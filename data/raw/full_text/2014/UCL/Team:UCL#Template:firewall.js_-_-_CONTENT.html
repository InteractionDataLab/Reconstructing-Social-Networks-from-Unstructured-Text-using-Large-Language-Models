<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_UCL_Template_firewall_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:UCL/Template:firewall.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:UCL/Template:firewall.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:UCL/Template:firewall.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:UCL/Template:firewall.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:UCL/Template:firewall.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:UCL/Template:firewall.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><P>// created by Minh Nguyen;
// version 1.04;
/*
Copyright (c) 2013 Minh Nguyen.
</P><P>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the &quot;Software&quot;), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
</P><P>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</P><P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
</P><UL><LI>/
</LI></UL><P>
(function($) {
</P><PRE>   // for zeptojs;
   $.isNumeric == null &amp;&amp; ($.isNumeric = function(src) {
       return src != null &amp;&amp; src.constructor === Number;
   });
</PRE><PRE>   $.isFunction == null &amp;&amp; ($.isFunction = function(src) {
       return src != null &amp;&amp; src instanceof Function;
   });
</PRE><PRE>   var $W = $(window);
   var $D = $(document);
   
   var layoutManager = {
       // default setting;
       defaultConfig: {
           animate: false,
           cache: true, // cache the size of blocks for performance;
           cellW: 100, // function(container) {return 100;}
           cellH: 100, // function(container) {return 100;}
           delay: 0, // slowdown active block;
           engine: 'giot', // 'giot' is a person name;
           fixSize: null, // resize + adjust = fill gap;
           //fixSize: 0, allow adjust size = no fill gap;
           //fixSize: 1, no resize + no adjust = no fill gap;
           gutterX: 15, // width spacing between blocks;
           gutterY: 15, // height spacing between blocks;
           selector: '&gt; div',
           draggable: false,
           rightToLeft: false,
           bottomToTop: false,
           onGapFound: function() {},
           onComplete: function() {},
           onResize: function() {},
           onBlockReady: function() {},
           onBlockFinish: function() {},
           onBlockActive: function() {},
           onBlockResize: function() {}
       },
       plugin: {},
       totalGrid: 1,
       transition: false,
       loadBlock: function(item, setting) {
           var runtime = setting.runtime;
           var gutterX = runtime.gutterX;
           var gutterY = runtime.gutterY;
           var cellH = runtime.cellH;
           var cellW = runtime.cellW;
           var block = null;
           var $item = $(item);
           var active = $item.data(&quot;active&quot;);
           var fixPos = $item.attr('data-position');
           var fixSize = parseInt($item.attr('data-fixSize'));
           var blockId = runtime.lastId++ + '-' + runtime.totalGrid;
           
           //ignore dragging block;
           if ($item.hasClass('fw-float')) return;
           $item.attr({id: blockId, 'data-delay': item.index});
</PRE><PRE>           //remove animation for speed render;
           if (setting.animate &amp;&amp; this.transition) {
               this.setTransition(item, &quot;&quot;);
           }
</PRE><PRE>           isNaN(fixSize) &amp;&amp; (fixSize = null);
           (fixSize == null) &amp;&amp; (fixSize = setting.fixSize);
           var makeRound = (fixSize == 1) ? &quot;ceil&quot; : &quot;round&quot;;
           // store original size;
          
           $item.attr('data-height') == null &amp;&amp; $item.attr('data-height', $item.height());
           $item.attr('data-width') == null &amp;&amp; $item.attr('data-width', $item.width());
           var height = 1 * $item.attr('data-height');
           var width = 1 * $item.attr('data-width');
           
           if (!setting.cache) {
               item.style.width = &quot;&quot;;
               width = $item.width();
</PRE><PRE>               item.style.height = &quot;&quot;;
               height = $item.height();
           }
</PRE><PRE>           var col = !width ? 0 : Math[makeRound]((width + gutterX) / cellW);
           var row = !height ? 0 : Math[makeRound]((height + gutterY) / cellH);
</PRE><PRE>           // estimate size;
           if (!fixSize &amp;&amp; setting.cellH == 'auto') {
               $item.width(cellW * col - gutterX);
               item.style.height = &quot;&quot;;
               height = $item.height();
               row = !height ? 0 : Math.round((height + gutterY) / cellH);
           }
</PRE><PRE>           if (!fixSize &amp;&amp; setting.cellW == 'auto') {
               $item.height(cellH * row - gutterY);
               item.style.width = &quot;&quot;;
               width = $item.width();
               col = !width ? 0 : Math.round((width + gutterX) / cellW);
           }
           
           // for none resize block;
           if ((fixSize != null) &amp;&amp; (col &gt; runtime.limitCol || row &gt; runtime.limitRow)) {
               block = null;
           } else {
               // get smallest width and smallest height of block;
               // using for image runtime;
               row &amp;&amp; row &lt; runtime.minHoB &amp;&amp; (runtime.minHoB = row);
               col &amp;&amp; col &lt; runtime.minWoB &amp;&amp; (runtime.minWoB = col);
</PRE><PRE>               // get biggest width and biggest height of block;
               row &gt; runtime.maxHoB &amp;&amp; (runtime.maxHoB = row);
               col &gt; runtime.maxWoB &amp;&amp; (runtime.maxWoB = col);
</PRE><PRE>               width == 0 &amp;&amp; (col = 0);
               height == 0 &amp;&amp; (row = 0);
</PRE><PRE>               block = {
                   resize: false,
                   id: blockId,
                   width: col,
                   height: row,
                   fixSize: fixSize
               };
</PRE><PRE>               // for fix position;
               if (fixPos) {
                   fixPos = fixPos.split(&quot;-&quot;);
                   block.y = 1 * fixPos[0];
                   block.x = 1 * fixPos[1];
                   block.width = fixSize != null ? col : Math.min(col, runtime.limitCol - block.x);
                   block.height = fixSize != null ? row : Math.min(row, runtime.limitRow - block.y);
                   var holeId = block.y + &quot;-&quot; + block.x + &quot;-&quot; + block.width + &quot;-&quot; + block.height;
                   if (active) {
                       runtime.holes[holeId] = {
                           id: block.id,
                           top: block.y,
                           left: block.x,
                           width: block.width,
                           height: block.height
                       };
                       this.setBlock(block, setting);
                   } else {
                       delete runtime.holes[holeId];
                   }
                   
               }
           }
</PRE><PRE>           // for css animation;
           if ($item.attr(&quot;data-state&quot;) == null) {
               $item.attr(&quot;data-state&quot;, &quot;init&quot;);
           } else {
               $item.attr(&quot;data-state&quot;, &quot;move&quot;);
           }
</PRE><PRE>           setting.onBlockReady.call(item, block, setting);
</PRE><PRE>           return (fixPos &amp;&amp; active) ? null : block;
       },
       setBlock: function(block, setting) {
           var runtime = setting.runtime;
           var gutterX = runtime.gutterX;
           var gutterY = runtime.gutterY;
           var height = block.height;
           var width = block.width;
           var cellH = runtime.cellH;
           var cellW = runtime.cellW;
           var x = block.x;
           var y = block.y;
</PRE><PRE>           if (setting.rightToLeft) {
               x = runtime.limitCol - x - width;
           }
           if (setting.bottomToTop) {
               y = runtime.limitRow - y - height;
           }
</PRE><PRE>           var realBlock = {
               fixSize: block.fixSize,
               resize: block.resize,
               top: y * cellH,
               left: x  * cellW,
               width: cellW * width - gutterX,
               height: cellH * height - gutterY
           };
           
           realBlock.top = 1 * realBlock.top.toFixed(2);
           realBlock.left = 1 * realBlock.left.toFixed(2);
           realBlock.width = 1 * realBlock.width.toFixed(2);
           realBlock.height = 1 * realBlock.height.toFixed(2);
</PRE><PRE>           //runtime.length += 1;
           block.id &amp;&amp; (runtime.blocks[block.id] = realBlock);
</PRE><PRE>           // for append feature;
           return realBlock;
       },
       showBlock: function(item, setting) {
           var runtime = setting.runtime;
           var method = setting.animate &amp;&amp; !this.transition ? 'animate' : 'css';
           var block = runtime.blocks[item.id];
           var $item = $(item);
           var self = this;
           var start = $item.attr(&quot;data-state&quot;) != &quot;move&quot;;
           var trans = start ? &quot;width 0.5s, height 0.5s&quot; : &quot;top 0.5s, left 0.5s, width 0.5s, height 0.5s, opacity 0.5s&quot;;
           
           item.delay &amp;&amp; clearTimeout(item.delay);
           //ignore dragging block;
           if ($item.hasClass('fw-float')) return;
           
           // kill the old transition;
           self.setTransition(item, &quot;&quot;);
           item.style.position = &quot;absolute&quot;;
           setting.onBlockActive.call(item, block, setting);
           
           function action() {
               // start to arrange;
               start &amp;&amp; $item.attr(&quot;data-state&quot;, &quot;start&quot;);
               // add animation by using css3 transition;
               if (setting.animate &amp;&amp; self.transition) {
                   self.setTransition(item, trans);
               }
</PRE><PRE>               // for hidden block;
               if (!block) {
                   //var position = $item.position(); &lt;= make speed so slow;
                   var height = parseInt(item.style.height) || 0;
                   var width = parseInt(item.style.width) || 0;
                   var left = parseInt(item.style.left) || 0;
                   var top = parseInt(item.style.top) || 0;
                   $item[method]({
                       left: left + width / 2,
                       top: top + height / 2,
                       width: 0,
                       height: 0,
                       opacity: 0
                   });
               } else {
                   if (block.fixSize) {
                       block.height = 1 * $item.attr(&quot;data-height&quot;);
                       block.width = 1 * $item.attr(&quot;data-width&quot;);
                   }
</PRE><PRE>                   $item[&quot;css&quot;]({
                       opacity: 1,
                       width: block.width,
                       height: block.height
                   });
</PRE><PRE>                   // for animating by javascript;
                   $item[method]({
                       top: block.top,
                       left: block.left
                   });
</PRE><PRE>                   if ($item.attr('data-nested') != null) {
                       self.nestedGrid(item, setting);
                   }
               }
</PRE><PRE>               runtime.length -= 1;
</PRE><PRE>               setting.onBlockFinish.call(item, block, setting);
</PRE><PRE>               runtime.length == 0 &amp;&amp; setting.onComplete.call(item, block, setting);
           }
</PRE><PRE>           block &amp;&amp; block.resize &amp;&amp; setting.onBlockResize.call(item, block, setting);
           
           setting.delay &gt; 0 ? (item.delay = setTimeout(action, setting.delay * $item.attr(&quot;data-delay&quot;))) : action(); 
       },
       nestedGrid: function(item, setting) {
           var innerWall, $item = $(item), runtime = setting.runtime;
           var gutterX = $item.attr(&quot;data-gutterX&quot;) || setting.gutterX;
           var gutterY = $item.attr(&quot;data-gutterY&quot;) || setting.gutterY;
           var method = $item.attr(&quot;data-method&quot;) || &quot;fitZone&quot;;
           var nested = $item.attr('data-nested') || &quot;&gt; div&quot;;
           var cellH = $item.attr(&quot;data-cellH&quot;) || setting.cellH;
           var cellW = $item.attr(&quot;data-cellW&quot;) || setting.cellW;
           var block = runtime.blocks[item.id];
           
           if (block) {
               innerWall = new freewall($item);
               innerWall.reset({
                   cellH: cellH,
                   cellW: cellW,
                   gutterX: 1 * gutterX,
                   gutterY: 1 * gutterY,
                   selector: nested
               });
</PRE><PRE>               switch (method) {
                   case &quot;fitHeight&quot;:
                       innerWall[method](block.height);
                       break;
                   case &quot;fitWidth&quot;:
                       innerWall[method](block.width);
                       break;
                   case &quot;fitZone&quot;:
                       innerWall[method](block.width, block.height);
                       break;
               }
           }
       },
       adjustBlock: function(block, setting) {
           var runtime = setting.runtime;
           var gutterX = runtime.gutterX;
           var gutterY = runtime.gutterY;
           var $item = $(&quot;#&quot; + block.id);
           var cellH = runtime.cellH;
           var cellW = runtime.cellW;
</PRE><PRE>           if (setting.cellH == 'auto') {
               $item.width(block.width * cellW - gutterX);
               $item[0].style.height = &quot;&quot;;
               block.height = Math.round(($item.height() + gutterY) / cellH);
           }
       },
       adjustUnit: function(width, height, setting) {
           var gutterX = setting.gutterX;
           var gutterY = setting.gutterY;
           var runtime = setting.runtime;
           var cellW = setting.cellW;
           var cellH = setting.cellH;
</PRE><PRE>           $.isFunction(cellW) &amp;&amp; (cellW = cellW(width));
           cellW = 1 * cellW;
           !$.isNumeric(cellW) &amp;&amp; (cellW = 1);
           
           $.isFunction(cellH) &amp;&amp; (cellH = cellH(height));
           cellH = 1 * cellH;
           !$.isNumeric(cellH) &amp;&amp; (cellH = 1);
</PRE><PRE>           if ($.isNumeric(width)) {
               // adjust cell width via container;
               cellW &lt; 1 &amp;&amp; (cellW = cellW * width);
</PRE><PRE>               // estimate total columns;
               var limitCol = Math.max(1, Math.floor(width / cellW));
</PRE><PRE>               // adjust unit size for fit width;
               if (!$.isNumeric(gutterX)) {
                   gutterX = (width - limitCol * cellW) / Math.max(1, (limitCol - 1));
                   gutterX = Math.max(0, gutterX);
               }
</PRE><PRE>               limitCol = Math.floor((width + gutterX) / cellW);
               runtime.cellW = (width + gutterX) / Math.max(limitCol, 1);
               runtime.cellS = runtime.cellW / cellW;
               runtime.gutterX = gutterX;
               runtime.limitCol = limitCol;
           } 
</PRE><PRE>           if ($.isNumeric(height)) {
               // adjust cell height via container;
               cellH &lt; 1 &amp;&amp; (cellH = cellH * height);
</PRE><PRE>               // estimate total rows;
               var limitRow = Math.max(1, Math.floor(height / cellH));
</PRE><PRE>               // adjust size unit for fit height;
               if (!$.isNumeric(gutterY)) {
                   gutterY = (height - limitRow * cellH) / Math.max(1, (limitRow - 1));
                   gutterY = Math.max(0, gutterY);
               }
</PRE><PRE>               limitRow = Math.floor((height + gutterY) / cellH);
               runtime.cellH = (height + gutterY) / Math.max(limitRow, 1);
               runtime.cellS = runtime.cellH / cellH;
               runtime.gutterY = gutterY;
               runtime.limitRow = limitRow;
           } 
</PRE><PRE>           if (!$.isNumeric(width)) {
               // adjust cell width via cell height;
               cellW &lt; 1 &amp;&amp; (cellW = runtime.cellH);
               runtime.cellW = cellW != 1 ? cellW * runtime.cellS : 1;
               runtime.gutterX = gutterX;
               runtime.limitCol = 666666;
           }
</PRE><PRE>           if (!$.isNumeric(height)) {
               // adjust cell height via cell width;
               cellH &lt; 1 &amp;&amp; (cellH = runtime.cellW);
               runtime.cellH = cellH != 1 ? cellH * runtime.cellS : 1;
               runtime.gutterY = gutterY;
               runtime.limitRow = 666666;
           }
       },
       resetGrid: function(runtime) {
           runtime.blocks = {};
           runtime.length = 0;
           runtime.cellH = 0;
           runtime.cellW = 0;
           runtime.lastId = 1;
           runtime.matrix = {};
           runtime.totalCol = 0;
           runtime.totalRow = 0;
       },
       setDraggable: function(item, option) {
           var isTouch = false;
           var config = {
               startX: 0, //start clientX;
               startY: 0, 
               top: 0,
               left: 0,
               handle: null,
               onDrop: function() {},
               onDrag: function() {},
               onStart: function() {}
           };
</PRE><PRE>           $(item).each(function() {
               var setting = $.extend({}, config, option);
               var handle = setting.handle || this;
               var ele = this;
               var $E = $(ele);
               var $H = $(handle);
</PRE><PRE>               var posStyle = $E.css(&quot;position&quot;);
               posStyle != &quot;absolute&quot; &amp;&amp; $E.css(&quot;position&quot;, &quot;relative&quot;);
               
</PRE><PRE>               function mouseDown(evt) {
                   evt.stopPropagation();
                   evt = evt.originalEvent;
</PRE><PRE>                   if (evt.touches) {
                       isTouch = true;
                       evt = evt.changedTouches[0];
                   }
</PRE><PRE>                   if (evt.button != 2 &amp;&amp; evt.which != 3) {
                       setting.onStart.call(ele, evt);
                       
                       setting.startX = evt.clientX;
                       setting.startY = evt.clientY;
                       setting.top = parseInt($E.css(&quot;top&quot;)) || 0;
                       setting.left = parseInt($E.css(&quot;left&quot;)) || 0;
                       
                       $D.bind(&quot;mouseup touchend&quot;, mouseUp);
                       $D.bind(&quot;mousemove touchmove&quot;, mouseMove); 
                   }
</PRE><PRE>                   return false;
               };
               
                       
               function mouseMove(evt) {
                   evt = evt.originalEvent;
                   isTouch &amp;&amp; (evt = evt.changedTouches[0]);
                   
                   $E.css({
                       top: setting.top - (setting.startY - evt.clientY),
                       left: setting.left - (setting.startX - evt.clientX)
                   });
                   
                   setting.onDrag.call(ele, evt);
               };
               
               function mouseUp(evt) {
                   evt = evt.originalEvent;
                   isTouch &amp;&amp; (evt = evt.changedTouches[0]);
       
                   setting.onDrop.call(ele, evt);
</PRE><PRE>                   $D.unbind(&quot;mouseup touchend&quot;, mouseUp);
                   $D.unbind(&quot;mousemove touchmove&quot;, mouseMove);
               };
</PRE><PRE>               // ignore drag drop on text field;
               $E.find(&quot;iframe, form, input, textarea, .ignore-drag&quot;)
               .each(function() {
                   $(this).on(&quot;touchstart mousedown&quot;, function(evt) {
                       evt.stopPropagation();
                   });
               });
               
               $D.unbind(&quot;mouseup touchend&quot;, mouseUp);
               $D.unbind(&quot;mousemove touchmove&quot;, mouseMove);
               $H.unbind(&quot;mousedown touchstart&quot;).bind(&quot;mousedown touchstart&quot;, mouseDown);
</PRE><PRE>           });
       },
       setTransition: function(item, trans) {
           var style = item.style;
           var $item = $(item);
               
           // remove animation;
           if (!this.transition &amp;&amp; $item.stop) {
               $item.stop();
           } else if (style.webkitTransition != null) {
               style.webkitTransition = trans;
           } else if (style.MozTransition != null) {
               style.MozTransition = trans;
           } else if (style.msTransition != null) {
               style.msTransition = trans;
           } else if (style.OTransition != null) {
               style.OTransition = trans;
           } else {
               style.transition = trans;
           }
       },
       getFreeArea: function(t, l, runtime) {
           var maxY = Math.min(t + runtime.maxHoB, runtime.limitRow);
           var maxX = Math.min(l + runtime.maxWoB, runtime.limitCol);
           var minX = maxX;
           var minY = maxY;
           var matrix = runtime.matrix;
           
           // find limit zone by horizon;
           for (var y = t; y &lt; minY; ++y) {
               for (var x = l; x &lt; maxX; ++x) {
                   if (matrix[y + '-' + x]) {
                       (l &lt; x &amp;&amp; x &lt; minX) &amp;&amp; (minX = x);
                   }
               }
           }
           
           // find limit zone by vertical;
           for (var y = t; y &lt; maxY; ++y) {
               for (var x = l; x &lt; minX; ++x) {
                   if (matrix[y + '-' + x]) {
                       (t &lt; y &amp;&amp; y &lt; minY) &amp;&amp; (minY = y);
                   }
               }
           }
</PRE><PRE>           return {
               top: t,
               left: l,
               width: minX - l,
               height: minY - t
           };
</PRE><PRE>       },
       setWallSize: function(runtime, container) {
           var totalRow = runtime.totalRow;
           var totalCol = runtime.totalCol;
           var gutterY = runtime.gutterY;
           var gutterX = runtime.gutterX;
           var cellH = runtime.cellH;
           var cellW = runtime.cellW;
           var totalWidth = Math.max(0, cellW * totalCol - gutterX);
           var totalHeight = Math.max(0, cellH * totalRow - gutterY);
           
           container.attr({
               'data-total-col': totalCol,
               'data-total-row': totalRow,
               'data-wall-width': Math.ceil(totalWidth),
               'data-wall-height': Math.ceil(totalHeight)
           });
</PRE><PRE>           if (runtime.limitCol &lt; runtime.limitRow) {
               // do not set height with nesting grid;
               !container.attr(&quot;data-height&quot;) &amp;&amp; container.height(Math.ceil(totalHeight));
           }
       }
   };
</PRE><PRE>   var engine = {
       // Giot just a person name;
       giot: function(items, setting) {
           var runtime = setting.runtime,
               row = runtime.limitRow,
               col = runtime.limitCol,
               x = 0,
               y = 0,
               maxX = runtime.totalCol,
               maxY = runtime.totalRow,
               wall = {},
               holes = runtime.holes,
               block = null,
               matrix = runtime.matrix,
               bigLoop = Math.max(col, row),
               freeArea = null,
               misBlock = null,
               fitWidth = col &lt; row ? 1 : 0,
               lastBlock = null,
               smallLoop = Math.min(col, row);
</PRE><PRE>           // fill area with top, left, width, height;
           function fillMatrix(id, t, l, w, h) {
               for (var y = t; y &lt; t + h;) {
                   for (var x = l; x &lt; l + w;) {
                       matrix[y + '-' + x] = id;
                       ++x &gt; maxX &amp;&amp; (maxX = x);
                   }
                   ++y &gt; maxY &amp;&amp; (maxY = y);
               }
           }
           
           // set a hole on the wall;
           for (var i in holes) {
               if (holes.hasOwnProperty(i)) {
                   fillMatrix(holes[i][&quot;id&quot;] || true, holes[i]['top'], holes[i]['left'], holes[i]['width'], holes[i]['height']);
               }
           }
           
</PRE><PRE>           for (var b = 0; b &lt; bigLoop; ++b) {
               if (!items.length) break;
               fitWidth ? (y = b) : (x = b);
               lastBlock = null;
</PRE><PRE>               for (var s = 0; s &lt; smallLoop; ++s) {
                   if (!items.length) break;
                   fitWidth ? (x = s) : (y = s);
                   if (runtime.matrix[y + '-' + x]) continue;
                   freeArea = layoutManager.getFreeArea(y, x, runtime);
                   block = null;
                   for (var i = 0; i &lt; items.length; ++i) {
                       if (items[i].height &gt; freeArea.height) continue;
                       if (items[i].width &gt; freeArea.width) continue;
                       block = items.splice(i, 1)[0];
                       break;
                   }
</PRE><PRE>                   // trying resize the other block to fit gap;
                   if (block == null &amp;&amp; setting.fixSize == null) {
                       // resize near block to fill gap;
                       if (lastBlock &amp;&amp; !fitWidth &amp;&amp; runtime.minHoB &gt; freeArea.height) {
                           lastBlock.height += freeArea.height;
                           lastBlock.resize = true;
                           fillMatrix(lastBlock.id, lastBlock.y, lastBlock.x, lastBlock.width, lastBlock.height);
                           layoutManager.setBlock(lastBlock, setting);
                           continue;
                       } else if (lastBlock &amp;&amp; fitWidth &amp;&amp; runtime.minWoB &gt; freeArea.width) {
                           lastBlock.width += freeArea.width;
                           lastBlock.resize = true;
                           fillMatrix(lastBlock.id, lastBlock.y, lastBlock.x, lastBlock.width, lastBlock.height);
                           layoutManager.setBlock(lastBlock, setting);
                           continue;
                       } else {
                           // get other block fill to gap;
                           for (var i = 0; i &lt; items.length; ++i) {
                               if (items[i]['fixSize'] != null) continue;
                               block = items.splice(i, 1)[0];
                               block.resize = true;
                               if (fitWidth) {
                                   block.width = freeArea.width;
                                   if (setting.cellH == 'auto') {
                                       layoutManager.adjustBlock(block, setting);
                                   }
                                   // for fitZone;
                                   block.height = Math.min(block.height, freeArea.height);
                               } else {
                                   block.height = freeArea.height;
                                   // for fitZone;
                                   block.width = Math.min(block.width, freeArea.width);
                               }
                               break;
                           }
                       }
</PRE><PRE>                   }
                   
                   if (block != null) {
                       wall[block.id] = {
                           id: block.id,
                           x: x,
                           y: y,
                           width: block.width,
                           height: block.height,
                           resize: block.resize,
                           fixSize: block.fixSize
                       };
                       
                       // keep success block for next round;
                       lastBlock = wall[block.id];
</PRE><PRE>                       fillMatrix(lastBlock.id, lastBlock.y, lastBlock.x, lastBlock.width, lastBlock.height);
                       layoutManager.setBlock(lastBlock, setting);
                   } else {
                       // get expect area;
                       var misBlock = {
                           x: x,
                           y: y,
                           fixSize: 0
                       };
                       if (fitWidth) {
                           misBlock.width = freeArea.width;
                           misBlock.height = 0;
                           var lastX = x - 1;
                           var lastY = y;
                           
                           while (matrix[lastY + '-' + lastX]) {
                               matrix[lastY + '-' + x] = true;
                               misBlock.height += 1;
                               lastY += 1;
                           }
                       } else {
                           misBlock.height = freeArea.height;
                           misBlock.width = 0;
                           var lastY = y - 1;
                           var lastX = x;
                           
                           while (matrix[lastY + '-' + lastX]) {
                               matrix[y + '-' + lastX] = true;
                               misBlock.width += 1;
                               lastX += 1;
                           }
                       }
                       setting.onGapFound(layoutManager.setBlock(misBlock, setting), setting);
                   }
               }
</PRE><PRE>           }
</PRE><PRE>           runtime.matrix = matrix;
           runtime.totalRow = maxY;
           runtime.totalCol = maxX;
       }
   };
</PRE><PRE>   window.freewall = function(selector) {
       
       var container = $(selector);
       if (container.css('position') == 'static') {
           container.css('position', 'relative');
       }
       var MAX = Number.MAX_VALUE;
       var klass = this;
       // increase the instance index;
       layoutManager.totalGrid += 1;
</PRE><PRE>       var setting = $.extend({}, layoutManager.defaultConfig);
       var runtime = {
           blocks: {}, // store all items;
           events: {}, // store custome events;
           matrix: {},
           holes: {}, // forbidden zone;
           
           cellW: 0,
           cellH: 0, // unit adjust;
           cellS: 1, // unit scale;
           
           filter: <I>, // filter selector;</I>
           
           lastId: 0,
           length: 0,
</PRE><PRE>           maxWoB: 0, // max width of block;
           maxHoB: 0,
           minWoB: MAX, 
           minHoB: MAX, // min height of block;
</PRE><PRE>           running: 0, // flag to check layout arranging;
</PRE><PRE>           gutterX: 15, 
           gutterY: 15,
</PRE><PRE>           totalCol: 0,
           totalRow: 0,
</PRE><PRE>      limitCol: 666666, // maximum column; 
           limitRow: 666666,
           
           currentMethod: null,
           currentArguments: []
       };
       setting.runtime = runtime;
       runtime.totalGrid = layoutManager.totalGrid;
       
       // check browser support transition;
       var bodyStyle = document.body.style;
       if (!layoutManager.transition) {
           (bodyStyle.webkitTransition != null ||
           bodyStyle.MozTransition != null ||
           bodyStyle.msTransition != null ||
           bodyStyle.OTransition != null ||
           bodyStyle.transition != null) &amp;&amp;
           (layoutManager.transition = true);
       }
       
</PRE><PRE>       function setDraggable(item) {
           
           var gutterX = runtime.gutterX;
           var gutterY = runtime.gutterY;
           var cellH = runtime.cellH;
           var cellW = runtime.cellW;
           var $item = $(item);
           var handle = $item.find($item.attr(&quot;data-handle&quot;));
           layoutManager.setDraggable(item, {
               handle: handle[0],
               onStart: function(event) {
                   if (setting.animate &amp;&amp; layoutManager.transition) {
                       layoutManager.setTransition(this, &quot;&quot;);
                   }
                   $item.css('z-index', 9999).addClass('fw-float');
</PRE><PRE>                   if (setting.draggable &amp;&amp; setting.draggable.onDragStart) {
                       setting.draggable.onDragStart.call(item, event);
                   }
               },
               onDrag: function(event, tracker) {
                   var position = $item.position();
                   var top = Math.round(position.top / cellH);
                   var left = Math.round(position.left / cellW);
                   var width = Math.round($item.width() / cellW);
                   var height = Math.round($item.height() / cellH);
                   top = Math.min(Math.max(0, top), runtime.limitRow - height);
                   left = Math.min(Math.max(0, left), runtime.limitCol - width);
                   klass.setHoles({top: top, left: left, width: width, height: height});
                   klass.refresh();
</PRE><PRE>                   if (setting.draggable &amp;&amp; setting.draggable.onDrag) {
                       setting.draggable.onDrag.call(item, event);
                   }
               },
               onDrop: function(event) {
                   var position = $item.position();
                   var top = Math.round(position.top / cellH);
                   var left = Math.round(position.left / cellW);
                   var width = Math.round($item.width() / cellW);
                   var height = Math.round($item.height() / cellH);
                   top = Math.min(Math.max(0, top), runtime.limitRow - height);
                   left = Math.min(Math.max(0, left), runtime.limitCol - width);
</PRE><PRE>                   $item.removeClass('fw-float');
                   $item.css({
                       zIndex: &quot;auto&quot;,
                       top: top * cellH,
                       left: left * cellW
                   });
                   
                   //check old drag element;
                   var x, y, key, oldDropId;
                   for (y = 0; y &lt; height; ++y) {
                       for (x = 0; x &lt; width; ++x) {
                           key = (y + top) + &quot;-&quot; + (x + left);
                           oldDropId = runtime.matrix[key];
                           if (oldDropId &amp;&amp; oldDropId != true) {
                               $(&quot;#&quot; + oldDropId).removeAttr(&quot;data-position&quot;);
                           }
                       }
                   }
                   
                   runtime.holes = {};
                   
                   $item.attr({
                       &quot;data-width&quot;: $item.width(),
                       &quot;data-height&quot;: $item.height(),
                       &quot;data-position&quot;: top + &quot;-&quot; + left
                   });
</PRE><PRE>                   klass.refresh();
</PRE><PRE>                   if (setting.draggable &amp;&amp; setting.draggable.onDrop) {
                       setting.draggable.onDrop.call(item, event);
                   }
               }
           });
       }
       
</PRE><PRE>       $.extend(klass, {
           
           addCustomEvent: function(name, func) {
               var events = runtime.events;
               name = name.toLowerCase();
               !events[name] &amp;&amp; (events[name] = []);
               func.eid = events[name].length;
               events[name].push(func);
               return this;
           },
</PRE><PRE>           appendBlock: function(items) {
               var allBlock = $(items).appendTo(container);
               var block = null;
               var activeBlock = [];
               
               if (runtime.currentMethod) {
                   allBlock.each(function(index, item) {
                       item.index = ++index;
                       if (block = layoutManager.loadBlock(item, setting)) {
                           activeBlock.push(block);
                       }
                   });
               
                   engine[setting.engine](activeBlock, setting);
                   
                   layoutManager.setWallSize(runtime, container);
                   
                   runtime.length = allBlock.length;
</PRE><PRE>                   allBlock.each(function(index, item) {
                       layoutManager.showBlock(item, setting);
                       if (setting.draggable || item.getAttribute('data-draggable')) {
                           setDraggable(item);
                       }
                   });
               }
           },
           /*
           add one or more blank area (hole) on layout;
           example:
               
               wall.appendHoles({
                   top: 10,
                   left: 36,
                   width: 2,
                   height: 6
               });
</PRE><PRE>               wall.appendHoles([
                   {
                       top: 16,
                       left: 16,
                       width: 8,
                       height: 2
                   },
                   {
                       top: 10,
                       left: 36,
                       width: 2,
                       height: 6
                   }
               ]);
</PRE><PRE>           */
           appendHoles: function(holes) {
               var newHoles = [].concat(holes), h = {}, i;
               for (i = 0; i &lt; newHoles.length; ++i) {
                   h = newHoles[i];
                   runtime.holes[h.top + &quot;-&quot; + h.left + &quot;-&quot; + h.width + &quot;-&quot; + h.height] = h;
               }
               return this;
           },
</PRE><PRE>           container: container,
</PRE><PRE>           destroy: function() {
               var allBlock = container.find(setting.selector).removeAttr('id'),
                   block = null,
                   activeBlock = [];
</PRE><PRE>               allBlock.each(function(index, item) {
                   $item = $(item);
                   var width = 1 * $item.attr('data-width') || &quot;&quot;;
                   var height = 1 * $item.attr('data-height') || &quot;&quot;;
                   $item.width(width).height(height).css({
                       position: 'static'
                   });
               });
           },
</PRE><PRE>           fillHoles: function(holes) {
               if (arguments.length == 0) {
                   runtime.holes = {};
               } else {
                   var newHoles = [].concat(holes), h = {}, i;
                   for (i = 0; i &lt; newHoles.length; ++i) {
                       h = newHoles[i];
                       delete runtime.holes[h.top + &quot;-&quot; + h.left + &quot;-&quot; + h.width + &quot;-&quot; + h.height];
                   }
               }
               return this;
           },
</PRE><PRE>           filter: function(filter) {
               runtime.filter = filter;
               runtime.currentMethod &amp;&amp; this.refresh();
               return this;
           },
</PRE><PRE>           fireEvent: function(name, object, setting) {
               var events = runtime.events;
               name = name.toLowerCase();
               if (events[name] &amp;&amp; events[name].length) {
                   for (var i = 0; i &lt; events[name].length; ++i) {
                       events[name][i].call(this, object, setting);
                   }
               }
               return this;
           },
</PRE><PRE>           fitHeight: function(height) {
               var allBlock = container.find(setting.selector).removeAttr('id'),
                   block = null,
                   activeBlock = [];
</PRE><PRE>               height = height ? height : container.height() || $W.height();
               
               runtime.currentMethod = arguments.callee;
               runtime.currentArguments = arguments;
               
               layoutManager.resetGrid(runtime);
               layoutManager.adjustUnit('auto', height, setting);
               
               if (runtime.filter) {
                   allBlock.data('active', 0);
                   allBlock.filter(runtime.filter).data('active', 1);
               } else {
                   allBlock.data('active', 1);
               }
</PRE><PRE>               allBlock.each(function(index, item) {
                   var $item = $(item);
                   item.index = ++index;
                   if (block = layoutManager.loadBlock(item, setting)) {
                       $item.data(&quot;active&quot;) &amp;&amp; activeBlock.push(block);
                   }
               });
               
               klass.fireEvent('onGridReady', container, setting);
</PRE><PRE>               engine[setting.engine](activeBlock, setting);
               
               layoutManager.setWallSize(runtime, container);
</PRE><PRE>               klass.fireEvent('onGridArrange', container, setting);
</PRE><PRE>               runtime.length = allBlock.length;
</PRE><PRE>               allBlock.each(function(index, item) {
                   layoutManager.showBlock(item, setting);
                   if (setting.draggable || item.getAttribute('data-draggable')) {
                       setDraggable(item);
                   }
               });
           },
</PRE><PRE>           fitWidth: function(width) {
               var allBlock = container.find(setting.selector).removeAttr('id'),
                   block = null,
                   activeBlock = [];
</PRE><PRE>               width = width ? width : container.width() || $W.width();
</PRE><PRE>               runtime.currentMethod = arguments.callee;
               runtime.currentArguments = arguments;
               
               layoutManager.resetGrid(runtime);
               layoutManager.adjustUnit(width, 'auto', setting);
               
               if (runtime.filter) {
                   allBlock.data('active', 0);
                   allBlock.filter(runtime.filter).data('active', 1);
               } else {
                   allBlock.data('active', 1);
               }
               
               allBlock.each(function(index, item) {
                   var $item = $(item);
                   item.index = ++index;
                   if (block = layoutManager.loadBlock(item, setting)) {
                       $item.data(&quot;active&quot;) &amp;&amp; activeBlock.push(block);
                   }
               });
               
               klass.fireEvent('onGridReady', container, setting);
               
               engine[setting.engine](activeBlock, setting);
</PRE><PRE>               layoutManager.setWallSize(runtime, container);
               
               klass.fireEvent('onGridArrange', container, setting);
</PRE><PRE>               runtime.length = allBlock.length;
</PRE><PRE>               allBlock.each(function(index, item) {
                   layoutManager.showBlock(item, setting);
                   if (setting.draggable || item.getAttribute('data-draggable')) {
                       setDraggable(item);
                   }
               });
           },
</PRE><PRE>           fitZone: function(width, height) {
               var allBlock = container.find(setting.selector).removeAttr('id'),
                   block = null,
                   activeBlock = [];
</PRE><PRE>               height = height ? height : container.height() || $W.height();
               width = width ? width : container.width() || $W.width();
               
               runtime.currentMethod = arguments.callee;
               runtime.currentArguments = arguments;
               
               layoutManager.resetGrid(runtime);
               layoutManager.adjustUnit(width, height, setting);
</PRE><PRE>               if (runtime.filter) {
                   allBlock.data('active', 0);
                   allBlock.filter(runtime.filter).data('active', 1);
               } else {
                   allBlock.data('active', 1);
               }
               
               allBlock.each(function(index, item) {
                   var $item = $(item);
                   item.index = ++index;
                   if (block = layoutManager.loadBlock(item, setting)) {
                       $item.data(&quot;active&quot;) &amp;&amp; activeBlock.push(block);
                   }
               });
</PRE><PRE>               klass.fireEvent('onGridReady', container, setting);
</PRE><PRE>               engine[setting.engine](activeBlock, setting);
               
               layoutManager.setWallSize(runtime, container);
               
               klass.fireEvent('onGridArrange', container, setting);
</PRE><PRE>               runtime.length = allBlock.length;
              
               allBlock.each(function(index, item) {
                   layoutManager.showBlock(item, setting);
                   if (setting.draggable || item.getAttribute('data-draggable')) {
                       setDraggable(item);
                   }
               });
           },
</PRE><PRE>           /*
           set block with special position, the top and left are multiple of unit width/height;
           example:
</PRE><PRE>               wall.fixPos({
                   top: 0,
                   left: 0,
                   block: $('.free')
               });
           */
           fixPos: function(option) {
               $(option.block).attr({'data-position': option.top + &quot;-&quot; + option.left});
               return this;
           },
</PRE><PRE>           /*
           set block with special size, the width and height are multiple of unit width/height;
           example:
</PRE><PRE>               wall.fixSize({
                   height: 5,
                   width: 2,
                   block: $('.free')
               });
           */
           fixSize: function(option) {
               option.height != null &amp;&amp; $(option.block).attr({'data-height': option.height});
               option.width != null &amp;&amp; $(option.block).attr({'data-width': option.width});
               return this;
           },
</PRE><PRE>           prepend: function(items) {
               container.prepend(items);
               runtime.currentMethod &amp;&amp; this.refresh();
               return this;
           },
</PRE><PRE>           refresh: function() {
               var params = arguments.length ? arguments : runtime.currentArguments;
               runtime.currentMethod == null &amp;&amp; (runtime.currentMethod = this.fitWidth);
               runtime.currentMethod.apply(this, Array.prototype.slice.call(params, 0));
               return this;
           },
</PRE><PRE>           /*
           custom layout setting;
           example:
</PRE><PRE>               wall.reset({
                   selector: '.brick',
                   animate: true,
                   cellW: 160,
                   cellH: 160,
                   delay: 50,
                   onResize: function() {
                       wall.fitWidth();
                   }
               });
           */
           reset: function(option) {
               $.extend(setting, option);
               return this;
           },
           
           /*
           create one or more blank area (hole) on layout;
           example:
               
               wall.setHoles({
                   top: 2,
                   left: 2,
                   width: 2,
                   height: 2
               });
           */
           
           setHoles: function(holes) {
               var newHoles = [].concat(holes), h = {}, i;
               runtime.holes = {};
               for (i = 0; i &lt; newHoles.length; ++i) {
                   h = newHoles[i];
                   runtime.holes[h.top + &quot;-&quot; + h.left + &quot;-&quot; + h.width + &quot;-&quot; + h.height] = h;
               }
               return this;
           },
</PRE><PRE>           unFilter: function() {
               delete runtime.filter;
               this.refresh();
               return this;
           }
       });
       
       container.attr('data-min-width', Math.floor($W.width() / 80) * 80);
       // execute plugins;
       for (var i in layoutManager.plugin) {
           if (layoutManager.plugin.hasOwnProperty(i)) {
               layoutManager.plugin[i].call(klass, setting, container);
           }
       }
</PRE><PRE>       // setup resize event;
       $W.resize(function() {
           if (runtime.running) return;
           runtime.running = 1;
           setTimeout(function() {
               runtime.running = 0;
               setting.onResize.call(klass, container);
           }, 122);
           container.attr('data-min-width', Math.floor($W.width() / 80) * 80);
       });
   };
</PRE><PRE>   /*
   add default setting;
   example:
</PRE><PRE>       freewall.addConfig({
           offsetLeft: 0
       });
   */
   freewall.addConfig = function(newConfig) {
       // add default setting;
       $.extend(layoutManager.defaultConfig, newConfig);    
   };
   
</PRE><PRE>   /*
   support create new arrange algorithm;
   example:
</PRE><PRE>       freewall.createEngine({
           slice: function(items, setting) {
               // slice engine;
           }
       });
   */
   freewall.createEngine = function(engineData) {
       // create new engine;
       $.extend(engine, engineData);
   };
   
   /*
   support create new plugin;
   example:
       
       freewall.createPlugin({
           centering: function(setting, container) {
               console.log(this);
               console.log(setting);
           }
       })l
   */
   freewall.createPlugin = function(pluginData) {
       // register new plugin;
       $.extend(layoutManager.plugin, pluginData);
   };
</PRE><PRE>   /*
   support access helper function;
   example:
</PRE><PRE>       freewall.getMethod('setBlock')(block, setting);
   */
   freewall.getMethod = function(method) {
       // get helper method;
       return layoutManager[method];
   };

</PRE><P>})(window.Zepto || window.jQuery);
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:UCL/Template:firewall.js">http://2014.igem.org/Team:UCL/Template:firewall.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:UCL/Template:firewall.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:UCL/Template:firewall.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:UCL/Template:firewall.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:UCL/Template:firewall.js&amp;oldid=242283" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
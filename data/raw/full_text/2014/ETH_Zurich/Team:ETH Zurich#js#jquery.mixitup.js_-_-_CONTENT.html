<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_ETH_Zurich_js_jquery_mixitup_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:ETH_Zurich/js/jquery.mixitup.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:ETH_Zurich/js/jquery.mixitup.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:ETH_Zurich/js/jquery.mixitup.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:ETH_Zurich/js/jquery.mixitup.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:ETH_Zurich/js/jquery.mixitup.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:ETH Zurich/js/jquery.mixitup.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><P>/**!
</P><PRE>* MixItUp v2.1.6
*
* @copyright Copyright 2014 KunkaLabs Limited.
* @author    KunkaLabs Limited.
* @link      <A href="https://mixitup.kunkalabs.com" class="external free" rel="nofollow">https://mixitup.kunkalabs.com</A>
*
* @license   Commercial use requires a commercial license.
*            <A href="https://mixitup.kunkalabs.com/licenses/" class="external free" rel="nofollow">https://mixitup.kunkalabs.com/licenses/</A>
*
*            Non-commercial use permitted under terms of CC-BY-NC license.
*            <A href="http://creativecommons.org/licenses/by-nc/3.0/" class="external free" rel="nofollow">http://creativecommons.org/licenses/by-nc/3.0/</A>
*/
</PRE><P>(function($, undf){
</P><P>	/**
	 * MixItUp Constructor Function
	 * @constructor
	 * @extends jQuery
	 */
</P><P>	$.MixItUp = function(){
		var self = this;
</P><P>		self._execAction('_constructor', 0);
</P><P>		$.extend(self, {
</P><P>			/* Public Properties
			---------------------------------------------------------------------- */
</P><P>			selectors: {
				target: '.mix',
				filter: '.filter',
				sort: '.sort'
			},
</P><P>			animation: {
				enable: true,
				effects: 'fade scale',
				duration: 600,
				easing: 'ease',
				perspectiveDistance: '3000',
				perspectiveOrigin: '50% 50%',
				queue: true,
				queueLimit: 1,
				animateChangeLayout: false,
				animateResizeContainer: true,
				animateResizeTargets: false,
				staggerSequence: false,
				reverseOut: false
			},
</P><P>			callbacks: {
				onMixLoad: false,
				onMixStart: false,
				onMixBusy: false,
				onMixEnd: false,
				onMixFail: false,
				_user: false
			},
</P><P>			controls: {
				enable: true,
				live: false,
				toggleFilterButtons: false,
				toggleLogic: 'or',
				activeClass: 'active'
			},
</P><P>			layout: {
				display: 'block',
				containerClass: <I>,</I>
				containerClassFail: 'fail'
			},
</P><P>			load: {
				filter: 'all',
				sort: false
			},
</P><P>			/* Private Properties
			---------------------------------------------------------------------- */
</P><P>			_$body: null,
			_$container: null,
			_$targets: null,
			_$parent: null,
			_$sortButtons: null,
			_$filterButtons: null,
</P><P>			_suckMode: false,
			_mixing: false,
			_sorting: false,
			_clicking: false,
			_loading: true,
			_changingLayout: false,
			_changingClass: false,
			_changingDisplay: false,
</P><P>			_origOrder: [],
			_startOrder: [],
			_newOrder: [],
			_activeFilter: null,
			_toggleArray: [],
			_toggleString: <I>,</I>
			_activeSort: 'default:asc',
			_newSort: null,
			_startHeight: null,
			_newHeight: null,
			_incPadding: true,
			_newDisplay: null,
			_newClass: null,
			_targetsBound: 0,
			_targetsDone: 0,
			_queue: [],
</P><P>			_$show: $(),
			_$hide: $()
		});
</P><P>		self._execAction('_constructor', 1);
	};
</P><P>	/**
	 * MixItUp Prototype
	 * @override
	 */
</P><P>	$.MixItUp.prototype = {
		constructor: $.MixItUp,
</P><P>		/* Static Properties
		---------------------------------------------------------------------- */
</P><P>		_instances: {},
		_handled: {
			_filter: {},
			_sort: {}
		},
		_bound: {
			_filter: {},
			_sort: {}
		},
		_actions: {},
		_filters: {},
</P><P>		/* Static Methods
		---------------------------------------------------------------------- */
</P><P>		/**
		 * Extend
		 * @since 2.1.0
		 * @param {object} new properties/methods
		 * @extends {object} prototype
		 */
</P><P>		extend: function(extension){
			for(var key in extension){
				$.MixItUp.prototype[key] = extension[key];
			}
		},
</P><P>		/**
		 * Add Action
		 * @since 2.1.0
		 * @param {string} hook name
		 * @param {string} namespace
		 * @param {function} function to execute
		 * @param {number} priority
		 * @extends {object} $.MixItUp.prototype._actions
		 */
</P><P>		addAction: function(hook, name, func, priority){
			$.MixItUp.prototype._addHook('_actions', hook, name, func, priority);
		},
</P><P>		/**
		 * Add Filter
		 * @since 2.1.0
		 * @param {string} hook name
		 * @param {string} namespace
		 * @param {function} function to execute
		 * @param {number} priority
		 * @extends {object} $.MixItUp.prototype._filters
		 */
</P><P>		addFilter: function(hook, name, func, priority){
			$.MixItUp.prototype._addHook('_filters', hook, name, func, priority);
		},
</P><P>		/**
		 * Add Hook
		 * @since 2.1.0
		 * @param {string} type of hook
		 * @param {string} hook name
		 * @param {function} function to execute
		 * @param {number} priority
		 * @extends {object} $.MixItUp.prototype._filters
		 */
</P><P>		_addHook: function(type, hook, name, func, priority){
			var collection = $.MixItUp.prototype[type],
				obj = {};
</P><P>			priority = (priority === 1 || priority === 'post') ? 'post' : 'pre';
</P><P>			obj[hook] = {};
			obj[hook][priority] = {};
			obj[hook][priority][name] = func;
</P><P>			$.extend(true, collection, obj);
		},
</P><P>		
		/* Private Methods
		---------------------------------------------------------------------- */
</P><P>		/**
		 * Initialise
		 * @since 2.0.0
		 * @param {object} domNode
		 * @param {object} config
		 */
</P><P>		_init: function(domNode, config){
			var self = this;
</P><P>			self._execAction('_init', 0, arguments);
</P><P>			config &amp;&amp; $.extend(true, self, config);
</P><P>			self._$body = $('body');
			self._domNode = domNode;
			self._$container = $(domNode);
			self._$container.addClass(self.layout.containerClass);
			self._id = domNode.id;
</P><P>			self._platformDetect();
</P><P>			self._brake = self._getPrefixedCSS('transition', 'none');
</P><P>			self._refresh(true);
</P><P>			self._$parent = self._$targets.parent().length ? self._$targets.parent() : self._$container;
</P><P>			if(self.load.sort){
				self._newSort = self._parseSort(self.load.sort);
				self._newSortString = self.load.sort;
				self._activeSort = self.load.sort;
				self._sort();
				self._printSort();
			}
</P><P>			self._activeFilter = self.load.filter === 'all' ? 
				self.selectors.target : 
				self.load.filter === 'none' ?
					<I> :</I>
					self.load.filter;
</P><P>			self.controls.enable &amp;&amp; self._bindHandlers();
</P><P>			if(self.controls.toggleFilterButtons){
				self._buildToggleArray();
</P><P>				for(var i = 0; i &lt; self._toggleArray.length; i++){
					self._updateControls({filter: self._toggleArray[i], sort: self._activeSort}, true);
				};
			} else if(self.controls.enable){
				self._updateControls({filter: self._activeFilter, sort: self._activeSort});
			}
</P><P>			self._filter();
</P><P>			self._init = true;
</P><P>			self._$container.data('mixItUp',self);
</P><P>			self._execAction('_init', 1, arguments);
</P><P>			self._buildState();
</P><P>			self._$targets.css(self._brake);
</P><P>			self._goMix(self.animation.enable);
		},
</P><P>		/**
		 * Platform Detect
		 * @since 2.0.0
		 */
</P><P>		_platformDetect: function(){
			var self = this,
				vendorsTrans = ['Webkit', 'Moz', 'O', 'ms'],
				vendorsRAF = ['webkit', 'moz'],
				chrome = window.navigator.appVersion.match(/Chrome\/(\d+)\./) || false,
				ff = typeof InstallTrigger !== 'undefined',
				prefix = function(el){
					for (var i = 0; i &lt; vendorsTrans.length; i++){
						if (vendorsTrans[i] + 'Transition' in el.style){
							return {
								prefix: '-'+vendorsTrans[i].toLowerCase()+'-',
								vendor: vendorsTrans[i]
							};
						};
					}; 
					return 'transition' in el.style ? <I> : false;</I>
				},
				transPrefix = prefix(self._domNode);
</P><P>			self._execAction('_platformDetect', 0);
</P><P>			self._chrome = chrome ? parseInt(chrome[1], 10) : false;
			self._ff = ff ? parseInt(window.navigator.userAgent.match(/rv:([^)]+)\)/)[1]) : false;
			self._prefix = transPrefix.prefix;
			self._vendor = transPrefix.vendor;
			self._suckMode = window.atob &amp;&amp; self._prefix ? false : true;
</P><P>			self._suckMode &amp;&amp; (self.animation.enable = false);
			(self._ff &amp;&amp; self._ff &lt;= 4) &amp;&amp; (self.animation.enable = false);
</P><P>			/* Polyfills
			---------------------------------------------------------------------- */
</P><P>			/**
			 * window.requestAnimationFrame
			 */
</P><P>			for(var x = 0; x &lt; vendorsRAF.length &amp;&amp; !window.requestAnimationFrame; x++){
				window.requestAnimationFrame = window[vendorsRAF[x]+'RequestAnimationFrame'];
			}
</P><P>			/**
			 * Object.getPrototypeOf
			 */
</P><P>			if(typeof Object.getPrototypeOf !== 'function'){
				if(typeof 'test'.__proto__ === 'object'){
					Object.getPrototypeOf = function(object){
						return object.__proto__;
					};
				} else {
					Object.getPrototypeOf = function(object){
						return object.constructor.prototype;
					};
				}
			}
</P><P>			/**
			 * Element.nextElementSibling
			 */
</P><P>			if(self._domNode.nextElementSibling === undf){
				Object.defineProperty(Element.prototype, 'nextElementSibling',{
					get: function(){
						var el = this.nextSibling;
</P><P>						while(el){
							if(el.nodeType ===1){
								return el;
							}
							el = el.nextSibling;
						}
						return null;
					}
				});
			}
</P><P>			self._execAction('_platformDetect', 1);
		},
</P><P>		/**
		 * Refresh
		 * @since 2.0.0
		 * @param {boolean} init
		 * @param {boolean} force
		 */
</P><P>		_refresh: function(init, force){
			var self = this;
</P><P>			self._execAction('_refresh', 0, arguments);
</P><P>			self._$targets = self._$container.find(self.selectors.target);
</P><P>			for(var i = 0;  i &lt; self._$targets.length; i++){
				var target = self._$targets[i];
</P><P>				if(target.dataset === undf || force){
</P><P>					target.dataset = {};
</P><P>					for(var j = 0; j &lt; target.attributes.length; j++){
</P><P>						var attr =  target.attributes[j],
							name = attr.name,
							val = attr.value;
</P><P>						if(name.indexOf('data-') &gt; -1){
							var dataName = self._helpers._camelCase(name.substring(5,name.length));
							target.dataset[dataName] = val;
						}
					}
				}
</P><P>				if(target.mixParent === undf){
					target.mixParent = self._id;
				}
			}
</P><P>			if(
				(self._$targets.length &amp;&amp; init) ||
				(!self._origOrder.length &amp;&amp; self._$targets.length)
			){
				self._origOrder = [];
</P><P>				for(var i = 0;  i &lt; self._$targets.length; i++){
					var target = self._$targets[i];
</P><P>					self._origOrder.push(target);
				}
			}
</P><P>			self._execAction('_refresh', 1, arguments);
		},
</P><P>		/**
		 * Bind Handlers
		 * @since 2.0.0
		 */
</P><P>		_bindHandlers: function(){
			var self = this,
				filters = $.MixItUp.prototype._bound._filter,
				sorts = $.MixItUp.prototype._bound._sort;
</P><P>			self._execAction('_bindHandlers', 0);
</P><P>			if(self.controls.live){
				self._$body
					.on('click.mixItUp.'+self._id, self.selectors.sort, function(){
						self._processClick($(this), 'sort');
					})
					.on('click.mixItUp.'+self._id, self.selectors.filter, function(){
						self._processClick($(this), 'filter');
					});
			} else {
				self._$sortButtons = $(self.selectors.sort);
				self._$filterButtons = $(self.selectors.filter);
</P><P>				self._$sortButtons.on('click.mixItUp.'+self._id, function(){
					self._processClick($(this), 'sort');
				});
</P><P>				self._$filterButtons.on('click.mixItUp.'+self._id, function(){
					self._processClick($(this), 'filter');
				});
			}
</P><P>			filters[self.selectors.filter] = (filters[self.selectors.filter] === undf) ? 1 : filters[self.selectors.filter] + 1;
			sorts[self.selectors.sort] = (sorts[self.selectors.sort] === undf) ? 1 : sorts[self.selectors.sort] + 1;
</P><P>			self._execAction('_bindHandlers', 1);
		},
</P><P>		/**
		 * Process Click
		 * @since 2.0.0
		 * @param {object} $button
		 * @param {string} type
		 */
</P><P>		_processClick: function($button, type){
			var self = this,
				trackClick = function($button, type, off){
					var proto = $.MixItUp.prototype;
</P><P>					proto._handled['_'+type][self.selectors[type]] = (proto._handled['_'+type][self.selectors[type]] === undf) ? 
						1 : 
						proto._handled['_'+type][self.selectors[type]] + 1;
</P><P>					if(proto._handled['_'+type][self.selectors[type]] === proto._bound['_'+type][self.selectors[type]]){
						$button[(off ? 'remove' : 'add')+'Class'](self.controls.activeClass);
						delete proto._handled['_'+type][self.selectors[type]];
					}
				};
</P><P>			self._execAction('_processClick', 0, arguments);
</P><P>			if(!self._mixing || (self.animation.queue &amp;&amp; self._queue.length &lt; self.animation.queueLimit)){
				self._clicking = true;
</P><P>				if(type === 'sort'){
					var sort = $button.attr('data-sort');
</P><P>					if(!$button.hasClass(self.controls.activeClass) || sort.indexOf('random') &gt; -1){
						$(self.selectors.sort).removeClass(self.controls.activeClass);
						trackClick($button, type);
						self.sort(sort);
					}
				}
</P><P>				if(type === 'filter') {
					var filter = $button.attr('data-filter'),
						ndx,
						seperator = self.controls.toggleLogic === 'or' ? ',' : <I>;</I></P><P>					if(!self.controls.toggleFilterButtons){
						if(!$button.hasClass(self.controls.activeClass)){
							$(self.selectors.filter).removeClass(self.controls.activeClass);
							trackClick($button, type);
							self.filter(filter);
						}
					} else {
						self._buildToggleArray();
</P><P>						if(!$button.hasClass(self.controls.activeClass)){
							trackClick($button, type);
</P><P>							self._toggleArray.push(filter);
						} else {
							trackClick($button, type, true);
							ndx = self._toggleArray.indexOf(filter);
							self._toggleArray.splice(ndx, 1);
						}
</P><P>						self._toggleArray = $.grep(self._toggleArray,function(n){return(n);});
</P><P>						self._toggleString = self._toggleArray.join(seperator);
</P><P>						self.filter(self._toggleString);
					}
				}
</P><P>				self._execAction('_processClick', 1, arguments);
			} else {
				if(typeof self.callbacks.onMixBusy === 'function'){
					self.callbacks.onMixBusy.call(self._domNode, self._state, self);
				}
				self._execAction('_processClickBusy', 1, arguments);
			}
		},
</P><P>		/**
		 * Build Toggle Array
		 * @since 2.0.0
		 */
</P><P>		_buildToggleArray: function(){
			var self = this,
				activeFilter = self._activeFilter.replace(/\s/g, <I>);</I></P><P>			self._execAction('_buildToggleArray', 0, arguments);
</P><P>			if(self.controls.toggleLogic === 'or'){
				self._toggleArray = activeFilter.split(',');
			} else {
				self._toggleArray = activeFilter.split('.');
</P><P>				!self._toggleArray[0] &amp;&amp; self._toggleArray.shift();
</P><P>				for(var i = 0, filter; filter = self._toggleArray[i]; i++){
					self._toggleArray[i] = '.'+filter;
				}
			}
</P><P>			self._execAction('_buildToggleArray', 1, arguments);
		},
</P><P>		/**
		 * Update Controls
		 * @since 2.0.0
		 * @param {object} command
		 * @param {boolean} multi
		 */
</P><P>		_updateControls: function(command, multi){
			var self = this,
				output = {
					filter: command.filter,
					sort: command.sort
				},
				update = function($el, filter){
					(multi &amp;&amp; type == 'filter' &amp;&amp; !(output.filter === 'none' || output.filter === <I>)) ?</I>
						$el.filter(filter).addClass(self.controls.activeClass) :
						$el.removeClass(self.controls.activeClass).filter(filter).addClass(self.controls.activeClass);
				},
				type = 'filter',
				$el = null;
</P><P>			self._execAction('_updateControls', 0, arguments);
</P><P>			(command.filter === undf) &amp;&amp; (output.filter = self._activeFilter);
			(command.sort === undf) &amp;&amp; (output.sort = self._activeSort);
			(output.filter === self.selectors.target) &amp;&amp; (output.filter = 'all');
</P><P>			for(var i = 0; i &lt; 2; i++){
				$el = self.controls.live ? $(self.selectors[type]) : self['_$'+type+'Buttons'];
				$el &amp;&amp; update($el, '[data-'+type+'=&quot;'+output[type]+'&quot;]');
				type = 'sort';
			}
</P><P>			self._execAction('_updateControls', 1, arguments);
		},
</P><P>		/**
		 * Filter (private)
		 * @since 2.0.0
		 */
</P><P>		_filter: function(){
			var self = this;
</P><P>			self._execAction('_filter', 0);
</P><P>			for(var i = 0; i &lt; self._$targets.length; i++){
				var $target = $(self._$targets[i]);
</P><P>				if($target.is(self._activeFilter)){
					self._$show = self._$show.add($target);
				} else {
					self._$hide = self._$hide.add($target);
				}
			}
</P><P>			self._execAction('_filter', 1);
		},
</P><P>		/**
		 * Sort (private)
		 * @since 2.0.0
		 */
</P><P>		_sort: function(){
			var self = this,
				arrayShuffle = function(oldArray){
					var newArray = oldArray.slice(),
						len = newArray.length,
						i = len;
</P><P>					while(i--){
						var p = parseInt(Math.random()*len);
						var t = newArray[i];
						newArray[i] = newArray[p];
						newArray[p] = t;
					};
					return newArray; 
				};
</P><P>			self._execAction('_sort', 0);
</P><P>			self._startOrder = [];
</P><P>			for(var i = 0; i &lt; self._$targets.length; i++){
				var target = self._$targets[i];
</P><P>				self._startOrder.push(target);
			}
</P><P>			switch(self._newSort[0].sortBy){
				case 'default':
					self._newOrder = self._origOrder;
					break;
				case 'random':
					self._newOrder = arrayShuffle(self._startOrder);
					break;
				case 'custom':
					self._newOrder = self._newSort[0].order;
					break;
				default:
					self._newOrder = self._startOrder.concat().sort(function(a, b){
						return self._compare(a, b);
					});
			}
</P><P>			self._execAction('_sort', 1);
		},
</P><P>		/**
		 * Compare Algorithm
		 * @since 2.0.0
		 * @param {string|number} a
		 * @param {string|number} b
		 * @param {number} depth (recursion)
		 * @return {number}
		 */
</P><P>		_compare: function(a, b, depth){
			depth = depth ? depth : 0;
</P><P>			var self = this,
				order = self._newSort[depth].order,
				getData = function(el){
					return el.dataset[self._newSort[depth].sortBy] || 0;
				},
				attrA = isNaN(getData(a) * 1) ? getData(a).toLowerCase() : getData(a) * 1,
				attrB = isNaN(getData(b) * 1) ? getData(b).toLowerCase() : getData(b) * 1;
</P><P>			if(attrA &lt; attrB)
				return order == 'asc' ? -1 : 1;
			if(attrA &gt; attrB)
				return order == 'asc' ? 1 : -1;
			if(attrA == attrB &amp;&amp; self._newSort.length &gt; depth+1)
				return self._compare(a, b, depth+1);
</P><P>			return 0;
		},
</P><P>		/**
		 * Print Sort
		 * @since 2.0.0
		 * @param {boolean} reset
		 */
</P><P>		_printSort: function(reset){
			var self = this,
				order = reset ? self._startOrder : self._newOrder,
				targets = self._$parent[0].querySelectorAll(self.selectors.target),
				nextSibling = targets[targets.length -1].nextElementSibling,
				frag = document.createDocumentFragment();
</P><P>			self._execAction('_printSort', 0, arguments);
</P><P>			for(var i = 0; i &lt; targets.length; i++){
				var target = targets[i],
					whiteSpace = target.nextSibling;
</P><P>				if(target.style.position === 'absolute') continue;
</P><P>				if(whiteSpace &amp;&amp; whiteSpace.nodeName == '#text'){
					self._$parent[0].removeChild(whiteSpace);
				}
</P><P>				self._$parent[0].removeChild(target);
			}
</P><P>			for(var i = 0; i &lt; order.length; i++){
				var el = order[i];
</P><P>				if(self._newSort[0].sortBy == 'default' &amp;&amp; self._newSort[0].order == 'desc' &amp;&amp; !reset){
					var firstChild = frag.firstChild;
					frag.insertBefore(el, firstChild);
					frag.insertBefore(document.createTextNode(' '), el);
				} else {
					frag.appendChild(el);
					frag.appendChild(document.createTextNode(' '));
				}
			}
</P><P>			nextSibling ? 
				self._$parent[0].insertBefore(frag, nextSibling) :
				self._$parent[0].appendChild(frag);
</P><P>			self._execAction('_printSort', 1, arguments);
		},
</P><P>		/**
		 * Parse Sort
		 * @since 2.0.0
		 * @param {string} sortString
		 * @return {array} newSort
		 */
</P><P>		_parseSort: function(sortString){
			var self = this,
				rules = typeof sortString === 'string' ? sortString.split(' ') : [sortString],
				newSort = [];
</P><P>			for(var i = 0; i &lt; rules.length; i++){
				var rule = typeof sortString === 'string' ? rules[i].split(':') : ['custom', rules[i]],
					ruleObj = {
						sortBy: self._helpers._camelCase(rule[0]),
						order: rule[1] || 'asc'
					};
</P><P>				newSort.push(ruleObj);
</P><P>				if(ruleObj.sortBy == 'default' || ruleObj.sortBy == 'random') break;
			}
</P><P>			return self._execFilter('_parseSort', newSort, arguments);
		},
</P><P>		/**
		 * Parse Effects
		 * @since 2.0.0
		 * @return {object} effects
		 */
</P><P>		_parseEffects: function(){
			var self = this,
				effects = {
					opacity: <I>,</I>
					transformIn: <I>,</I>
					transformOut: <I>,</I>
					filter: 
				},
				parse = function(effect, extract, reverse){
					if(self.animation.effects.indexOf(effect) &gt; -1){
						if(extract){
							var propIndex = self.animation.effects.indexOf(effect+'(');
							if(propIndex &gt; -1){
								var str = self.animation.effects.substring(propIndex),
									match = /\(([^)]+)\)/.exec(str),
									val = match[1];
</P><P>				return {val: val};
							}
						}
						return true;
					} else {
						return false;
					}
				},
				negate = function(value, invert){
					if(invert){
						return value.charAt(0) === '-' ? value.substr(1, value.length) : '-'+value;
					} else {
						return value;
					}
				},
				buildTransform = function(key, invert){
					var transforms = [
						['scale', '.01'],
						['translateX', '20px'],
						['translateY', '20px'],
						['translateZ', '20px'],
						['rotateX', '90deg'],
						['rotateY', '90deg'],
						['rotateZ', '180deg'],
					];
</P><P>					for(var i = 0; i &lt; transforms.length; i++){
						var prop = transforms[i][0],
							def = transforms[i][1],
							inverted = invert &amp;&amp; prop !== 'scale';
</P><P>						effects[key] += parse(prop) ? prop+'('+negate(parse(prop, true).val || def, inverted)+') ' : <I>;</I>
					}
				};
</P><P>			effects.opacity = parse('fade') ? parse('fade',true).val || '0' : '1';
</P><P>			buildTransform('transformIn');
</P><P>			self.animation.reverseOut ? buildTransform('transformOut', true) : (effects.transformOut = effects.transformIn);
</P><P>			effects.transition = {};
</P><P>			effects.transition = self._getPrefixedCSS('transition','all '+self.animation.duration+'ms '+self.animation.easing+', opacity '+self.animation.duration+'ms linear');
</P><P>			self.animation.stagger = parse('stagger') ? true : false;
			self.animation.staggerDuration = parseInt(parse('stagger') ? (parse('stagger',true).val ? parse('stagger',true).val : 100) : 100);
</P><P>			return self._execFilter('_parseEffects', effects);
		},
</P><P>		/**
		 * Build State
		 * @since 2.0.0
		 * @param {boolean} future
		 * @return {object} futureState
		 */
</P><P>		_buildState: function(future){
			var self = this,
				state = {};
</P><P>			self._execAction('_buildState', 0);
</P><P>			state = {
				activeFilter: self._activeFilter === <I> ? 'none' : self._activeFilter,</I>
				activeSort: future &amp;&amp; self._newSortString ? self._newSortString : self._activeSort,
				fail: !self._$show.length &amp;&amp; self._activeFilter !== <I>,</I>
				$targets: self._$targets,
				$show: self._$show,
				$hide: self._$hide,
				totalTargets: self._$targets.length,
				totalShow: self._$show.length,
				totalHide: self._$hide.length,
				display: future &amp;&amp; self._newDisplay ? self._newDisplay : self.layout.display
			};
</P><P>			if(future){
				return self._execFilter('_buildState', state);
			} else {
				self._state = state;
</P><P>				self._execAction('_buildState', 1);
			}
		},
</P><P>		/**
		 * Go Mix
		 * @since 2.0.0
		 * @param {boolean} animate
		 */
</P><P>		_goMix: function(animate){
			var self = this,
				phase1 = function(){
					if(self._chrome &amp;&amp; (self._chrome === 31)){
						chromeFix(self._$parent[0]);
					}
</P><P>					self._setInter();
</P><P>					phase2();
				},
				phase2 = function(){
					var scrollTop = window.pageYOffset,
						scrollLeft = window.pageXOffset,
						docHeight = document.documentElement.scrollHeight;
</P><P>					self._getInterMixData();
</P><P>					self._setFinal();
</P><P>					self._getFinalMixData();
</P><P>					(window.pageYOffset !== scrollTop) &amp;&amp; window.scrollTo(scrollLeft, scrollTop);
</P><P>					self._prepTargets();
</P><P>					if(window.requestAnimationFrame){
						requestAnimationFrame(phase3);
					} else {
						setTimeout(function(){
							phase3();
						},20);
					}
				},
				phase3 = function(){
					self._animateTargets();
</P><P>					if(self._targetsBound === 0){
						self._cleanUp();
					}
				},
				chromeFix = function(grid){
					var parent = grid.parentElement,
						placeholder = document.createElement('div'),
						frag = document.createDocumentFragment();
</P><P>					parent.insertBefore(placeholder, grid);
					frag.appendChild(grid);
					parent.replaceChild(grid, placeholder);
				},
				futureState = self._buildState(true);
</P><P>			self._execAction('_goMix', 0, arguments);
</P><P>			!self.animation.duration &amp;&amp; (animate = false);
</P><P>			self._mixing = true;
</P><P>			self._$container.removeClass(self.layout.containerClassFail);
</P><P>			if(typeof self.callbacks.onMixStart === 'function'){
				self.callbacks.onMixStart.call(self._domNode, self._state, futureState, self);
			}
</P><P>			self._$container.trigger('mixStart', [self._state, futureState, self]);
</P><P>			self._getOrigMixData();
</P><P>			if(animate &amp;&amp; !self._suckMode){
</P><P>				window.requestAnimationFrame ?
					requestAnimationFrame(phase1) :
					phase1();
</P><P>			} else {
				self._cleanUp();
			}
</P><P>			self._execAction('_goMix', 1, arguments);
		},
</P><P>		/**
		 * Get Target Data
		 * @since 2.0.0
		 */
</P><P>		_getTargetData: function(el, stage){
			var self = this,
				elStyle;
</P><P>			el.dataset[stage+'PosX'] = el.offsetLeft;
			el.dataset[stage+'PosY'] = el.offsetTop;
</P><P>			if(self.animation.animateResizeTargets){
				elStyle = window.getComputedStyle(el);
</P><P>				el.dataset[stage+'MarginBottom'] = parseInt(elStyle.marginBottom);
				el.dataset[stage+'MarginRight'] = parseInt(elStyle.marginRight);
				el.dataset[stage+'Width'] = el.offsetWidth;
				el.dataset[stage+'Height'] = el.offsetHeight;
			}
		},
</P><P>		/**
		 * Get Original Mix Data
		 * @since 2.0.0
		 */
</P><P>		_getOrigMixData: function(){
			var self = this,
				parentStyle = !self._suckMode ? window.getComputedStyle(self._$parent[0]) : {boxSizing: <I>},</I>
				parentBS = parentStyle.boxSizing || parentStyle[self._vendor+'BoxSizing'];
</P><P>			self._incPadding = (parentBS === 'border-box');
</P><P>			self._execAction('_getOrigMixData', 0);
</P><P>			!self._suckMode &amp;&amp; (self.effects = self._parseEffects());
</P><P>			self._$toHide = self._$hide.filter(':visible');
			self._$toShow = self._$show.filter(':hidden');
			self._$pre = self._$targets.filter(':visible');
</P><P>			self._startHeight = self._incPadding ? 
				self._$parent.outerHeight() : 
				self._$parent.height();
</P><P>			for(var i = 0; i &lt; self._$pre.length; i++){
				var el = self._$pre[i];
</P><P>				self._getTargetData(el, 'orig');
			}
</P><P>			self._execAction('_getOrigMixData', 1);
		},
</P><P>		/**
		 * Set Intermediate Positions
		 * @since 2.0.0
		 */
</P><P>		_setInter: function(){
			var self = this;
</P><P>			self._execAction('_setInter', 0);
</P><P>			if(self._changingLayout &amp;&amp; self.animation.animateChangeLayout){
				self._$toShow.css('display',self._newDisplay);
</P><P>				if(self._changingClass){
					self._$container
						.removeClass(self.layout.containerClass)
						.addClass(self._newClass);
				}
			} else {
				self._$toShow.css('display', self.layout.display);
			}
</P><P>			self._execAction('_setInter', 1);
		},
</P><P>		/**
		 * Get Intermediate Mix Data
		 * @since 2.0.0
		 */
</P><P>		_getInterMixData: function(){
			var self = this;
</P><P>			self._execAction('_getInterMixData', 0);
</P><P>			for(var i = 0; i &lt; self._$toShow.length; i++){
				var el = self._$toShow[i];
</P><P>				self._getTargetData(el, 'inter');
			}
</P><P>			for(var i = 0; i &lt; self._$pre.length; i++){
				var el = self._$pre[i];
</P><P>				self._getTargetData(el, 'inter');
			}
</P><P>			self._execAction('_getInterMixData', 1);
		},
</P><P>		/**
		 * Set Final Positions
		 * @since 2.0.0
		 */
</P><P>		_setFinal: function(){
			var self = this;
</P><P>			self._execAction('_setFinal', 0);
</P><P>			self._sorting &amp;&amp; self._printSort();
</P><P>			self._$toHide.removeStyle('display');
</P><P>			if(self._changingLayout &amp;&amp; self.animation.animateChangeLayout){
				self._$pre.css('display',self._newDisplay);
			}
</P><P>			self._execAction('_setFinal', 1);
		},
</P><P>		/**
		 * Get Final Mix Data
		 * @since 2.0.0
		 */
</P><P>		_getFinalMixData: function(){
			var self = this;
</P><P>			self._execAction('_getFinalMixData', 0);
</P><P>			for(var i = 0; i &lt; self._$toShow.length; i++){
				var el = self._$toShow[i];
</P><P>				self._getTargetData(el, 'final');
			}
</P><P>			for(var i = 0; i &lt; self._$pre.length; i++){
				var el = self._$pre[i];
</P><P>				self._getTargetData(el, 'final');
			}
</P><P>			self._newHeight = self._incPadding ? 
				self._$parent.outerHeight() : 
				self._$parent.height();
</P><P>			self._sorting &amp;&amp; self._printSort(true);
</P><P>			self._$toShow.removeStyle('display');
</P><P>			self._$pre.css('display',self.layout.display);
</P><P>			if(self._changingClass &amp;&amp; self.animation.animateChangeLayout){
				self._$container
					.removeClass(self._newClass)
					.addClass(self.layout.containerClass);
			}
</P><P>			self._execAction('_getFinalMixData', 1);
		},
</P><P>		/**
		 * Prepare Targets
		 * @since 2.0.0
		 */
</P><P>		_prepTargets: function(){
			var self = this,
				transformCSS = {
					_in: self._getPrefixedCSS('transform', self.effects.transformIn),
					_out: self._getPrefixedCSS('transform', self.effects.transformOut)
				};
</P><P>			self._execAction('_prepTargets', 0);
</P><P>			if(self.animation.animateResizeContainer){
				self._$parent.css('height',self._startHeight+'px');
			}
</P><P>			for(var i = 0; i &lt; self._$toShow.length; i++){
				var el = self._$toShow[i],
					$el = $(el);
</P><P>				el.style.opacity = self.effects.opacity;
				el.style.display = (self._changingLayout &amp;&amp; self.animation.animateChangeLayout) ?
					self._newDisplay :
					self.layout.display;
</P><P>				$el.css(transformCSS._in);
</P><P>				if(self.animation.animateResizeTargets){
					el.style.width = el.dataset.finalWidth+'px';
					el.style.height = el.dataset.finalHeight+'px';
					el.style.marginRight = -(el.dataset.finalWidth - el.dataset.interWidth) + (el.dataset.finalMarginRight * 1)+'px';
					el.style.marginBottom = -(el.dataset.finalHeight - el.dataset.interHeight) + (el.dataset.finalMarginBottom * 1)+'px';
				}
			}
</P><P>			for(var i = 0; i &lt; self._$pre.length; i++){
				var el = self._$pre[i],
					$el = $(el),
					translate = {
						x: el.dataset.origPosX - el.dataset.interPosX,
						y: el.dataset.origPosY - el.dataset.interPosY
					},
					transformCSS = self._getPrefixedCSS('transform','translate('+translate.x+'px,'+translate.y+'px)');
</P><P>				$el.css(transformCSS);
</P><P>				if(self.animation.animateResizeTargets){
					el.style.width = el.dataset.origWidth+'px';
					el.style.height = el.dataset.origHeight+'px';
</P><P>					if(el.dataset.origWidth - el.dataset.finalWidth){
						el.style.marginRight = -(el.dataset.origWidth - el.dataset.interWidth) + (el.dataset.origMarginRight * 1)+'px';
					}
</P><P>					if(el.dataset.origHeight - el.dataset.finalHeight){
						el.style.marginBottom = -(el.dataset.origHeight - el.dataset.interHeight) + (el.dataset.origMarginBottom * 1) +'px';
					}
				}
			}
</P><P>			self._execAction('_prepTargets', 1);
		},
</P><P>		/**
		 * Animate Targets
		 * @since 2.0.0
		 */
</P><P>		_animateTargets: function(){
			var self = this;
</P><P>			self._execAction('_animateTargets', 0);
</P><P>			self._targetsDone = 0;
			self._targetsBound = 0;
</P><P>			self._$parent
				.css(self._getPrefixedCSS('perspective', self.animation.perspectiveDistance+'px'))
				.css(self._getPrefixedCSS('perspective-origin', self.animation.perspectiveOrigin));
</P><P>			if(self.animation.animateResizeContainer){
				self._$parent
					.css(self._getPrefixedCSS('transition','height '+self.animation.duration+'ms ease'))
					.css('height',self._newHeight+'px');
			}
</P><P>			for(var i = 0; i &lt; self._$toShow.length; i++){
				var el = self._$toShow[i],
					$el = $(el),
					translate = {
						x: el.dataset.finalPosX - el.dataset.interPosX,
						y: el.dataset.finalPosY - el.dataset.interPosY
					},
					delay = self._getDelay(i),
					toShowCSS = {};
</P><P>				el.style.opacity = <I>;</I></P><P>				for(var j = 0; j &lt; 2; j++){
					var a = j === 0 ? a = self._prefix : <I>;</I></P><P>					if(self._ff &amp;&amp; self._ff &lt;= 20){
						toShowCSS[a+'transition-property'] = 'all';
						toShowCSS[a+'transition-timing-function'] = self.animation.easing+'ms';
						toShowCSS[a+'transition-duration'] = self.animation.duration+'ms';
					}
</P><P>					toShowCSS[a+'transition-delay'] = delay+'ms';
					toShowCSS[a+'transform'] = 'translate('+translate.x+'px,'+translate.y+'px)';
				}
</P><P>				if(self.effects.transform || self.effects.opacity){
					self._bindTargetDone($el);
				}
</P><P>				(self._ff &amp;&amp; self._ff &lt;= 20) ? 
					$el.css(toShowCSS) : 
					$el.css(self.effects.transition).css(toShowCSS);
			}
</P><P>			for(var i = 0; i &lt; self._$pre.length; i++){
				var el = self._$pre[i],
					$el = $(el),
					translate = {
						x: el.dataset.finalPosX - el.dataset.interPosX,
						y: el.dataset.finalPosY - el.dataset.interPosY
					},
					delay = self._getDelay(i);
</P><P>				if(!(
					el.dataset.finalPosX === el.dataset.origPosX &amp;&amp;
					el.dataset.finalPosY === el.dataset.origPosY
				)){
					self._bindTargetDone($el);
				}
</P><P>				$el.css(self._getPrefixedCSS('transition', 'all '+self.animation.duration+'ms '+self.animation.easing+' '+delay+'ms'));
				$el.css(self._getPrefixedCSS('transform', 'translate('+translate.x+'px,'+translate.y+'px)'));
</P><P>				if(self.animation.animateResizeTargets){
					if(el.dataset.origWidth - el.dataset.finalWidth &amp;&amp; el.dataset.finalWidth * 1){
						el.style.width = el.dataset.finalWidth+'px';
						el.style.marginRight = -(el.dataset.finalWidth - el.dataset.interWidth)+(el.dataset.finalMarginRight * 1)+'px';
					}
</P><P>					if(el.dataset.origHeight - el.dataset.finalHeight &amp;&amp; el.dataset.finalHeight * 1){
						el.style.height = el.dataset.finalHeight+'px';
						el.style.marginBottom = -(el.dataset.finalHeight - el.dataset.interHeight)+(el.dataset.finalMarginBottom * 1) +'px';
					}
				}
			}
</P><P>			if(self._changingClass){
				self._$container
					.removeClass(self.layout.containerClass)
					.addClass(self._newClass);
			}
</P><P>			for(var i = 0; i &lt; self._$toHide.length; i++){
				var el = self._$toHide[i],
					$el = $(el),
					delay = self._getDelay(i),
					toHideCSS = {};
</P><P>for(var j = 0; j&lt;2; j++){
					var a = j === 0 ? a = self._prefix : <I>;</I></P><P>					toHideCSS[a+'transition-delay'] = delay+'ms';
					toHideCSS[a+'transform'] = self.effects.transformOut;
					toHideCSS.opacity = self.effects.opacity;
				}
</P><P>				$el.css(self.effects.transition).css(toHideCSS);
</P><P>				if(self.effects.transform || self.effects.opacity){
					self._bindTargetDone($el);
				};
			}
</P><P>			self._execAction('_animateTargets', 1);
</P><P>		},
</P><P>		/**
		 * Bind Targets TransitionEnd
		 * @since 2.0.0
		 * @param {object} $el
		 */
</P><P>		_bindTargetDone: function($el){
			var self = this,
				el = $el[0];
</P><P>			self._execAction('_bindTargetDone', 0, arguments);
</P><P>			if(!el.dataset.bound){
</P><P>				el.dataset.bound = true;
				self._targetsBound++;
</P><P>				$el.on('webkitTransitionEnd.mixItUp transitionend.mixItUp',function(e){
					if(
						(e.originalEvent.propertyName.indexOf('transform') &gt; -1 || 
						e.originalEvent.propertyName.indexOf('opacity') &gt; -1) &amp;&amp;
						$(e.originalEvent.target).is(self.selectors.target)
					){
						$el.off('.mixItUp');
						delete el.dataset.bound;
						self._targetDone();
					}
				});
			}
</P><P>			self._execAction('_bindTargetDone', 1, arguments);
		},
</P><P>		/**
		 * Target Done
		 * @since 2.0.0
		 */
</P><P>		_targetDone: function(){
			var self = this;
</P><P>			self._execAction('_targetDone', 0);
</P><P>			self._targetsDone++;
</P><P>			(self._targetsDone === self._targetsBound) &amp;&amp; self._cleanUp();
</P><P>			self._execAction('_targetDone', 1);
		},
</P><P>		/**
		 * Clean Up
		 * @since 2.0.0
		 */
</P><P>		_cleanUp: function(){
			var self = this,
				targetStyles = self.animation.animateResizeTargets ? 'transform opacity width height margin-bottom margin-right' : 'transform opacity';
				unBrake = function(){
					self._$targets.removeStyle('transition', self._prefix);
				};
</P><P>			self._execAction('_cleanUp', 0);
</P><P>			!self._changingLayout ?
				self._$show.css('display',self.layout.display) :
				self._$show.css('display',self._newDisplay);
</P><P>			self._$targets.css(self._brake);
</P><P>			self._$targets
				.removeStyle(targetStyles, self._prefix)
				.removeAttr('data-inter-pos-x data-inter-pos-y data-final-pos-x data-final-pos-y data-orig-pos-x data-orig-pos-y data-orig-height data-orig-width data-final-height data-final-width data-inter-width data-inter-height data-orig-margin-right data-orig-margin-bottom data-inter-margin-right data-inter-margin-bottom data-final-margin-right data-final-margin-bottom');
</P><P>			self._$hide.removeStyle('display');
</P><P>			self._$parent.removeStyle('height transition perspective-distance perspective perspective-origin-x perspective-origin-y perspective-origin perspectiveOrigin', self._prefix);
</P><P>			if(self._sorting){
				self._printSort();
				self._activeSort = self._newSortString;
				self._sorting = false;
			}
</P><P>			if(self._changingLayout){
				if(self._changingDisplay){
					self.layout.display = self._newDisplay;
					self._changingDisplay = false;
				}
</P><P>				if(self._changingClass){
					self._$parent.removeClass(self.layout.containerClass).addClass(self._newClass);
					self.layout.containerClass = self._newClass;
					self._changingClass = false;
				}
</P><P>				self._changingLayout = false;
			}
</P><P>			self._refresh();
</P><P>			self._buildState();
</P><P>			if(self._state.fail){
				self._$container.addClass(self.layout.containerClassFail);
			}
</P><P>			self._$show = $();
			self._$hide = $();
</P><P>			if(window.requestAnimationFrame){
				requestAnimationFrame(unBrake);
			}
</P><P>			self._mixing = false;
</P><P>			if(typeof self.callbacks._user === 'function'){
				self.callbacks._user.call(self._domNode, self._state, self);
			}
</P><P>			if(typeof self.callbacks.onMixEnd === 'function'){
				self.callbacks.onMixEnd.call(self._domNode, self._state, self);
			}
</P><P>			self._$container.trigger('mixEnd', [self._state, self]);
</P><P>			if(self._state.fail){
				(typeof self.callbacks.onMixFail === 'function') &amp;&amp; self.callbacks.onMixFail.call(self._domNode, self._state, self);
				self._$container.trigger('mixFail', [self._state, self]);
			}
</P><P>			if(self._loading){
				(typeof self.callbacks.onMixLoad === 'function') &amp;&amp; self.callbacks.onMixLoad.call(self._domNode, self._state, self);
				self._$container.trigger('mixLoad', [self._state, self]);
			}
</P><P>			if(self._queue.length){
				self._execAction('_queue', 0);
</P><P>				self.multiMix(self._queue[0][0],self._queue[0][1],self._queue[0][2]);
				self._queue.splice(0, 1);
			}
</P><P>			self._execAction('_cleanUp', 1);
</P><P>			self._loading = false;
		},
</P><P>		/**
		 * Get Prefixed CSS
		 * @since 2.0.0
		 * @param {string} property
		 * @param {string} value
		 * @param {boolean} prefixValue
		 * @return {object} styles
		 */
</P><P>		_getPrefixedCSS: function(property, value, prefixValue){
			var self = this,
				styles = {};
</P><P>			for(i = 0; i &lt; 2; i++){
				var prefix = i === 0 ? self._prefix : <I>;</I>
				prefixValue ? styles[prefix+property] = prefix+value : styles[prefix+property] = value;
			}
</P><P>			return self._execFilter('_getPrefixedCSS', styles, arguments);
		},
</P><P>		/**
		 * Get Delay
		 * @since 2.0.0
		 * @param {number} i
		 * @return {number} delay
		 */
</P><P>		_getDelay: function(i){
			var self = this,
				n = typeof self.animation.staggerSequence === 'function' ? self.animation.staggerSequence.call(self._domNode, i, self._state) : i,
				delay = self.animation.stagger ?  n * self.animation.staggerDuration : 0;
</P><P>			return self._execFilter('_getDelay', delay, arguments);
		},
</P><P>		/**
		 * Parse MultiMix Arguments
		 * @since 2.0.0
		 * @param {array} args
		 * @return {object} output
		 */
</P><P>		_parseMultiMixArgs: function(args){
			var self = this,
				output = {
					command: null,
					animate: self.animation.enable,
					callback: null
				};
</P><P>			for(var i = 0; i &lt; args.length; i++){
				var arg = args[i];
</P><P>				if(arg !== null){
					if(typeof arg === 'object' || typeof arg === 'string'){
						output.command = arg;
					} else if(typeof arg === 'boolean'){
						output.animate = arg;
					} else if(typeof arg === 'function'){
						output.callback = arg;
					}
				}
			}
</P><P>			return self._execFilter('_parseMultiMixArgs', output, arguments);
		},
</P><P>		/**
		 * Parse Insert Arguments
		 * @since 2.0.0
		 * @param {array} args
		 * @return {object} output
		 */
</P><P>		_parseInsertArgs: function(args){
			var self = this,
				output = {
					index: 0,
					$object: $(),
					multiMix: {filter: self._state.activeFilter},
					callback: null
				};
</P><P>			for(var i = 0; i &lt; args.length; i++){
				var arg = args[i];
</P><P>				if(typeof arg === 'number'){
					output.index = arg;
				} else if(typeof arg === 'object' &amp;&amp; arg instanceof $){
					output.$object = arg;
				} else if(typeof arg === 'object' &amp;&amp; self._helpers._isElement(arg)){
					output.$object = $(arg);
				} else if(typeof arg === 'object' &amp;&amp; arg !== null){
					output.multiMix = arg;
				} else if(typeof arg === 'boolean' &amp;&amp; !arg){
					output.multiMix = false;
				} else if(typeof arg === 'function'){
					output.callback = arg;
				}
			}
</P><P>			return self._execFilter('_parseInsertArgs', output, arguments);
		},
</P><P>		/**
		 * Execute Action
		 * @since 2.0.0
		 * @param {string} methodName
		 * @param {boolean} isPost
		 * @param {array} args
		 */
</P><P>		_execAction: function(methodName, isPost, args){
			var self = this,
				context = isPost ? 'post' : 'pre';
</P><P>			if(!self._actions.isEmptyObject &amp;&amp; self._actions.hasOwnProperty(methodName)){
				for(var key in self._actions[methodName][context]){
					self._actions[methodName][context][key].call(self, args);
				}
			}
		},
</P><P>		/**
		 * Execute Filter
		 * @since 2.0.0
		 * @param {string} methodName
		 * @param {mixed} value
		 * @return {mixed} value
		 */
</P><P>		_execFilter: function(methodName, value, args){
			var self = this;
</P><P>			if(!self._filters.isEmptyObject &amp;&amp; self._filters.hasOwnProperty(methodName)){
				for(var key in self._filters[methodName]){
					return self._filters[methodName][key].call(self, args);
				}
			} else {
				return value;
			}
		},
</P><P>		/* Helpers
		---------------------------------------------------------------------- */
</P><P>		_helpers: {
</P><P>			/**
			 * CamelCase
			 * @since 2.0.0
			 * @param {string}
			 * @return {string}
			 */
</P><P>			_camelCase: function(string){
				return string.replace(/-([a-z])/g, function(g){
						return g[1].toUpperCase();
				});
			},
</P><P>			/**
			 * Is Element
			 * @since 2.1.3
			 * @param {object} element to test
			 * @return {boolean}
			 */
</P><P>			_isElement: function(el){
				if(window.HTMLElement){
					return el instanceof HTMLElement;
				} else {
					return (
						el !== null &amp;&amp; 
						el.nodeType === 1 &amp;&amp;
						el.nodeName === 'string'
					);
				}
			}
		},
</P><P>		/* Public Methods
		---------------------------------------------------------------------- */
</P><P>		/**
		 * Is Mixing
		 * @since 2.0.0
		 * @return {boolean}
		 */
</P><P>		isMixing: function(){
			var self = this;
</P><P>			return self._execFilter('isMixing', self._mixing);
		},
</P><P>		/**
		 * Filter (public)
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		filter: function(){
			var self = this,
				args = self._parseMultiMixArgs(arguments);
</P><P>			self._clicking &amp;&amp; (self._toggleString = <I>);</I></P><P>			self.multiMix({filter: args.command}, args.animate, args.callback);
		},
</P><P>		/**
		 * Sort (public)
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		sort: function(){
			var self = this,
				args = self._parseMultiMixArgs(arguments);
</P><P>			self.multiMix({sort: args.command}, args.animate, args.callback);
		},
</P><P>		/**
		 * Change Layout (public)
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		changeLayout: function(){
			var self = this,
				args = self._parseMultiMixArgs(arguments);
</P><P>			self.multiMix({changeLayout: args.command}, args.animate, args.callback);
		},
</P><P>		/**
		 * MultiMix
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		multiMix: function(){
			var self = this,
				args = self._parseMultiMixArgs(arguments);
</P><P>			self._execAction('multiMix', 0, arguments);
</P><P>			if(!self._mixing){
				if(self.controls.enable &amp;&amp; !self._clicking){
					self.controls.toggleFilterButtons &amp;&amp; self._buildToggleArray();
					self._updateControls(args.command, self.controls.toggleFilterButtons);
				}
</P><P>				(self._queue.length &lt; 2) &amp;&amp; (self._clicking = false);
</P><P>				delete self.callbacks._user;
				if(args.callback) self.callbacks._user = args.callback;
</P><P>				var sort = args.command.sort,
					filter = args.command.filter,
					changeLayout = args.command.changeLayout;
</P><P>				self._refresh();
</P><P>				if(sort){
					self._newSort = self._parseSort(sort);
					self._newSortString = sort;
</P><P>					self._sorting = true;
					self._sort();
				}
</P><P>				if(filter !== undf){
					filter = (filter === 'all') ? self.selectors.target : filter;
</P><P>					self._activeFilter = filter;
				}
</P><P>				self._filter();
</P><P>				if(changeLayout){
					self._newDisplay = (typeof changeLayout === 'string') ? changeLayout : changeLayout.display || self.layout.display;
					self._newClass = changeLayout.containerClass || <I>;</I></P><P>					if(
						self._newDisplay !== self.layout.display ||
						self._newClass !== self.layout.containerClass
					){
						self._changingLayout = true;
</P><P>						self._changingClass = (self._newClass !== self.layout.containerClass);
						self._changingDisplay = (self._newDisplay !== self.layout.display);
					}
				}
</P><P>				self._$targets.css(self._brake);
</P><P>				self._goMix(args.animate ^ self.animation.enable ? args.animate : self.animation.enable);
</P><P>				self._execAction('multiMix', 1, arguments);
</P><P>			} else {
				if(self.animation.queue &amp;&amp; self._queue.length &lt; self.animation.queueLimit){
					self._queue.push(arguments);
</P><P>					(self.controls.enable &amp;&amp; !self._clicking) &amp;&amp; self._updateControls(args.command);
</P><P>					self._execAction('multiMixQueue', 1, arguments);
</P><P>				} else {
					if(typeof self.callbacks.onMixBusy === 'function'){
						self.callbacks.onMixBusy.call(self._domNode, self._state, self);
					}
					self._$container.trigger('mixBusy', [self._state, self]);
</P><P>					self._execAction('multiMixBusy', 1, arguments);
				}
			}
		},
</P><P>		/**
		 * Insert
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		insert: function(){
			var self = this,
				args = self._parseInsertArgs(arguments),
				callback = (typeof args.callback === 'function') ? args.callback : null,
				frag = document.createDocumentFragment(),
				target = (function(){
					self._refresh();
</P><P>					if(self._$targets.length){
						return (args.index &lt; self._$targets.length || !self._$targets.length) ? 
							self._$targets[args.index] :
							self._$targets[self._$targets.length-1].nextElementSibling;
					} else {
						return self._$parent[0].children[0];
					}
				})();
</P><P>			self._execAction('insert', 0, arguments);
</P><P>			if(args.$object){
				for(var i = 0; i &lt; args.$object.length; i++){
					var el = args.$object[i];
</P><P>					frag.appendChild(el);
					frag.appendChild(document.createTextNode(' '));
				}
</P><P>				self._$parent[0].insertBefore(frag, target);
			}
</P><P>			self._execAction('insert', 1, arguments);
</P><P>			if(typeof args.multiMix === 'object'){
				self.multiMix(args.multiMix, callback);
			}
		},
</P><P>		/**
		 * Prepend
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		prepend: function(){
			var self = this,
				args = self._parseInsertArgs(arguments);
</P><P>			self.insert(0, args.$object, args.multiMix, args.callback);
		},
</P><P>		/**
		 * Append
		 * @since 2.0.0
		 * @param {array} arguments
		 */
</P><P>		append: function(){
			var self = this,
				args = self._parseInsertArgs(arguments);
</P><P>			self.insert(self._state.totalTargets, args.$object, args.multiMix, args.callback);
		},
</P><P>		/**
		 * Get Option
		 * @since 2.0.0
		 * @param {string} string
		 * @return {mixed} value
		 */
</P><P>		getOption: function(string){
			var self = this,
				getProperty = function(obj, prop){
					var parts = prop.split('.'),
						last = parts.pop(),
						l = parts.length,
						i = 1,
						current = parts[0] || prop;
</P><P>					while((obj = obj[current]) &amp;&amp; i &lt; l){
						current = parts[i];
						i++;
					}
</P><P>					if(obj !== undf){
						return obj[last] !== undf ? obj[last] : obj;
					}
				};
</P><P>			return string ? self._execFilter('getOption', getProperty(self, string), arguments) : self;
		},
</P><P>		/**
		 * Set Options
		 * @since 2.0.0
		 * @param {object} config
		 */
</P><P>		setOptions: function(config){
			var self = this;
</P><P>			self._execAction('setOptions', 0, arguments);
</P><P>			typeof config === 'object' &amp;&amp; $.extend(true, self, config);
</P><P>			self._execAction('setOptions', 1, arguments);
		},
</P><P>		/**
		 * Get State
		 * @since 2.0.0
		 * @return {object} state
		 */
</P><P>		getState: function(){
			var self = this;
</P><P>			return self._execFilter('getState', self._state, self);
		},
</P><P>		/**
		 * Force Refresh
		 * @since 2.1.2
		 */
</P><P>		forceRefresh: function(){
			var self = this;
</P><P>			self._refresh(false, true);
		},
</P><P>		/**
		 * Destroy
		 * @since 2.0.0
		 * @param {boolean} hideAll
		 */
</P><P>		destroy: function(hideAll){
			var self = this;
</P><P>			self._execAction('destroy', 0, arguments);
</P><P>			self._$body
				.add($(self.selectors.sort))
				.add($(self.selectors.filter))
				.off('.mixItUp');
</P><P>			for(var i = 0; i &lt; self._$targets.length; i++){
				var target = self._$targets[i];
</P><P>				hideAll &amp;&amp; (target.style.display = <I>);</I></P><P>				delete target.mixParent;
			}
</P><P>			self._execAction('destroy', 1, arguments);
</P><P>			delete $.MixItUp.prototype._instances[self._id];
		}
</P><P>	};
</P><P>	/* jQuery Methods
	---------------------------------------------------------------------- */
</P><P>	/**
	 * jQuery .mixItUp() method
	 * @since 2.0.0
	 * @extends $.fn
	 */
</P><P>	$.fn.mixItUp = function(){
		var args = arguments,
			dataReturn = [],
			eachReturn,
			_instantiate = function(domNode, settings){
				var instance = new $.MixItUp(),
					rand = function(){
						return ('00000'+(Math.random()*16777216&lt;&lt;0).toString(16)).substr(-6).toUpperCase();
					};
</P><P>				instance._execAction('_instantiate', 0, arguments);
</P><P>				domNode.id = !domNode.id ? 'MixItUp'+rand() : domNode.id;
</P><P>				if(!instance._instances[domNode.id]){
					instance._instances[domNode.id] = instance;
					instance._init(domNode, settings);
				}
</P><P>				instance._execAction('_instantiate', 1, arguments);
			};
</P><P>		eachReturn = this.each(function(){
			if(args &amp;&amp; typeof args[0] === 'string'){
				var instance = $.MixItUp.prototype._instances[this.id];
				if(args[0] == 'isLoaded'){
					dataReturn.push(instance ? true : false);
				} else {
					var data = instance[args[0]](args[1], args[2], args[3]);
					if(data !== undf)dataReturn.push(data);
				}
			} else {
				_instantiate(this, args[0]);
			}
		});
</P><P>		if(dataReturn.length){
			return dataReturn.length &gt; 1 ? dataReturn : dataReturn[0];
		} else {
			return eachReturn;
		}
	};
</P><P>	/**
	 * jQuery .removeStyle() method
	 * @since 2.0.0
	 * @extends $.fn
	 */
</P><P>	$.fn.removeStyle = function(style, prefix){
		prefix = prefix ? prefix : <I>;</I></P><P>		return this.each(function(){
			var el = this,
				styles = style.split(' ');
</P><P>			for(var i = 0; i &lt; styles.length; i++){
				for(var j = 0; j &lt; 2; j++){
					var prop = j ? styles[i] : prefix+styles[i];
					if(
						el.style[prop] !== undf &amp;&amp; 
						typeof el.style[prop] !== 'unknown' &amp;&amp;
						el.style[prop].length &gt; 0
					){
						el.style[prop] = <I>;</I>
					}
					if(!prefix)break;
				}
			}
</P><P>			if(el.attributes &amp;&amp; el.attributes.style &amp;&amp; el.attributes.style !== undf &amp;&amp; el.attributes.style.value === <I>){</I>
				el.attributes.removeNamedItem('style');
			}
		});
	};
</P><P>})(jQuery);
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:ETH_Zurich/js/jquery.mixitup.js">http://2014.igem.org/Team:ETH_Zurich/js/jquery.mixitup.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:ETH_Zurich/js/jquery.mixitup.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:ETH_Zurich/js/jquery.mixitup.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:ETH_Zurich/js/jquery.mixitup.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:ETH_Zurich/js/jquery.mixitup.js&amp;oldid=194629" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
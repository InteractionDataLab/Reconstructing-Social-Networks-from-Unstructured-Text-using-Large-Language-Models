<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_British_Columbia_mwe_cssParser_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:British_Columbia/mwe_cssParser.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:British_Columbia/mwe_cssParser.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:British_Columbia/mwe_cssParser.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:British_Columbia/mwe_cssParser.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:British_Columbia/mwe_cssParser.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform">Â </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:British Columbia/mwe cssParser.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><P>/* ***** BEGIN LICENSE BLOCK *****
</P><PRE>* Version: MPL 1.1/GPL 2.0/LGPL 2.1
*
* The contents of this file are subject to the Mozilla Public License Version
* 1.1 (the &quot;License&quot;); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* <A href="http://www.mozilla.org/MPL/" class="external free" rel="nofollow">http://www.mozilla.org/MPL/</A>
*
* Software distributed under the License is distributed on an &quot;AS IS&quot; basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
* for the specific language governing rights and limitations under the
* License.
*
* The Original Code is mozilla.org code.
*
* The Initial Developer of the Original Code is
* Netscape Communications Corporation.
* Portions created by the Initial Developer are Copyright (C) 1998
* the Initial Developer. All Rights Reserved.
*
* Contributor(s):
*   emk &lt;VYV03354@nifty.ne.jp&gt;
*   Daniel Glazman &lt;glazman@netscape.com&gt;
*   L. David Baron &lt;dbaron@dbaron.org&gt;
*   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
*   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
*   Christian Biesinger &lt;cbiesinger@web.de&gt;
*   Jeff Walden &lt;jwalden+code@mit.edu&gt;
*   Jonathon Jongsma &lt;jonathon.jongsma@collabora.co.uk&gt;, Collabora Ltd.
*   Siraj Razick &lt;siraj.razick@collabora.co.uk&gt;, Collabora Ltd.
*   Daniel Glazman &lt;daniel.glazman@disruptive-innovations.com&gt;
*
* Alternatively, the contents of this file may be used under the terms of
* either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
* or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
* in which case the provisions of the GPL or the LGPL are applicable instead
* of those above. If you wish to allow use of your version of this file only
* under the terms of either the GPL or the LGPL, and not to allow others to
* use your version of this file under the terms of the MPL, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the GPL or the LGPL. If you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the MPL, the GPL or the LGPL.
*
* ***** END LICENSE BLOCK ***** */
</PRE><P>var kCHARSET_RULE_MISSING_SEMICOLON = &quot;Missing semicolon at the end of @charset rule&quot;;
var kCHARSET_RULE_CHARSET_IS_STRING = &quot;The charset in the @charset rule should be a string&quot;;
var kCHARSET_RULE_MISSING_WS = &quot;Missing mandatory whitespace after @charset&quot;;
var kIMPORT_RULE_MISSING_URL = &quot;Missing URL in @import rule&quot;;
var kURL_EOF = &quot;Unexpected end of stylesheet&quot;;
var kURL_WS_INSIDE = &quot;Multiple tokens inside a url() notation&quot;;
var kVARIABLES_RULE_POSITION = &quot;@variables rule invalid at this position in the stylesheet&quot;;
var kIMPORT_RULE_POSITION = &quot;@import rule invalid at this position in the stylesheet&quot;;
var kNAMESPACE_RULE_POSITION = &quot;@namespace rule invalid at this position in the stylesheet&quot;;
var kCHARSET_RULE_CHARSET_SOF = &quot;@charset rule invalid at this position in the stylesheet&quot;;
var kUNKNOWN_AT_RULE = &quot;Unknow @-rule&quot;;
</P><P>/* FROM <A href="http://peter.sh/data/vendor-prefixed-css.php?js=1" class="external free" rel="nofollow">http://peter.sh/data/vendor-prefixed-css.php?js=1</A> */
</P><P>var kENGINES = [
</P><PRE> &quot;webkit&quot;,
 &quot;presto&quot;,
 &quot;trident&quot;,
 &quot;generic&quot;
</PRE><P>];
</P><P>var kCSS_VENDOR_VALUES = {
</P><PRE> &quot;-moz-box&quot;:             {&quot;webkit&quot;: &quot;-webkit-box&quot;,        &quot;presto&quot;: &quot;&quot;, &quot;trident&quot;: &quot;&quot;, &quot;generic&quot;: &quot;box&quot; },
 &quot;-moz-inline-box&quot;:      {&quot;webkit&quot;: &quot;-webkit-inline-box&quot;, &quot;presto&quot;: &quot;&quot;, &quot;trident&quot;: &quot;&quot;, &quot;generic&quot;: &quot;inline-box&quot; },
 &quot;-moz-initial&quot;:         {&quot;webkit&quot;: &quot;&quot;,                   &quot;presto&quot;: &quot;&quot;, &quot;trident&quot;: &quot;&quot;, &quot;generic&quot;: &quot;initial&quot; },
 &quot;-moz-linear-gradient&quot;: {&quot;webkit20110101&quot;: FilterLinearGradientForOutput,
                          &quot;webkit&quot;: FilterLinearGradientForOutput,
                          &quot;presto&quot;: &quot;&quot;,
                          &quot;trident&quot;: &quot;&quot;,
                          &quot;generic&quot;: FilterLinearGradientForOutput },
 &quot;-moz-radial-gradient&quot;: {&quot;webkit20110101&quot;: FilterRadialGradientForOutput,
                          &quot;webkit&quot;: FilterRadialGradientForOutput,
                          &quot;presto&quot;: &quot;&quot;,
                          &quot;trident&quot;: &quot;&quot;,
                          &quot;generic&quot;: FilterRadialGradientForOutput },
 &quot;-moz-repeating-linear-gradient&quot;: {&quot;webkit20110101&quot;: &quot;&quot;,
                          &quot;webkit&quot;: FilterRepeatingGradientForOutput,
                          &quot;presto&quot;: &quot;&quot;,
                          &quot;trident&quot;: &quot;&quot;,
                          &quot;generic&quot;: FilterRepeatingGradientForOutput },
 &quot;-moz-repeating-radial-gradient&quot;: {&quot;webkit20110101&quot;: &quot;&quot;,
                          &quot;webkit&quot;: FilterRepeatingGradientForOutput,
                          &quot;presto&quot;: &quot;&quot;,
                          &quot;trident&quot;: &quot;&quot;,
                          &quot;generic&quot;: FilterRepeatingGradientForOutput }
</PRE><P>};
</P><P>var kCSS_VENDOR_PREFIXES = {&quot;lastUpdate&quot;:1304175007,&quot;properties&quot;:[{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-accelerator&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-wap-accesskey&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-animation&quot;,&quot;webkit&quot;:&quot;-webkit-animation&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-delay&quot;,&quot;webkit&quot;:&quot;-webkit-animation-delay&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-direction&quot;,&quot;webkit&quot;:&quot;-webkit-animation-direction&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-duration&quot;,&quot;webkit&quot;:&quot;-webkit-animation-duration&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-fill-mode&quot;,&quot;webkit&quot;:&quot;-webkit-animation-fill-mode&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-iteration-count&quot;,&quot;webkit&quot;:&quot;-webkit-animation-iteration-count&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-name&quot;,&quot;webkit&quot;:&quot;-webkit-animation-name&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-play-state&quot;,&quot;webkit&quot;:&quot;-webkit-animation-play-state&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-animation-timing-function&quot;,&quot;webkit&quot;:&quot;-webkit-animation-timing-function&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-appearance&quot;,&quot;webkit&quot;:&quot;-webkit-appearance&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-backface-visibility&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;background-clip&quot;,&quot;webkit&quot;:&quot;-webkit-background-clip&quot;,&quot;presto&quot;:&quot;background-clip&quot;,&quot;trident&quot;:&quot;background-clip&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-background-composite&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-background-inline-policy&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;background-origin&quot;,&quot;webkit&quot;:&quot;-webkit-background-origin&quot;,&quot;presto&quot;:&quot;background-origin&quot;,&quot;trident&quot;:&quot;background-origin&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;background-position-x&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-background-position-x&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;background-position-y&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-background-position-y&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;background-size&quot;,&quot;webkit&quot;:&quot;-webkit-background-size&quot;,&quot;presto&quot;:&quot;background-size&quot;,&quot;trident&quot;:&quot;background-size&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-behavior&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-binding&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-block-progression&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-after&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-after-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-after-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-after-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-before&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-before-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-before-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-before-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-bottom-colors&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;border-bottom-left-radius&quot;,&quot;webkit&quot;:&quot;-webkit-border-bottom-left-radius&quot;,&quot;presto&quot;:&quot;border-bottom-left-radius&quot;,&quot;trident&quot;:&quot;border-bottom-left-radius&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-bottom-left-radius = border-bottom-left-radius&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;border-bottom-right-radius&quot;,&quot;webkit&quot;:&quot;-webkit-border-bottom-right-radius&quot;,&quot;presto&quot;:&quot;border-bottom-right-radius&quot;,&quot;trident&quot;:&quot;border-bottom-right-radius&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-bottom-right-radius = border-bottom-right-radius&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-border-end&quot;,&quot;webkit&quot;:&quot;-webkit-border-end&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-end-color&quot;,&quot;webkit&quot;:&quot;-webkit-border-end-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-end-style&quot;,&quot;webkit&quot;:&quot;-webkit-border-end-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-end-width&quot;,&quot;webkit&quot;:&quot;-webkit-border-end-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-fit&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-horizontal-spacing&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-border-image&quot;,&quot;webkit&quot;:&quot;-webkit-border-image&quot;,&quot;presto&quot;:&quot;-o-border-image&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-border-left-colors&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;border-radius&quot;,&quot;webkit&quot;:&quot;-webkit-border-radius&quot;,&quot;presto&quot;:&quot;border-radius&quot;,&quot;trident&quot;:&quot;border-radius&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-border-right-colors&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-border-start&quot;,&quot;webkit&quot;:&quot;-webkit-border-start&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-start-color&quot;,&quot;webkit&quot;:&quot;-webkit-border-start-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-start-style&quot;,&quot;webkit&quot;:&quot;-webkit-border-start-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-start-width&quot;,&quot;webkit&quot;:&quot;-webkit-border-start-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-border-top-colors&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;border-top-left-radius&quot;,&quot;webkit&quot;:&quot;-webkit-border-top-left-radius&quot;,&quot;presto&quot;:&quot;border-top-left-radius&quot;,&quot;trident&quot;:&quot;border-top-left-radius&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-top-left-radius = border-top-left-radius&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;border-top-right-radius&quot;,&quot;webkit&quot;:&quot;-webkit-border-top-right-radius&quot;,&quot;presto&quot;:&quot;border-top-right-radius&quot;,&quot;trident&quot;:&quot;border-top-right-radius&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-top-right-radius = border-top-right-radius&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-border-vertical-spacing&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-box-align&quot;,&quot;webkit&quot;:&quot;-webkit-box-align&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-align&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-box-direction&quot;,&quot;webkit&quot;:&quot;-webkit-box-direction&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-direction&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-box-flex&quot;,&quot;webkit&quot;:&quot;-webkit-box-flex&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-flex&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-box-flex-group&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-line-progression&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-box-lines&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-lines&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-box-ordinal-group&quot;,&quot;webkit&quot;:&quot;-webkit-box-ordinal-group&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-ordinal-group&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-box-orient&quot;,&quot;webkit&quot;:&quot;-webkit-box-orient&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-orient&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-box-pack&quot;,&quot;webkit&quot;:&quot;-webkit-box-pack&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-box-pack&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-box-reflect&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;box-shadow&quot;,&quot;webkit&quot;:&quot;-webkit-box-shadow&quot;,&quot;presto&quot;:&quot;box-shadow&quot;,&quot;trident&quot;:&quot;box-shadow&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-box-sizing&quot;,&quot;webkit&quot;:&quot;box-sizing&quot;,&quot;presto&quot;:&quot;box-sizing&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-box-sizing = box-sizing&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-caption-side = caption-side&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-color-correction&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-column-break-after&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-column-break-before&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-column-break-inside&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-column-count&quot;,&quot;webkit&quot;:&quot;-webkit-column-count&quot;,&quot;presto&quot;:&quot;column-count&quot;,&quot;trident&quot;:&quot;column-count&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;-moz-column-gap&quot;,&quot;webkit&quot;:&quot;-webkit-column-gap&quot;,&quot;presto&quot;:&quot;column-gap&quot;,&quot;trident&quot;:&quot;column-gap&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;-moz-column-rule&quot;,&quot;webkit&quot;:&quot;-webkit-column-rule&quot;,&quot;presto&quot;:&quot;column-rule&quot;,&quot;trident&quot;:&quot;column-rule&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;-moz-column-rule-color&quot;,&quot;webkit&quot;:&quot;-webkit-column-rule-color&quot;,&quot;presto&quot;:&quot;column-rule-color&quot;,&quot;trident&quot;:&quot;column-rule-color&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;-moz-column-rule-style&quot;,&quot;webkit&quot;:&quot;-webkit-column-rule-style&quot;,&quot;presto&quot;:&quot;column-rule-style&quot;,&quot;trident&quot;:&quot;column-rule-style&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;-moz-column-rule-width&quot;,&quot;webkit&quot;:&quot;-webkit-column-rule-width&quot;,&quot;presto&quot;:&quot;column-rule-width&quot;,&quot;trident&quot;:&quot;column-rule-width&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-column-span&quot;,&quot;presto&quot;:&quot;column-span&quot;,&quot;trident&quot;:&quot;column-span&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;-moz-column-width&quot;,&quot;webkit&quot;:&quot;-webkit-column-width&quot;,&quot;presto&quot;:&quot;column-width&quot;,&quot;trident&quot;:&quot;column-width&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-columns&quot;,&quot;presto&quot;:&quot;columns&quot;,&quot;trident&quot;:&quot;columns&quot;,&quot;status&quot;:&quot;CR&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-dashboard-region&quot;,&quot;presto&quot;:&quot;-apple-dashboard-region&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;filter&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;filter&quot;,&quot;trident&quot;:&quot;-ms-filter&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-float-edge&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-focus-opacity&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-font-feature-settings&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-font-language-override&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-font-size-delta&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-font-smoothing&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-force-broken-image-icon&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-column&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-column-align&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-column-span&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-columns&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-layer&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-row&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-row-align&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-row-span&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-grid-rows&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-highlight&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-hyphenate-character&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-hyphenate-limit-after&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-hyphenate-limit-before&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-hyphens&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-hyphens = -webkit-hyphens&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-image-region&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;ime-mode&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-ime-mode&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-wap-input-format&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-wap-input-required&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-interpolation-mode&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-interpret-as&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-layout-flow&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-layout-grid&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-layout-grid-char&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-layout-grid-line&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-layout-grid-mode&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-layout-grid-type&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-line-box-contain&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-line-break&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-line-break&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-line-clamp&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-line-grid-mode&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-link&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-link-source&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-locale&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-logical-height&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-logical-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-after&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-after-collapse&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-before&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-before-collapse&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-bottom-collapse&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-collapse&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-margin-end&quot;,&quot;webkit&quot;:&quot;-webkit-margin-end&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-margin-start&quot;,&quot;webkit&quot;:&quot;-webkit-margin-start&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-margin-top-collapse&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-marquee&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-wap-marquee-dir&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-marquee-direction&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-marquee-increment&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-wap-marquee-loop&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-marquee-repetition&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-marquee-speed&quot;,&quot;presto&quot;:&quot;-wap-marquee-speed&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-marquee-style&quot;,&quot;presto&quot;:&quot;-wap-marquee-style&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;mask&quot;,&quot;webkit&quot;:&quot;-webkit-mask&quot;,&quot;presto&quot;:&quot;mask&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-attachment&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-box-image&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-clip&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-composite&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-image&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-origin&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-position&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-position-x&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-position-y&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-repeat&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-repeat-x&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-repeat-y&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-mask-size&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-match-nearest-mail-blockquote-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-max-logical-height&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-max-logical-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-min-logical-height&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-min-logical-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-mini-fold&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-nbsp-mode&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-object-fit&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-object-position&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;opacity&quot;,&quot;webkit&quot;:&quot;-webkit-opacity&quot;,&quot;presto&quot;:&quot;opacity&quot;,&quot;trident&quot;:&quot;opacity&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-opacity = opacity&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-outline-radius&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-outline-radius-bottomleft&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-outline-radius-bottomright&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-outline-radius-topleft&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-outline-radius-topright&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;overflow-x&quot;,&quot;webkit&quot;:&quot;overflow-x&quot;,&quot;presto&quot;:&quot;overflow-x&quot;,&quot;trident&quot;:&quot;-ms-overflow-x&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;overflow-y&quot;,&quot;webkit&quot;:&quot;overflow-y&quot;,&quot;presto&quot;:&quot;overflow-y&quot;,&quot;trident&quot;:&quot;-ms-overflow-y&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-padding-after&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-padding-before&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-padding-end&quot;,&quot;webkit&quot;:&quot;-webkit-padding-end&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;-moz-padding-start&quot;,&quot;webkit&quot;:&quot;-webkit-padding-start&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-perspective&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-perspective-origin&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-perspective-origin-x&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-perspective-origin-y&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-phonemes&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-rtl-ordering&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-script-level&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-script-min-size&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-script-size-multiplier&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-3dlight-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-3dlight-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-arrow-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-arrow-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-base-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-base-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-darkshadow-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-darkshadow-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-face-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-face-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-highlight-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-highlight-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-shadow-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-shadow-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;scrollbar-track-color&quot;,&quot;trident&quot;:&quot;-ms-scrollbar-track-color&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-stack-sizing&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-svg-shadow&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-tab-size&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-tab-size&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-o-table-baseline&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-tap-highlight-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-text-align-last&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-text-autospace&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-text-blink&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-combine&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-text-combine = -webkit-text-combine&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-text-decoration-color&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-text-decoration-line&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-text-decoration-style&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-decorations-in-effect&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-emphasis&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-text-emphasis = -webkit-text-emphasis&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-emphasis-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-text-emphasis-color = -webkit-text-emphasis-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-emphasis-position&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-emphasis-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-text-emphasis-style = -webkit-text-emphasis-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-fill-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-text-justify&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-text-kashida-space&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-orientation&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-text-orientation = -webkit-text-orientation&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;text-overflow&quot;,&quot;presto&quot;:&quot;text-overflow&quot;,&quot;trident&quot;:&quot;-ms-text-overflow&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-security&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-size-adjust&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-text-size-adjust&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-stroke&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-stroke-color&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-text-stroke-width&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-text-transform = text-transform&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-text-underline-position&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-touch-callout&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-transform&quot;,&quot;webkit&quot;:&quot;-webkit-transform&quot;,&quot;presto&quot;:&quot;-o-transform&quot;,&quot;trident&quot;:&quot;-ms-transform&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-transform-origin&quot;,&quot;webkit&quot;:&quot;-webkit-transform-origin&quot;,&quot;presto&quot;:&quot;-o-transform-origin&quot;,&quot;trident&quot;:&quot;-ms-transform-origin&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-transform-origin-x&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-transform-origin-y&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-transform-origin-z&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-transform-style&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-transition&quot;,&quot;webkit&quot;:&quot;-webkit-transition&quot;,&quot;presto&quot;:&quot;-o-transition&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-transition-delay&quot;,&quot;webkit&quot;:&quot;-webkit-transition-delay&quot;,&quot;presto&quot;:&quot;-o-transition-delay&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-transition-duration&quot;,&quot;webkit&quot;:&quot;-webkit-transition-duration&quot;,&quot;presto&quot;:&quot;-o-transition-duration&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-transition-property&quot;,&quot;webkit&quot;:&quot;-webkit-transition-property&quot;,&quot;presto&quot;:&quot;-o-transition-property&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;-moz-transition-timing-function&quot;,&quot;webkit&quot;:&quot;-webkit-transition-timing-function&quot;,&quot;presto&quot;:&quot;-o-transition-timing-function&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-user-drag&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-user-focus&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-user-input&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-user-modify&quot;,&quot;webkit&quot;:&quot;-webkit-user-modify&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;-moz-user-select&quot;,&quot;webkit&quot;:&quot;-webkit-user-select&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-balance&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-duration&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-pitch&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-pitch-range&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-rate&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-stress&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;-xv-voice-volume&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;-moz-window-shadow&quot;,&quot;webkit&quot;:&quot;&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;P&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;word-break&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-word-break&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-word-break = word-break&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;word-wrap&quot;,&quot;webkit&quot;:&quot;word-wrap&quot;,&quot;presto&quot;:&quot;word-wrap&quot;,&quot;trident&quot;:&quot;-ms-word-wrap&quot;,&quot;status&quot;:&quot;WD&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-webkit-writing-mode&quot;,&quot;presto&quot;:&quot;writing-mode&quot;,&quot;trident&quot;:&quot;-ms-writing-mode&quot;,&quot;status&quot;:&quot;ED&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;-epub-writing-mode = -webkit-writing-mode&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;},
{&quot;gecko&quot;:&quot;&quot;,&quot;webkit&quot;:&quot;zoom&quot;,&quot;presto&quot;:&quot;&quot;,&quot;trident&quot;:&quot;-ms-zoom&quot;,&quot;status&quot;:&quot;&quot;}]};
</P><P>var kCSS_PREFIXED_VALUE = [
</P><PRE> {&quot;gecko&quot;: &quot;-moz-box&quot;, &quot;webkit&quot;: &quot;-moz-box&quot;, &quot;presto&quot;: &quot;&quot;, &quot;trident&quot;: &quot;&quot;, &quot;generic&quot;: &quot;box&quot;}
</PRE><P>];
</P><P>var CssInspector = {
</P><PRE> mVENDOR_PREFIXES: null,
</PRE><PRE> kEXPORTS_FOR_GECKO:   true,
 kEXPORTS_FOR_WEBKIT:  true,
 kEXPORTS_FOR_PRESTO:  true,
 kEXPORTS_FOR_TRIDENT: true,
</PRE><PRE> cleanPrefixes: function()
 {
   this.mVENDOR_PREFIXES = null;
 },
</PRE><PRE> prefixesForProperty: function(aProperty)
 {
   if (!this.mVENDOR_PREFIXES) {
</PRE><PRE>     this.mVENDOR_PREFIXES = {};
     for (var i = 0; i &lt; kCSS_VENDOR_PREFIXES.properties.length; i++) {
       var p = kCSS_VENDOR_PREFIXES.properties[i];
       if (p.gecko &amp;&amp; (p.webkit || p.presto || p.trident)) {
         var o = {};
         if (this.kEXPORTS_FOR_GECKO) o[p.gecko] = true;
         if (this.kEXPORTS_FOR_WEBKIT &amp;&amp; p.webkit)  o[p.webkit] = true;
         if (this.kEXPORTS_FOR_PRESTO &amp;&amp; p.presto)  o[p.presto] = true;
         if (this.kEXPORTS_FOR_TRIDENT &amp;&amp; p.trident) o[p.trident] = true;
         this.mVENDOR_PREFIXES[p.gecko] = [];
         for (var j in o)
           this.mVENDOR_PREFIXES[p.gecko].push(j)
       }
     }
   }
   if (aProperty in this.mVENDOR_PREFIXES)
     return this.mVENDOR_PREFIXES[aProperty].sort();
   return null;
 },
</PRE><PRE> parseColorStop: function(parser, token)
 {
   var color = parser.parseColor(token);
   var position = &quot;&quot;;
   if (!color)
     return null;
   token = parser.getToken(true, true);
   if (token.isPercentage() ||
       token.isDimensionOfUnit(&quot;cm&quot;) ||
       token.isDimensionOfUnit(&quot;mm&quot;) ||
       token.isDimensionOfUnit(&quot;in&quot;) ||
       token.isDimensionOfUnit(&quot;pc&quot;) ||
       token.isDimensionOfUnit(&quot;px&quot;) ||
       token.isDimensionOfUnit(&quot;em&quot;) ||
       token.isDimensionOfUnit(&quot;ex&quot;) ||
       token.isDimensionOfUnit(&quot;pt&quot;)) {
     position = token.value;
     token = parser.getToken(true, true);
   }
   return { color: color, position: position }
 },
</PRE><PRE> parseGradient: function (parser, token)
 {
   var isRadial = false;
   var gradient = { isRepeating: false };
   if (token.isNotNull()) {
     if (token.isFunction(&quot;-moz-linear-gradient(&quot;) ||
         token.isFunction(&quot;-moz-radial-gradient(&quot;) ||
         token.isFunction(&quot;-moz-repeating-linear-gradient(&quot;) ||
         token.isFunction(&quot;-moz-repeating-radial-gradient(&quot;)) {
       if (token.isFunction(&quot;-moz-radial-gradient(&quot;) ||
           token.isFunction(&quot;-moz-repeating-radial-gradient(&quot;)) {
         gradient.isRadial = true;
       }
       if (token.isFunction(&quot;-moz-repeating-linear-gradient(&quot;) ||
           token.isFunction(&quot;-moz-repeating-radial-gradient(&quot;)) {
         gradient.isRepeating = true;
       }
       
</PRE><PRE>       token = parser.getToken(true, true);
       var haveGradientLine = false;
       var foundHorizPosition = false;
       var haveAngle = false;
</PRE><PRE>       if (token.isAngle()) {
         gradient.angle = token.value;
         haveGradientLine = true;
         haveAngle = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (token.isLength()
           || token.isIdent(&quot;top&quot;)
           || token.isIdent(&quot;center&quot;)
           || token.isIdent(&quot;bottom&quot;)
           || token.isIdent(&quot;left&quot;)
           || token.isIdent(&quot;right&quot;)) {
         haveGradientLine = true;
         if (token.isLength()
           || token.isIdent(&quot;left&quot;)
           || token.isIdent(&quot;right&quot;)) {
           foundHorizPosition = true;
         }
         gradient.position = token.value;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (haveGradientLine) {
         if (!haveAngle &amp;&amp; token.isAngle()) { // we have an angle here
           gradient.angle = token.value;
           haveAngle = true;
           token = parser.getToken(true, true);
         }
</PRE><PRE>         else if (token.isLength()
                 || (foundHorizPosition &amp;&amp; (token.isIdent(&quot;top&quot;)
                                            || token.isIdent(&quot;center&quot;)
                                            || token.isIdent(&quot;bottom&quot;)))
                 || (!foundHorizPosition &amp;&amp; (token.isLength()
                                             || token.isIdent(&quot;top&quot;)
                                             || token.isIdent(&quot;center&quot;)
                                             || token.isIdent(&quot;bottom&quot;)
                                             || token.isIdent(&quot;left&quot;)
                                             || token.isIdent(&quot;right&quot;)))) {
           gradient.position = (&quot;position&quot; in gradient)Â ? gradient.position + &quot; &quot;: &quot;&quot;;
           gradient.position += token.value;
           token = parser.getToken(true, true);
         }
</PRE><PRE>         if (!haveAngle &amp;&amp; token.isAngle()) { // we have an angle here
           gradient.angle = token.value;
           haveAngle = true;
           token = parser.getToken(true, true);
         }
</PRE><PRE>         // we must find a comma here
         if (!token.isSymbol(&quot;,&quot;))
           return null;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       // ok... Let's deal with the rest now
       if (gradient.isRadial) {
         if (token.isIdent(&quot;circle&quot;) ||
             token.isIdent(&quot;ellipse&quot;)) {
           gradient.shape = token.value;
           token = parser.getToken(true, true);
         }
         if (token.isIdent(&quot;closest-side&quot;) ||
                  token.isIdent(&quot;closest-corner&quot;) ||
                  token.isIdent(&quot;farthest-side&quot;) ||
                  token.isIdent(&quot;farthest-corner&quot;) ||
                  token.isIdent(&quot;contain&quot;) ||
                  token.isIdent(&quot;cover&quot;)) {
           gradient.size = token.value;
           token = parser.getToken(true, true);
         }
         if (!(&quot;shape&quot; in gradient) &amp;&amp;
             (token.isIdent(&quot;circle&quot;) ||
              token.isIdent(&quot;ellipse&quot;))) {
           // we can still have the second value...
           gradient.shape = token.value;
           token = parser.getToken(true, true);
         }
         if (((&quot;shape&quot; in gradient) || (&quot;size&quot; in gradient)) &amp;&amp;Â !token.isSymbol(&quot;,&quot;))
           return null;
         else if ((&quot;shape&quot; in gradient) || (&quot;size&quot; in gradient))
           token = parser.getToken(true, true);
       }
</PRE><PRE>       // now color stops...
       var stop1 = this.parseColorStop(parser, token);
       if (!stop1)
         return null;
       token = parser.currentToken();
       if (!token.isSymbol(&quot;,&quot;))
         return null;
       token = parser.getToken(true, true);
       var stop2 = this.parseColorStop(parser, token);
       if (!stop2)
         return null;
       token = parser.currentToken();
       if (token.isSymbol(&quot;,&quot;)) {
         token = parser.getToken(true, true);
       }
       // ok we have at least two color stops
       gradient.stops = [stop1, stop2];
       while (!token.isSymbol(&quot;)&quot;)) {
         var colorstop = this.parseColorStop(parser, token);
         if (!colorstop)
           return null;
         token = parser.currentToken();
         if (!token.isSymbol(&quot;)&quot;) &amp;&amp;Â !token.isSymbol(&quot;,&quot;))
           return null;
         if (token.isSymbol(&quot;,&quot;))
           token = parser.getToken(true, true);
         gradient.stops.push(colorstop);
       }
       return gradient;
     }
   }
   return null;
 },
</PRE><PRE> parseBoxShadows: function(aString)
 {
   var parser = new CSSParser();
   parser._init();
   parser.mPreserveWS       = false;
   parser.mPreserveComments = false;
   parser.mPreservedTokens = [];
   parser.mScanner.init(aString);
</PRE><PRE>   var shadows = [];
   var token = parser.getToken(true, true);
   var color = &quot;&quot;, blurRadius = &quot;0px&quot;, offsetX = &quot;0px&quot;, offsetY = &quot;0px&quot;, spreadRadius = &quot;0px&quot;;
   var inset = false;
   while (token.isNotNull()) {
     if (token.isIdent(&quot;none&quot;)) {
       shadows.push( { none: true } );
       token = parser.getToken(true, true);
     }
     else {
       if (token.isIdent('inset')) {
         inset = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var offsetX = token.value;
         token = parser.getToken(true, true);
       }
       else
         return [];
</PRE><PRE>       if (!inset &amp;&amp; token.isIdent('inset')) {
         inset = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var offsetX = token.value;
         token = parser.getToken(true, true);
       }
       else
         return [];
</PRE><PRE>       if (!inset &amp;&amp; token.isIdent('inset')) {
         inset = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var blurRadius = token.value;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (!inset &amp;&amp; token.isIdent('inset')) {
         inset = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var spreadRadius = token.value;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (!inset &amp;&amp; token.isIdent('inset')) {
         inset = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (token.isFunction(&quot;rgb(&quot;) ||
           token.isFunction(&quot;rgba(&quot;) ||
           token.isFunction(&quot;hsl(&quot;) ||
           token.isFunction(&quot;hsla(&quot;) ||
           token.isSymbol(&quot;#&quot;) ||
           token.isIdent()) {
         var color = parser.parseColor(token);
         token = parser.getToken(true, true);
       }
</PRE><PRE>       if (!inset &amp;&amp; token.isIdent('inset')) {
         inset = true;
         token = parser.getToken(true, true);
       }
</PRE><PRE>       shadows.push( { none: false,
                       color: color,
                       offsetX: offsetX, offsetY: offsetY,
                       blurRadius: blurRadius,
                       spreadRadius: spreadRadius } );
</PRE><PRE>       if (token.isSymbol(&quot;,&quot;)) {
         inset = false;
         color = &quot;&quot;;
         blurRadius = &quot;0px&quot;;
         spreadRadius = &quot;0px&quot;
         offsetX = &quot;0px&quot;;
         offsetY = &quot;0px&quot;; 
         token = parser.getToken(true, true);
       }
       else if (!token.isNotNull())
         return shadows;
       else
         return [];
     }
   }
   return shadows;
 },
</PRE><PRE> parseTextShadows: function(aString)
 {
   var parser = new CSSParser();
   parser._init();
   parser.mPreserveWS       = false;
   parser.mPreserveComments = false;
   parser.mPreservedTokens = [];
   parser.mScanner.init(aString);
</PRE><PRE>   var shadows = [];
   var token = parser.getToken(true, true);
   var color = &quot;&quot;, blurRadius = &quot;0px&quot;, offsetX = &quot;0px&quot;, offsetY = &quot;0px&quot;; 
   while (token.isNotNull()) {
     if (token.isIdent(&quot;none&quot;)) {
       shadows.push( { none: true } );
       token = parser.getToken(true, true);
     }
     else {
       if (token.isFunction(&quot;rgb(&quot;) ||
           token.isFunction(&quot;rgba(&quot;) ||
           token.isFunction(&quot;hsl(&quot;) ||
           token.isFunction(&quot;hsla(&quot;) ||
           token.isSymbol(&quot;#&quot;) ||
           token.isIdent()) {
         var color = parser.parseColor(token);
         token = parser.getToken(true, true);
       }
       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var offsetX = token.value;
         token = parser.getToken(true, true);
       }
       else
         return [];
       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var offsetY = token.value;
         token = parser.getToken(true, true);
       }
       else
         return [];
       if (token.isPercentage() ||
           token.isDimensionOfUnit(&quot;cm&quot;) ||
           token.isDimensionOfUnit(&quot;mm&quot;) ||
           token.isDimensionOfUnit(&quot;in&quot;) ||
           token.isDimensionOfUnit(&quot;pc&quot;) ||
           token.isDimensionOfUnit(&quot;px&quot;) ||
           token.isDimensionOfUnit(&quot;em&quot;) ||
           token.isDimensionOfUnit(&quot;ex&quot;) ||
           token.isDimensionOfUnit(&quot;pt&quot;)) {
         var blurRadius = token.value;
         token = parser.getToken(true, true);
       }
       if (!color &amp;&amp;
           (token.isFunction(&quot;rgb(&quot;) ||
            token.isFunction(&quot;rgba(&quot;) ||
            token.isFunction(&quot;hsl(&quot;) ||
            token.isFunction(&quot;hsla(&quot;) ||
            token.isSymbol(&quot;#&quot;) ||
            token.isIdent())) {
         var color = parser.parseColor(token);
         token = parser.getToken(true, true);
       }
</PRE><PRE>       shadows.push( { none: false,
                       color: color,
                       offsetX: offsetX, offsetY: offsetY,
                       blurRadius: blurRadius } );
</PRE><PRE>       if (token.isSymbol(&quot;,&quot;)) {
         color = &quot;&quot;;
         blurRadius = &quot;0px&quot;;
         offsetX = &quot;0px&quot;;
         offsetY = &quot;0px&quot;; 
         token = parser.getToken(true, true);
       }
       else if (!token.isNotNull())
         return shadows;
       else
         return [];
     }
   }
   return shadows;
 },
</PRE><PRE> parseBackgroundImages: function(aString)
 {
   var parser = new CSSParser();
   parser._init();
   parser.mPreserveWS       = false;
   parser.mPreserveComments = false;
   parser.mPreservedTokens = [];
   parser.mScanner.init(aString);
</PRE><PRE>   var backgrounds = [];
   var token = parser.getToken(true, true);
   while (token.isNotNull()) {
     /*if (token.isFunction(&quot;rgb(&quot;) ||
         token.isFunction(&quot;rgba(&quot;) ||
         token.isFunction(&quot;hsl(&quot;) ||
         token.isFunction(&quot;hsla(&quot;) ||
         token.isSymbol(&quot;#&quot;) ||
         token.isIdent()) {
       var color = parser.parseColor(token);
       backgrounds.push( { type: &quot;color&quot;, value: color });
       token = parser.getToken(true, true);
     }
     else */
     if (token.isFunction(&quot;url(&quot;)) {
       token = parser.getToken(true, true);
       var urlContent = parser.parseURL(token);
       backgrounds.push( { type: &quot;image&quot;, value: &quot;url(&quot; + urlContent });
       token = parser.getToken(true, true);
     }
     else if (token.isFunction(&quot;-moz-linear-gradient(&quot;) ||
              token.isFunction(&quot;-moz-radial-gradient(&quot;) ||
              token.isFunction(&quot;-moz-repeating-linear-gradient(&quot;) ||
              token.isFunction(&quot;-moz-repeating-radial-gradient(&quot;)) {
       var gradient = this.parseGradient(parser, token);
       backgrounds.push( { type: gradient.isRadialÂ ? &quot;radial-gradient&quot;Â : &quot;linear-gradient&quot;, value: gradient });
       token = parser.getToken(true, true);
     }
     else
       return null;
     if (token.isSymbol(&quot;,&quot;)) {
       token = parser.getToken(true, true);
       if (!token.isNotNull())
         return null;
     }
   }
   return backgrounds;
 },
</PRE><PRE> serializeGradient: function(gradient)
 {
   var s = gradient.isRadial
            Â ? (gradient.isRepeatingÂ ? &quot;-moz-repeating-radial-gradient(&quot;Â : &quot;-moz-radial-gradient(&quot; )
            Â : (gradient.isRepeatingÂ ? &quot;-moz-repeating-linear-gradient(&quot;Â : &quot;-moz-linear-gradient(&quot; );
   if (gradient.angle || gradient.position)
     s += (gradient.angleÂ ? gradient.angle + &quot; &quot;: &quot;&quot;) +
          (gradient.positionÂ ? gradient.positionÂ : &quot;&quot;) +
          &quot;, &quot;;
   if (gradient.isRadial &amp;&amp; (gradient.shape || gradient.size))
     s += (gradient.shapeÂ ? gradient.shapeÂ : &quot;&quot;) +
          &quot; &quot; +
          (gradient.sizeÂ ? gradient.sizeÂ : &quot;&quot;) +
          &quot;, &quot;;
   for (var i = 0; i &lt; gradient.stops.length; i++) {
     var colorstop = gradient.stops[i];
     s += colorstop.color + (colorstop.positionÂ ? &quot; &quot; + colorstop.positionÂ : &quot;&quot;);
     if (iÂ != gradient.stops.length -1)
       s += &quot;, &quot;;
   }
   s += &quot;)&quot;;
   return s;
 },
</PRE><PRE> parseBorderImage: function(aString)
 {
   var parser = new CSSParser();
   parser._init();
   parser.mPreserveWS       = false;
   parser.mPreserveComments = false;
   parser.mPreservedTokens = [];
   parser.mScanner.init(aString);
</PRE><PRE>   var borderImage = {url: &quot;&quot;, offsets: [], widths: [], sizes: []};
   var token = parser.getToken(true, true);
   if (token.isFunction(&quot;url(&quot;)) {
     token = parser.getToken(true, true);
     var urlContent = parser.parseURL(token);
     if (urlContent) {
       borderImage.url = urlContent.substr(0, urlContent.length - 1).trim();
       if ((borderImage.url[0] == '&quot;' &amp;&amp; borderImage.url[borderImage.url.length - 1] == '&quot;') ||
            (borderImage.url[0] == &quot;'&quot; &amp;&amp; borderImage.url[borderImage.url.length - 1] == &quot;'&quot;))
       borderImage.url = borderImage.url.substr(1, borderImage.url.length - 2);
     }
     else
       return null;
   }
   else
     return null; 
</PRE><PRE>   token = parser.getToken(true, true);
   if (token.isNumber() || token.isPercentage())
     borderImage.offsets.push(token.value);
   else
     return null;
   var i;
   for (i= 0; i &lt; 3; i++) {
     token = parser.getToken(true, true);
     if (token.isNumber() || token.isPercentage())
       borderImage.offsets.push(token.value);
     else
       break;
   }
   if (i == 3)
     token = parser.getToken(true, true);
</PRE><PRE>   if (token.isSymbol(&quot;/&quot;)) {
     token = parser.getToken(true, true);
     if (token.isDimension()
         || token.isNumber(&quot;0&quot;)
         || (token.isIdent() &amp;&amp; token.value in parser.kBORDER_WIDTH_NAMES))
       borderImage.widths.push(token.value);
     else
       return null;
</PRE><PRE>     for (var i = 0; i &lt; 3; i++) {
       token = parser.getToken(true, true);
       if (token.isDimension()
           || token.isNumber(&quot;0&quot;)
           || (token.isIdent() &amp;&amp; token.value in parser.kBORDER_WIDTH_NAMES))
         borderImage.widths.push(token.value);
       else
         break;
     }
     if (i == 3)
       token = parser.getToken(true, true);
   }
</PRE><PRE>   for (var i = 0; i &lt; 2; i++) {
     if (token.isIdent(&quot;stretch&quot;)
         || token.isIdent(&quot;repeat&quot;)
         || token.isIdent(&quot;round&quot;))
       borderImage.sizes.push(token.value);
     else if (!token.isNotNull())
       return borderImage;
     else
       return null;
     token = parser.getToken(true, true);
   }
   if (!token.isNotNull())
     return borderImage;
</PRE><PRE>   return null;
 },
</PRE><PRE> parseMediaQuery: function(aString)
 {
   var kCONSTRAINTS = {
     &quot;width&quot;: true,
     &quot;min-width&quot;: true,
     &quot;max-width&quot;: true,
     &quot;height&quot;: true,
     &quot;min-height&quot;: true,
     &quot;max-height&quot;: true,
     &quot;device-width&quot;: true,
     &quot;min-device-width&quot;: true,
     &quot;max-device-width&quot;: true,
     &quot;device-height&quot;: true,
     &quot;min-device-height&quot;: true,
     &quot;max-device-height&quot;: true,
     &quot;orientation&quot;: true,
     &quot;aspect-ratio&quot;: true,
     &quot;min-aspect-ratio&quot;: true,
     &quot;max-aspect-ratio&quot;: true,
     &quot;device-aspect-ratio&quot;: true,
     &quot;min-device-aspect-ratio&quot;: true,
     &quot;max-device-aspect-ratio&quot;: true,
     &quot;color&quot;: true,
     &quot;min-color&quot;: true,
     &quot;max-color&quot;: true,
     &quot;color-index&quot;: true,
     &quot;min-color-index&quot;: true,
     &quot;max-color-index&quot;: true,
     &quot;monochrome&quot;: true,
     &quot;min-monochrome&quot;: true,
     &quot;max-monochrome&quot;: true,
     &quot;resolution&quot;: true,
     &quot;min-resolution&quot;: true,
     &quot;max-resolution&quot;: true,
     &quot;scan&quot;: true,
     &quot;grid&quot;: true
   };
   var parser = new CSSParser();
   parser._init();
   parser.mPreserveWS       = false;
   parser.mPreserveComments = false;
   parser.mPreservedTokens = [];
   parser.mScanner.init(aString);
</PRE><PRE>   var m = {amplifier: &quot;&quot;, medium: &quot;&quot;, constraints: []};
   var token = parser.getToken(true, true);
</PRE><PRE>   if (token.isIdent(&quot;all&quot;) ||
       token.isIdent(&quot;aural&quot;) ||
       token.isIdent(&quot;braille&quot;) ||
       token.isIdent(&quot;handheld&quot;) ||
       token.isIdent(&quot;print&quot;) ||
       token.isIdent(&quot;projection&quot;) ||
       token.isIdent(&quot;screen&quot;) ||
       token.isIdent(&quot;tty&quot;) ||
       token.isIdent(&quot;tv&quot;)) {
      m.medium = token.value;
      token = parser.getToken(true, true);
   }
   else if (token.isIdent(&quot;not&quot;) || token.isIdent(&quot;only&quot;)) {
     m.amplifier = token.value;
     token = parser.getToken(true, true);
     if (token.isIdent(&quot;all&quot;) ||
         token.isIdent(&quot;aural&quot;) ||
         token.isIdent(&quot;braille&quot;) ||
         token.isIdent(&quot;handheld&quot;) ||
         token.isIdent(&quot;print&quot;) ||
         token.isIdent(&quot;projection&quot;) ||
         token.isIdent(&quot;screen&quot;) ||
         token.isIdent(&quot;tty&quot;) ||
         token.isIdent(&quot;tv&quot;)) {
        m.medium = token.value;
        token = parser.getToken(true, true);
     }
     else
       return null;
   }
</PRE><PRE>   if (m.medium) {
     if (!token.isNotNull())
       return m;
     if (token.isIdent(&quot;and&quot;)) {
       token = parser.getToken(true, true);
     }
     else
       return null;
   }
</PRE><PRE>   while (token.isSymbol(&quot;(&quot;)) {
     token = parser.getToken(true, true);
     if (token.isIdent() &amp;&amp; (token.value in kCONSTRAINTS)) {
       var constraint = token.value;
       token = parser.getToken(true, true);
       if (token.isSymbol(&quot;:&quot;)) {
         token = parser.getToken(true, true);
         var values = [];
         while (!token.isSymbol(&quot;)&quot;)) {
           values.push(token.value);
           token = parser.getToken(true, true);
         }
         if (token.isSymbol(&quot;)&quot;)) {
           m.constraints.push({constraint: constraint, value: values});
           token = parser.getToken(true, true);
           if (token.isNotNull()) {
             if (token.isIdent(&quot;and&quot;)) {
               token = parser.getToken(true, true);
             }
             else
               return null;
           }
           else
             return m;
         }
         else
           return null;
       }
       else if (token.isSymbol(&quot;)&quot;)) {
         m.constraints.push({constraint: constraint, value: null});
         token = parser.getToken(true, true);
         if (token.isNotNull()) {
           if (token.isIdent(&quot;and&quot;)) {
             token = parser.getToken(true, true);
           }
           else
             return null;
         }
         else
           return m;
       }
       else
         return null;
     }
     else
       return null;
   }
   return m;
 }
</PRE><P>};
</P><P>
/************************************************************/
/************************** JSCSSP **************************/
/************************************************************/
</P><P>var CSS_ESCAPE  = '\\';
</P><P>var IS_HEX_DIGIT  = 1;
var START_IDENT   = 2;
var IS_IDENT      = 4;
var IS_WHITESPACE = 8;
</P><P>var W   = IS_WHITESPACE;
var I   = IS_IDENT;
var S   =          START_IDENT;
var SI  = IS_IDENT|START_IDENT;
var XI  = IS_IDENT            |IS_HEX_DIGIT;
var XSI = IS_IDENT|START_IDENT|IS_HEX_DIGIT;
</P><P>function CSSScanner(aString)
{
</P><PRE> this.init(aString);
</PRE><P>}
</P><P>CSSScanner.prototype = {
</P><PRE> kLexTable: [
 //                                     TAB LF      FF  CR
    0,  0,  0,  0,  0,  0,  0,  0,  0,  W,  W,  0,  W,  W,  0,  0,
 //
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 // SPCÂ !   &quot;   #   $  Â %   &amp;   '   (   )   *   +   ,   -   .   /
    W,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  I,  0,  0,
 // 0   1   2   3   4   5   6   7   8   9  Â :  Â ;   &lt;   =   &gt;Â ?
    XI, XI, XI, XI, XI, XI, XI, XI, XI, XI, 0,  0,  0,  0,  0,  0,
 // @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
    0,  XSI,XSI,XSI,XSI,XSI,XSI,SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, 0,  S,  0,  0,  SI,
 // `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
    0,  XSI,XSI,XSI,XSI,XSI,XSI,SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, 0,  0,  0,  0,  0,
 //
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 //
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 //     Â¡   Â¢   Â£   Â¤   Â¥   Â¦   Â§   Â¨   Â©   Âª   Â«Â   Â¬   Â­   Â®   Â¯
    0,  SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // Â°   Â±   Â²   Â³   Â´   Âµ   Â¶   Â·   Â¸   Â¹   Âº  Â Â»   Â¼   Â½   Â¾   Â¿
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã   Ã
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // Ã    Ã¡   Ã¢   Ã£   Ã¤   Ã¥   Ã¦   Ã§   Ã¨   Ã©   Ãª   Ã«   Ã¬   Ã­   Ã®   Ã¯
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI,
 // Ã°   Ã±   Ã²   Ã³   Ã´   Ãµ   Ã¶   Ã·   Ã¸   Ã¹   Ãº   Ã»   Ã¼   Ã½   Ã¾   Ã¿
    SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI, SI
 ],
</PRE><PRE> kHexValues: {
   &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4, &quot;5&quot;: 5, &quot;6&quot;: 6, &quot;7&quot;: 7, &quot;8&quot;: 8, &quot;9&quot;: 9,
   &quot;a&quot;: 10, &quot;b&quot;: 11, &quot;c&quot;: 12, &quot;d&quot;: 13, &quot;e&quot;: 14, &quot;f&quot;: 15
 },
</PRE><PRE> mStringÂ : &quot;&quot;,
 mPosÂ : 0,
 mPreservedPosÂ : [],
</PRE><PRE> init: function(aString) {
   this.mString = aString;
   this.mPos = 0;
   this.mPreservedPos = [];
 },
</PRE><PRE> getCurrentPos: function() {
   return this.mPos;
 },
</PRE><PRE> getAlreadyScanned: function()
 {
   return this.mString.substr(0, this.mPos);
 },
</PRE><PRE> preserveState: function() {
   this.mPreservedPos.push(this.mPos);
 },
</PRE><PRE> restoreState: function() {
   if (this.mPreservedPos.length) {
     this.mPos = this.mPreservedPos.pop();
   }
 },
</PRE><PRE> forgetState: function() {
   if (this.mPreservedPos.length) {
     this.mPreservedPos.pop();
   }
 },
</PRE><PRE> read: function() {
   if (this.mPos &lt; this.mString.length)
     return this.mString.charAt(this.mPos++);
   return -1;
 },
</PRE><PRE> peek: function() {
   if (this.mPos &lt; this.mString.length)
     return this.mString.charAt(this.mPos);
   return -1;
 },
</PRE><PRE> isHexDigit: function(c) {
   var code = c.charCodeAt(0);
   return (code &lt; 256 &amp;&amp; (this.kLexTable[code] &amp; IS_HEX_DIGIT)Â != 0);
 },
</PRE><PRE> isIdentStart: function(c) {
   var code = c.charCodeAt(0);
   return (code &gt;= 256 || (this.kLexTable[code] &amp; START_IDENT)Â != 0);
 },
</PRE><PRE> startsWithIdent: function(aFirstChar, aSecondChar) {
   var code = aFirstChar.charCodeAt(0);
   return this.isIdentStart(aFirstChar) ||
          (aFirstChar == &quot;-&quot; &amp;&amp; this.isIdentStart(aSecondChar));
 },
</PRE><PRE> isIdent: function(c) {
   var code = c.charCodeAt(0);
   return (code &gt;= 256 || (this.kLexTable[code] &amp; IS_IDENT)Â != 0);
 },
</PRE><PRE> isSymbol: function(c) {
   var code = c.charCodeAt(0);
   return (this.kLexTable[code] &amp; IS_IDENT)Â != 1;
 },
</PRE><PRE> pushback: function() {
   this.mPos--;
 },
</PRE><PRE> nextHexValue: function() {
   var c = this.read();
   if (c == -1 ||Â !this.isHexDigit(c))
     return new jscsspToken(jscsspToken.NULL_TYPE, null);
   var s = c;
   c = this.read();
   while (cÂ != -1 &amp;&amp; this.isHexDigit(c)) {
     s += c;
     c = this.read();
   }
   if (cÂ != -1)
     this.pushback();
   return new jscsspToken(jscsspToken.HEX_TYPE, s);
 },
</PRE><PRE> gatherEscape: function() {
   var c = this.peek();
   if (c == -1)
     return &quot;&quot;;
   if (this.isHexDigit(c)) {
     var code = 0;
     for (var i = 0; i &lt; 6; i++) {
       c = this.read();
       if (this.isHexDigit(c))
         code = code * 16 + this.kHexValues[c.toLowerCase()];
       else if (!this.isHexDigit(c) &amp;&amp;Â !this.isWhiteSpace(c)) {
         this.pushback();
         break;
       }
       else
         break;
     }
     if (i == 6) {
       c = this.peek();
       if (this.isWhiteSpace(c))
         this.read();
     }
     return String.fromCharCode(code);
   }
   c = this.read();
   if (cÂ != &quot;\n&quot;)
     return c;
   return &quot;&quot;;
 },
</PRE><PRE> gatherIdent: function(c) {
   var s = &quot;&quot;;
   if (c == CSS_ESCAPE)
     s += this.gatherEscape();
   else
     s += c;
   c = this.read();
</PRE><P>	if(!this.mMediaQueryMode){
		while (cÂ != -1
			   &amp;&amp; (this.isIdent(c) || c == CSS_ESCAPE)) {
		  if (c == CSS_ESCAPE)
			s += this.gatherEscape();
		  else
			s += c;
		  c = this.read();
		}
	}
	else {
		while (cÂ != -1
			   &amp;&amp; cÂ != '{' 
			   &amp;&amp; cÂ != ',') {
			s += c;
		  c = this.read();
		}
	}
</P><PRE>   if (cÂ != -1)
     this.pushback();
</PRE><P>	  this.mMediaQueryMode = false;
</P><PRE>   return s;
 },
</PRE><PRE> parseIdent: function(c) {
</PRE><P>	var value = this.gatherIdent(c);
</P><PRE>   var nextChar = this.peek();
   if (nextChar == &quot;(&quot;) {
     value += this.read();
     return new jscsspToken(jscsspToken.FUNCTION_TYPE, value);
   }
   return new jscsspToken(jscsspToken.IDENT_TYPE, value);
 },
</PRE><PRE> isDigit: function(c) {
   return (c &gt;= '0') &amp;&amp; (c &lt;= '9');
 },
</PRE><PRE> parseComment: function(c) {
   var s = c;
   while ((c = this.read())Â != -1) {
     s += c;
     if (c == &quot;*&quot;) {
       c = this.read();
       if (c == -1)
         break;
       if (c == &quot;/&quot;) {
         s += c;
         break;
       }
       this.pushback();
     }
   }
   return new jscsspToken(jscsspToken.COMMENT_TYPE, s);
 },
</PRE><PRE> parseNumber: function(c) {
   var s = c;
   var foundDot = false;
   while ((c = this.read())Â != -1) {
     if (c == &quot;.&quot;) {
       if (foundDot)
         break;
       else {
         s += c;
         foundDot = true;
       }
     } else if (this.isDigit(c))
       s += c;
     else
       break;
   }
</PRE><PRE>   if (cÂ != -1 &amp;&amp; this.startsWithIdent(c, this.peek())) { // DIMENSION
     var unit = this.gatherIdent(c);
     s += unit;
     return new jscsspToken(jscsspToken.DIMENSION_TYPE, s, unit);
   }
   else if (c == &quot;%&quot;) {
     s += &quot;%&quot;;
     return new jscsspToken(jscsspToken.PERCENTAGE_TYPE, s);
   }
   else if (cÂ != -1)
     this.pushback();
   return new jscsspToken(jscsspToken.NUMBER_TYPE, s);
 },
</PRE><PRE> parseString: function(aStop) {
   var s = aStop;
   var previousChar = aStop;
   var c;
   while ((c = this.read())Â != -1) {
     if (c == aStop &amp;&amp; previousCharÂ != CSS_ESCAPE) {
       s += c;
       break;
     }
     else if (c == CSS_ESCAPE) {
       c = this.peek();
       if (c == -1)
         break;
       else if (c == &quot;\n&quot; || c == &quot;\r&quot; || c == &quot;\f&quot;) {
         d = c;
         c = this.read();
         // special for Opera that preserves \r\n...
         if (d == &quot;\r&quot;) {
           c = this.peek();
           if (c == &quot;\n&quot;)
             c = this.read();
         }
       }
       else {
         s += this.gatherEscape();
         c = this.peek();
       }
     }
     else if (c == &quot;\n&quot; || c == &quot;\r&quot; || c == &quot;\f&quot;) {
       break;
     }
     else
       s += c;
</PRE><PRE>     previousChar = c;
   }
   return new jscsspToken(jscsspToken.STRING_TYPE, s);
 },
</PRE><PRE> isWhiteSpace: function(c) {
   var code = c.charCodeAt(0);
   return code &lt; 256 &amp;&amp; (this.kLexTable[code] &amp; IS_WHITESPACE)Â != 0;
 },
</PRE><PRE> eatWhiteSpace: function(c) {
   var s = c;
   while ((c = this.read())Â != -1) {
     if (!this.isWhiteSpace(c))
       break;
     s += c;
   }
   if (cÂ != -1)
     this.pushback();
   return s;
 },
</PRE><PRE> parseAtKeyword: function(c) {
   return new jscsspToken(jscsspToken.ATRULE_TYPE, this.gatherIdent(c));
 },
</PRE><PRE> nextToken: function() {
   var c = this.read();
   if (c == -1)
     return new jscsspToken(jscsspToken.NULL_TYPE, null);
</PRE><PRE>   if (this.startsWithIdent(c, this.peek()))
     return this.parseIdent(c);
</PRE><PRE>   if (c == '@') {
     var nextChar = this.read();
     if (nextCharÂ != -1) {
       var followingChar = this.peek();
       this.pushback();
       if (this.startsWithIdent(nextChar, followingChar))
         return this.parseAtKeyword(c);
     }
   }
</PRE><PRE>   if (c == &quot;.&quot; || c == &quot;+&quot; || c == &quot;-&quot;) {
     var nextChar = this.peek();
     if (this.isDigit(nextChar))
       return this.parseNumber(c);
     else if (nextChar == &quot;.&quot; &amp;&amp; cÂ != &quot;.&quot;) {
       firstChar = this.read();
       var secondChar = this.peek();
       this.pushback();
       if (this.isDigit(secondChar))
         return this.parseNumber(c);
     }
   }
   if (this.isDigit(c)) {
     return this.parseNumber(c);
   }
</PRE><PRE>   if (c == &quot;'&quot; || c == '&quot;')
     return this.parseString(c);
</PRE><PRE>   if (this.isWhiteSpace(c)) {
     var s = this.eatWhiteSpace(c);
     
     return new jscsspToken(jscsspToken.WHITESPACE_TYPE, s);
   }
</PRE><PRE>   if (c == &quot;|&quot; || c == &quot;~&quot; || c == &quot;^&quot; || c == &quot;$&quot; || c == &quot;*&quot;) {
     var nextChar = this.read();
     if (nextChar == &quot;=&quot;) {
       switch (c) {
         case &quot;~&quot;Â :
           return new jscsspToken(jscsspToken.INCLUDES_TYPE, &quot;~=&quot;);
         case &quot;|&quot;Â :
           return new jscsspToken(jscsspToken.DASHMATCH_TYPE, &quot;|=&quot;);
         case &quot;^&quot;Â :
           return new jscsspToken(jscsspToken.BEGINSMATCH_TYPE, &quot;^=&quot;);
         case &quot;$&quot;Â :
           return new jscsspToken(jscsspToken.ENDSMATCH_TYPE, &quot;$=&quot;);
         case &quot;*&quot;Â :
           return new jscsspToken(jscsspToken.CONTAINSMATCH_TYPE, &quot;*=&quot;);
         defaultÂ :
           break;
       }
     } else if (nextCharÂ != -1)
       this.pushback();
   }
</PRE><PRE>   if (c == &quot;/&quot; &amp;&amp; this.peek() == &quot;*&quot;)
     return this.parseComment(c);
</PRE><PRE>   return new jscsspToken(jscsspToken.SYMBOL_TYPE, c);
 }
</PRE><P>};
</P><P>function CSSParser(aString)
{
</P><PRE> this.mToken = null;
 this.mLookAhead = null;
 this.mScanner = new CSSScanner(aString);
</PRE><PRE> this.mPreserveWS = true;
 this.mPreserveComments = true;
</PRE><PRE> this.mPreservedTokens = [];
 
 this.mError = null;
</PRE><P>}
</P><P>CSSParser.prototype = {
</P><PRE> _init:function() {
   this.mToken = null;
   this.mLookAhead = null;
   this.mMediaQueryMode = false;
 },
</PRE><PRE> kINHERIT: &quot;inherit&quot;,
</PRE><PRE> kBORDER_WIDTH_NAMES: {
     &quot;thin&quot;: true,
     &quot;medium&quot;: true,
     &quot;thick&quot;: true
 },
</PRE><PRE> kBORDER_STYLE_NAMES: {
   &quot;none&quot;: true,
   &quot;hidden&quot;: true,
   &quot;dotted&quot;: true,
   &quot;dashed&quot;: true,
   &quot;solid&quot;: true,
   &quot;double&quot;: true,
   &quot;groove&quot;: true,
   &quot;ridge&quot;: true,
   &quot;inset&quot;: true,
   &quot;outset&quot;: true
 },
</PRE><PRE> kCOLOR_NAMES: {
   &quot;transparent&quot;: true,
 
   &quot;black&quot;: true,
   &quot;silver&quot;: true,
   &quot;gray&quot;: true,
   &quot;white&quot;: true,
   &quot;maroon&quot;: true,
   &quot;red&quot;: true,
   &quot;purple&quot;: true,
   &quot;fuchsia&quot;: true,
   &quot;green&quot;: true,
   &quot;lime&quot;: true,
   &quot;olive&quot;: true,
   &quot;yellow&quot;: true,
   &quot;navy&quot;: true,
   &quot;blue&quot;: true,
   &quot;teal&quot;: true,
   &quot;aqua&quot;: true,
   
   &quot;aliceblue&quot;: true,
   &quot;antiquewhite&quot;: true,
   &quot;aqua&quot;: true,
   &quot;aquamarine&quot;: true,
   &quot;azure&quot;: true,
   &quot;beige&quot;: true,
   &quot;bisque&quot;: true,
   &quot;black&quot;: true,
   &quot;blanchedalmond&quot;: true,
   &quot;blue&quot;: true,
   &quot;blueviolet&quot;: true,
   &quot;brown&quot;: true,
   &quot;burlywood&quot;: true,
   &quot;cadetblue&quot;: true,
   &quot;chartreuse&quot;: true,
   &quot;chocolate&quot;: true,
   &quot;coral&quot;: true,
   &quot;cornflowerblue&quot;: true,
   &quot;cornsilk&quot;: true,
   &quot;crimson&quot;: true,
   &quot;cyan&quot;: true,
   &quot;darkblue&quot;: true,
   &quot;darkcyan&quot;: true,
   &quot;darkgoldenrod&quot;: true,
   &quot;darkgray&quot;: true,
   &quot;darkgreen&quot;: true,
   &quot;darkgrey&quot;: true,
   &quot;darkkhaki&quot;: true,
   &quot;darkmagenta&quot;: true,
   &quot;darkolivegreen&quot;: true,
   &quot;darkorange&quot;: true,
   &quot;darkorchid&quot;: true,
   &quot;darkred&quot;: true,
   &quot;darksalmon&quot;: true,
   &quot;darkseagreen&quot;: true,
   &quot;darkslateblue&quot;: true,
   &quot;darkslategray&quot;: true,
   &quot;darkslategrey&quot;: true,
   &quot;darkturquoise&quot;: true,
   &quot;darkviolet&quot;: true,
   &quot;deeppink&quot;: true,
   &quot;deepskyblue&quot;: true,
   &quot;dimgray&quot;: true,
   &quot;dimgrey&quot;: true,
   &quot;dodgerblue&quot;: true,
   &quot;firebrick&quot;: true,
   &quot;floralwhite&quot;: true,
   &quot;forestgreen&quot;: true,
   &quot;fuchsia&quot;: true,
   &quot;gainsboro&quot;: true,
   &quot;ghostwhite&quot;: true,
   &quot;gold&quot;: true,
   &quot;goldenrod&quot;: true,
   &quot;gray&quot;: true,
   &quot;green&quot;: true,
   &quot;greenyellow&quot;: true,
   &quot;grey&quot;: true,
   &quot;honeydew&quot;: true,
   &quot;hotpink&quot;: true,
   &quot;indianred&quot;: true,
   &quot;indigo&quot;: true,
   &quot;ivory&quot;: true,
   &quot;khaki&quot;: true,
   &quot;lavender&quot;: true,
   &quot;lavenderblush&quot;: true,
   &quot;lawngreen&quot;: true,
   &quot;lemonchiffon&quot;: true,
   &quot;lightblue&quot;: true,
   &quot;lightcoral&quot;: true,
   &quot;lightcyan&quot;: true,
   &quot;lightgoldenrodyellow&quot;: true,
   &quot;lightgray&quot;: true,
   &quot;lightgreen&quot;: true,
   &quot;lightgrey&quot;: true,
   &quot;lightpink&quot;: true,
   &quot;lightsalmon&quot;: true,
   &quot;lightseagreen&quot;: true,
   &quot;lightskyblue&quot;: true,
   &quot;lightslategray&quot;: true,
   &quot;lightslategrey&quot;: true,
   &quot;lightsteelblue&quot;: true,
   &quot;lightyellow&quot;: true,
   &quot;lime&quot;: true,
   &quot;limegreen&quot;: true,
   &quot;linen&quot;: true,
   &quot;magenta&quot;: true,
   &quot;maroon&quot;: true,
   &quot;mediumaquamarine&quot;: true,
   &quot;mediumblue&quot;: true,
   &quot;mediumorchid&quot;: true,
   &quot;mediumpurple&quot;: true,
   &quot;mediumseagreen&quot;: true,
   &quot;mediumslateblue&quot;: true,
   &quot;mediumspringgreen&quot;: true,
   &quot;mediumturquoise&quot;: true,
   &quot;mediumvioletred&quot;: true,
   &quot;midnightblue&quot;: true,
   &quot;mintcream&quot;: true,
   &quot;mistyrose&quot;: true,
   &quot;moccasin&quot;: true,
   &quot;navajowhite&quot;: true,
   &quot;navy&quot;: true,
   &quot;oldlace&quot;: true,
   &quot;olive&quot;: true,
   &quot;olivedrab&quot;: true,
   &quot;orange&quot;: true,
   &quot;orangered&quot;: true,
   &quot;orchid&quot;: true,
   &quot;palegoldenrod&quot;: true,
   &quot;palegreen&quot;: true,
   &quot;paleturquoise&quot;: true,
   &quot;palevioletred&quot;: true,
   &quot;papayawhip&quot;: true,
   &quot;peachpuff&quot;: true,
   &quot;peru&quot;: true,
   &quot;pink&quot;: true,
   &quot;plum&quot;: true,
   &quot;powderblue&quot;: true,
   &quot;purple&quot;: true,
   &quot;red&quot;: true,
   &quot;rosybrown&quot;: true,
   &quot;royalblue&quot;: true,
   &quot;saddlebrown&quot;: true,
   &quot;salmon&quot;: true,
   &quot;sandybrown&quot;: true,
   &quot;seagreen&quot;: true,
   &quot;seashell&quot;: true,
   &quot;sienna&quot;: true,
   &quot;silver&quot;: true,
   &quot;skyblue&quot;: true,
   &quot;slateblue&quot;: true,
   &quot;slategray&quot;: true,
   &quot;slategrey&quot;: true,
   &quot;snow&quot;: true,
   &quot;springgreen&quot;: true,
   &quot;steelblue&quot;: true,
   &quot;tan&quot;: true,
   &quot;teal&quot;: true,
   &quot;thistle&quot;: true,
   &quot;tomato&quot;: true,
   &quot;turquoise&quot;: true,
   &quot;violet&quot;: true,
   &quot;wheat&quot;: true,
   &quot;white&quot;: true,
   &quot;whitesmoke&quot;: true,
   &quot;yellow&quot;: true,
   &quot;yellowgreen&quot;: true,
 
   &quot;activeborder&quot;: true,
   &quot;activecaption&quot;: true,
   &quot;appworkspace&quot;: true,
   &quot;background&quot;: true,
   &quot;buttonface&quot;: true,
   &quot;buttonhighlight&quot;: true,
   &quot;buttonshadow&quot;: true,
   &quot;buttontext&quot;: true,
   &quot;captiontext&quot;: true,
   &quot;graytext&quot;: true,
   &quot;highlight&quot;: true,
   &quot;highlighttext&quot;: true,
   &quot;inactiveborder&quot;: true,
   &quot;inactivecaption&quot;: true,
   &quot;inactivecaptiontext&quot;: true,
   &quot;infobackground&quot;: true,
   &quot;infotext&quot;: true,
   &quot;menu&quot;: true,
   &quot;menutext&quot;: true,
   &quot;scrollbar&quot;: true,
   &quot;threeddarkshadow&quot;: true,
   &quot;threedface&quot;: true,
   &quot;threedhighlight&quot;: true,
   &quot;threedlightshadow&quot;: true,
   &quot;threedshadow&quot;: true,
   &quot;window&quot;: true,
   &quot;windowframe&quot;: true,
   &quot;windowtext&quot;: true
 },
</PRE><PRE> kLIST_STYLE_TYPE_NAMES: {
   &quot;decimal&quot;: true,
   &quot;decimal-leading-zero&quot;: true,
   &quot;lower-roman&quot;: true,
   &quot;upper-roman&quot;: true,
   &quot;georgian&quot;: true,
   &quot;armenian&quot;: true,
   &quot;lower-latin&quot;: true,
   &quot;lower-alpha&quot;: true,
   &quot;upper-latin&quot;: true,
   &quot;upper-alpha&quot;: true,
   &quot;lower-greek&quot;: true,
</PRE><PRE>   &quot;disc&quot;: true,
   &quot;circle&quot;: true,
   &quot;square&quot;: true,
   &quot;none&quot;: true,
   
   /* CSS 3 */
   &quot;box&quot;: true,
   &quot;check&quot;: true,
   &quot;diamond&quot;: true,
   &quot;hyphen&quot;: true,
</PRE><PRE>   &quot;lower-armenian&quot;: true,
   &quot;cjk-ideographic&quot;: true,
   &quot;ethiopic-numeric&quot;: true,
   &quot;hebrew&quot;: true,
   &quot;japanese-formal&quot;: true,
   &quot;japanese-informal&quot;: true,
   &quot;simp-chinese-formal&quot;: true,
   &quot;simp-chinese-informal&quot;: true,
   &quot;syriac&quot;: true,
   &quot;tamil&quot;: true,
   &quot;trad-chinese-formal&quot;: true,
   &quot;trad-chinese-informal&quot;: true,
   &quot;upper-armenian&quot;: true,
   &quot;arabic-indic&quot;: true,
   &quot;binary&quot;: true,
   &quot;bengali&quot;: true,
   &quot;cambodian&quot;: true,
   &quot;khmer&quot;: true,
   &quot;devanagari&quot;: true,
   &quot;gujarati&quot;: true,
   &quot;gurmukhi&quot;: true,
   &quot;kannada&quot;: true,
   &quot;lower-hexadecimal&quot;: true,
   &quot;lao&quot;: true,
   &quot;malayalam&quot;: true,
   &quot;mongolian&quot;: true,
   &quot;myanmar&quot;: true,
   &quot;octal&quot;: true,
   &quot;oriya&quot;: true,
   &quot;persian&quot;: true,
   &quot;urdu&quot;: true,
   &quot;telugu&quot;: true,
   &quot;tibetan&quot;: true,
   &quot;upper-hexadecimal&quot;: true,
   &quot;afar&quot;: true,
   &quot;ethiopic-halehame-aa-et&quot;: true,
   &quot;ethiopic-halehame-am-et&quot;: true,
   &quot;amharic-abegede&quot;: true,
   &quot;ehiopic-abegede-am-et&quot;: true,
   &quot;cjk-earthly-branch&quot;: true,
   &quot;cjk-heavenly-stem&quot;: true,
   &quot;ethiopic&quot;: true,
   &quot;ethiopic-abegede&quot;: true,
   &quot;ethiopic-abegede-gez&quot;: true,
   &quot;hangul-consonant&quot;: true,
   &quot;hangul&quot;: true,
   &quot;hiragana-iroha&quot;: true,
   &quot;hiragana&quot;: true,
   &quot;katakana-iroha&quot;: true,
   &quot;katakana&quot;: true,
   &quot;lower-norwegian&quot;: true,
   &quot;oromo&quot;: true,
   &quot;ethiopic-halehame-om-et&quot;: true,
   &quot;sidama&quot;: true,
   &quot;ethiopic-halehame-sid-et&quot;: true,
   &quot;somali&quot;: true,
   &quot;ethiopic-halehame-so-et&quot;: true,
   &quot;tigre&quot;: true,
   &quot;ethiopic-halehame-tig&quot;: true,
   &quot;tigrinya-er-abegede&quot;: true,
   &quot;ethiopic-abegede-ti-er&quot;: true,
   &quot;tigrinya-et&quot;: true,
   &quot;ethiopic-halehame-ti-et&quot;: true,
   &quot;upper-greek&quot;: true,
   &quot;asterisks&quot;: true,
   &quot;footnotes&quot;: true,
   &quot;circled-decimal&quot;: true,
   &quot;circled-lower-latin&quot;: true,
   &quot;circled-upper-latin&quot;: true,
   &quot;dotted-decimal&quot;: true,
   &quot;double-circled-decimal&quot;: true,
   &quot;filled-circled-decimal&quot;: true,
   &quot;parenthesised-decimal&quot;: true,
   &quot;parenthesised-lower-latin&quot;: true
 },
</PRE><PRE> reportError: function(aMsg) {
   this.mError = aMsg;
 },
</PRE><PRE> consumeError: function() {
   var e = this.mError;
   this.mError = null;
   return e;
 },
</PRE><PRE> currentToken: function() {
   return this.mToken;
 },
</PRE><PRE> getHexValue: function() {
   this.mToken = this.mScanner.nextHexValue();
   return this.mToken;
 },
</PRE><PRE> getToken: function(aSkipWS, aSkipComment) {
   if (this.mLookAhead) {
     this.mToken = this.mLookAhead;
     this.mLookAhead = null;
     return this.mToken;
   }
</PRE><PRE>   this.mToken = this.mScanner.nextToken();
   while (this.mToken &amp;&amp;
          ((aSkipWS &amp;&amp; this.mToken.isWhiteSpace()) ||
           (aSkipComment &amp;&amp; this.mToken.isComment())))
     this.mToken = this.mScanner.nextToken();
</PRE><P>	return this.mToken;
</P><PRE> },
</PRE><PRE> lookAhead: function(aSkipWS, aSkipComment) {
   var preservedToken = this.mToken;
   this.mScanner.preserveState();
   var token = this.getToken(aSkipWS, aSkipComment);
   this.mScanner.restoreState();
   this.mToken = preservedToken;
</PRE><PRE>   return token;
 },
</PRE><PRE> ungetToken: function() {
   this.mLookAhead = this.mToken;
 },
</PRE><PRE> addUnknownAtRule: function(aSheet, aString) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var blocks = [];
   var token = this.getToken(false, false);
   while (token.isNotNull()) {
     aString += token.value;
     if (token.isSymbol(&quot;;&quot;) &amp;&amp;Â !blocks.length)
       break;
     else if (token.isSymbol(&quot;{&quot;)
              || token.isSymbol(&quot;(&quot;)
              || token.isSymbol(&quot;[&quot;)
              || token.type == &quot;function&quot;) {
       blocks.push(token.isFunction()Â ? &quot;(&quot;Â : token.value);
     } else if (token.isSymbol(&quot;}&quot;)
                || token.isSymbol(&quot;)&quot;)
                || token.isSymbol(&quot;]&quot;)) {
       if (blocks.length) {
         var ontop = blocks[blocks.length - 1];
         if ((token.isSymbol(&quot;}&quot;) &amp;&amp; ontop == &quot;{&quot;)
             || (token.isSymbol(&quot;)&quot;) &amp;&amp; ontop == &quot;(&quot;)
             || (token.isSymbol(&quot;]&quot;) &amp;&amp; ontop == &quot;[&quot;)) {
           blocks.pop();
           if (!blocks.length &amp;&amp; token.isSymbol(&quot;}&quot;))
             break;
         }
       }
     }
     token = this.getToken(false, false);
   }
</PRE><PRE>   this.addUnknownRule(aSheet, aString, currentLine);
 },
</PRE><PRE> addUnknownRule: function(aSheet, aString, aCurrentLine) {
   var errorMsg = this.consumeError();
   var rule = new jscsspErrorRule(errorMsg);
   rule.currentLine = aCurrentLine;
   rule.parsedCssText = aString;
   rule.parentStyleSheet = aSheet;
   aSheet.cssRules.push(rule);
 },
</PRE><PRE> addWhitespace: function(aSheet, aString) {
   var rule = new jscsspWhitespace();
   rule.parsedCssText = aString;
   rule.parentStyleSheet = aSheet;
   aSheet.cssRules.push(rule);
 },
</PRE><PRE> addComment: function(aSheet, aString) {
   var rule = new jscsspComment();
   rule.parsedCssText = aString;
   rule.parentStyleSheet = aSheet;
   aSheet.cssRules.push(rule);
 },
</PRE><PRE> parseCharsetRule: function(aToken, aSheet) {
   var s = aToken.value;
   var token = this.getToken(false, false);
   s += token.value;
   if (token.isWhiteSpace(&quot; &quot;)) {
     token = this.getToken(false, false);
     s += token.value;
     if (token.isString()) {
       var encoding = token.value;
       token = this.getToken(false, false);
       s += token.value;
       if (token.isSymbol(&quot;;&quot;)) {
         var rule = new jscsspCharsetRule();
         rule.encoding = encoding;
         rule.parsedCssText = s;
         rule.parentStyleSheet = aSheet;
         aSheet.cssRules.push(rule);
         return true;
       }
       else
         this.reportError(kCHARSET_RULE_MISSING_SEMICOLON);
     }
     else
       this.reportError(kCHARSET_RULE_CHARSET_IS_STRING);
   }
   else
     this.reportError(kCHARSET_RULE_MISSING_WS);
</PRE><PRE>   this.addUnknownAtRule(aSheet, s);
   return false;
 },
</PRE><PRE> parseImportRule: function(aToken, aSheet) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var s = aToken.value;
   this.preserveState();
   var token = this.getToken(true, true);
   var media = [];
   var href = &quot;&quot;;
   if (token.isString()) {
     href = token.value;
     s += &quot; &quot; + href;
   }
   else if (token.isFunction(&quot;url(&quot;)) {
     token = this.getToken(true, true);
     var urlContent = this.parseURL(token);
     if (urlContent) {
       href = &quot;url(&quot; + urlContent;
       s += &quot; &quot; + href;
     }
   }
   else
     this.reportError(kIMPORT_RULE_MISSING_URL);
</PRE><PRE>   if (href) {
     token = this.getToken(true, true);
     while (token.isIdent()) {
       s += &quot; &quot; + token.value;
       media.push(token.value);
       token = this.getToken(true, true);
       if (!token)
         break;
       if (token.isSymbol(&quot;,&quot;)) {
         s += &quot;,&quot;;
       } else if (token.isSymbol(&quot;;&quot;)) {
         break;
       } else
         break;
       token = this.getToken(true, true);
     }
</PRE><PRE>     if (!media.length) {
       media.push(&quot;all&quot;);
     }
 
     if (token.isSymbol(&quot;;&quot;)) {
       s += &quot;;&quot;
       this.forgetState();
       var rule = new jscsspImportRule();
       rule.currentLine = currentLine;
       rule.parsedCssText = s;
       rule.href = href;
       rule.media = media;
       rule.parentStyleSheet = aSheet;
       aSheet.cssRules.push(rule);
       return true;
     }
   }
</PRE><PRE>   this.restoreState();
   this.addUnknownAtRule(aSheet, &quot;@import&quot;);
   return false;
 },
</PRE><PRE> parseVariablesRule: function(token, aSheet) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var s = token.value;
   var declarations = [];
   var valid = false;
   this.preserveState();
   token = this.getToken(true, true);
   var media = [];
   var foundMedia = false;
   while (token.isNotNull()) {
     if (token.isIdent()) {
       foundMedia = true;
       s += &quot; &quot; + token.value;
       media.push(token.value);
       token = this.getToken(true, true);
       if (token.isSymbol(&quot;,&quot;)) {
         s += &quot;,&quot;;
       } else {
         if (token.isSymbol(&quot;{&quot;))
           this.ungetToken();
         else {
           // error...
           token.type = jscsspToken.NULL_TYPE;
           break;
         }
       }
     } else if (token.isSymbol(&quot;{&quot;))
       break;
     else if (foundMedia) {
       token.type = jscsspToken.NULL_TYPE;
       // not a media list
       break;
     }
     token = this.getToken(true, true);
   }
</PRE><PRE>   if (token.isSymbol(&quot;{&quot;)) {
     s += &quot; {&quot;;
     token = this.getToken(true, true);
     while (true) {
       if (!token.isNotNull()) {
         valid = true;
         break;
       }
       if (token.isSymbol(&quot;}&quot;)) {
         s += &quot;}&quot;;
         valid = true;
         break;
       } else {
         var d = this.parseDeclaration(token, declarations, true, false, aSheet);
         s += ((d &amp;&amp; declarations.length)Â ? &quot; &quot;Â : &quot;&quot;) + d;
       }
       token = this.getToken(true, false);
     }
   }
   if (valid) {
     this.forgetState();
     var rule = new jscsspVariablesRule();
     rule.currentLine = currentLine;
     rule.parsedCssText = s;
     rule.declarations = declarations;
     rule.media = media;
     rule.parentStyleSheet = aSheet;
     aSheet.cssRules.push(rule)
     return true;
   }
   this.restoreState();
   return false;
 },
</PRE><PRE> parseNamespaceRule: function(aToken, aSheet) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var s = aToken.value;
   var valid = false;
   this.preserveState();
   var token = this.getToken(true, true);
   if (token.isNotNull()) {
     var prefix = &quot;&quot;;
     var url = &quot;&quot;;
     if (token.isIdent()) {
       prefix = token.value;
       s += &quot; &quot; + prefix;
       token = this.getToken(true, true);
     }
     if (token) {
       var foundURL = false;
       if (token.isString()) {
         foundURL = true;
         url = token.value;
         s += &quot; &quot; + url;
       } else if (token.isFunction(&quot;url(&quot;)) {
         // get a url here...
         token = this.getToken(true, true);
         var urlContent = this.parseURL(token);
         if (urlContent) {
           url += &quot;url(&quot; + urlContent;
           foundURL = true;
           s += &quot; &quot; + urlContent;
         }
       }
     }
     if (foundURL) {
       token = this.getToken(true, true);
       if (token.isSymbol(&quot;;&quot;)) {
         s += &quot;;&quot;;
         this.forgetState();
         var rule = new jscsspNamespaceRule();
         rule.currentLine = currentLine;
         rule.parsedCssText = s;
         rule.prefix = prefix;
         rule.url = url;
         rule.parentStyleSheet = aSheet;
         aSheet.cssRules.push(rule);
         return true;
       }
     }
</PRE><PRE>   }
   this.restoreState();
   this.addUnknownAtRule(aSheet, &quot;@namespace&quot;);
   return false;
 },
</PRE><PRE> parseFontFaceRule: function(aToken, aSheet) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var s = aToken.value;
   var valid = false;
   var descriptors = [];
   this.preserveState();
   var token = this.getToken(true, true);
   if (token.isNotNull()) {
     // expecting block start
     if (token.isSymbol(&quot;{&quot;)) {
       s += &quot; &quot; + token.value;
       var token = this.getToken(true, false);
       while (true) {
         if (token.isSymbol(&quot;}&quot;)) {
           s += &quot;}&quot;;
           valid = true;
           break;
         } else {
           var d = this.parseDeclaration(token, descriptors, false, false, aSheet);
           s += ((d &amp;&amp; descriptors.length)Â ? &quot; &quot;Â : &quot;&quot;) + d;
         }
         token = this.getToken(true, false);
       }
     }
   }
   if (valid) {
     this.forgetState();
     var rule = new jscsspFontFaceRule();
     rule.currentLine = currentLine;
     rule.parsedCssText = s;
     rule.descriptors = descriptors;
     rule.parentStyleSheet = aSheet;
     aSheet.cssRules.push(rule)
     return true;
   }
   this.restoreState();
   return false;
 },
</PRE><PRE> parsePageRule: function(aToken, aSheet) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var s = aToken.value;
   var valid = false;
   var declarations = [];
   this.preserveState();
   var token = this.getToken(true, true);
   var pageSelector = &quot;&quot;;
   if (token.isSymbol(&quot;:&quot;) || token.isIdent()) {
     if (token.isSymbol(&quot;:&quot;)) {
       pageSelector = &quot;:&quot;;
       token = this.getToken(false, false);
     }
     if (token.isIdent()) {
       pageSelector += token.value;
       s += &quot; &quot; + pageSelector;
       token = this.getToken(true, true);
     }
   }
   if (token.isNotNull()) {
     // expecting block start
     if (token.isSymbol(&quot;{&quot;)) {
       s += &quot; &quot; + token.value;
       var token = this.getToken(true, false);
       while (true) {
         if (token.isSymbol(&quot;}&quot;)) {
           s += &quot;}&quot;;
           valid = true;
           break;
         } else {
           var d = this.parseDeclaration(token, declarations, true, true, aSheet);
           s += ((d &amp;&amp; declarations.length)Â ? &quot; &quot;Â : &quot;&quot;) + d;
         }
         token = this.getToken(true, false);
       }
     }
   }
   if (valid) {
     this.forgetState();
     var rule = new jscsspPageRule();
     rule.currentLine = currentLine;
     rule.parsedCssText = s;
     rule.pageSelector = pageSelector;
     rule.declarations = declarations;
     rule.parentStyleSheet = aSheet;
     aSheet.cssRules.push(rule)
     return true;
   }
   this.restoreState();
   return false;
 },
</PRE><PRE> parseDefaultPropertyValue: function(token, aDecl, aAcceptPriority, descriptor, aSheet) {
   var valueText = &quot;&quot;;
   var blocks = [];
   var foundPriority = false;
   var values = [];
   while (token.isNotNull()) {
</PRE><PRE>     if ((token.isSymbol(&quot;;&quot;)
          || token.isSymbol(&quot;}&quot;)
          || token.isSymbol(&quot;!&quot;))
         &amp;&amp;Â !blocks.length) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
 
     if (token.isIdent(this.kINHERIT)) {
       if (values.length) {
         return &quot;&quot;;
       }
       else {
         valueText = this.kINHERIT;
         var value = new jscsspVariable(kJscsspINHERIT_VALUE, aSheet);
         values.push(value);
         token = this.getToken(true, true);
         break;
       }
     }
     else if (token.isSymbol(&quot;{&quot;)
                || token.isSymbol(&quot;(&quot;)
                || token.isSymbol(&quot;[&quot;)) {
       blocks.push(token.value);
     }
     else if (token.isSymbol(&quot;}&quot;)
                || token.isSymbol(&quot;]&quot;)) {
       if (blocks.length) {
         var ontop = blocks[blocks.length - 1];
         if ((token.isSymbol(&quot;}&quot;) &amp;&amp; ontop == &quot;{&quot;)
             || (token.isSymbol(&quot;)&quot;) &amp;&amp; ontop == &quot;(&quot;)
             || (token.isSymbol(&quot;]&quot;) &amp;&amp; ontop == &quot;[&quot;)) {
           blocks.pop();
         }
       }
     }
     // XXX must find a better way to store individual values
     // probably a |values: []| field holding dimensions, percentages
     // functions, idents, numbers and symbols, in that order.
     if (token.isFunction()) {
       if (token.isFunction(&quot;var(&quot;)) {
         token = this.getToken(true, true);
         if (token.isIdent()) {
           var name = token.value;
           token = this.getToken(true, true);
           if (token.isSymbol(&quot;)&quot;)) {
             var value = new jscsspVariable(kJscsspVARIABLE_VALUE, aSheet);
             valueText += &quot;var(&quot; + name + &quot;)&quot;;
             value.name = name;
             values.push(value);
           }
           else
             return &quot;&quot;;
         }
         else
           return &quot;&quot;;
       }
       else {
         var fn = token.value;
         token = this.getToken(false, true);
         var arg = this.parseFunctionArgument(token);
         if (arg) {
           valueText += fn + arg;
           var value = new jscsspVariable(kJscsspPRIMITIVE_VALUE, aSheet);
           value.value = fn + arg;
           values.push(value);
         }
         else
           return &quot;&quot;;
       }
     }
     else if (token.isSymbol(&quot;#&quot;)) {
       var color = this.parseColor(token);
       if (color) {
         valueText += color;
         var value = new jscsspVariable(kJscsspPRIMITIVE_VALUE, aSheet);
         value.value = color;
         values.push(value);
       }
       else
         return &quot;&quot;;
     }
     else if (!token.isWhiteSpace() &amp;&amp;Â !token.isSymbol(&quot;,&quot;)) {
       var value = new jscsspVariable(kJscsspPRIMITIVE_VALUE, aSheet);
       value.value = token.value;
       values.push(value);
       valueText += token.value;
     }
     else
       valueText += token.value;
     token = this.getToken(false, true);
   }
   if (values.length &amp;&amp; valueText) {
     this.forgetState();
     aDecl.push(this._createJscsspDeclarationFromValuesArray(descriptor, values, valueText));
     return valueText;
   }
   return &quot;&quot;;
 },
</PRE><PRE> parseMarginOrPaddingShorthand: function(token, aDecl, aAcceptPriority, aProperty)
 {
   var top = null;
   var bottom = null;
   var left = null;
   var right = null;
</PRE><PRE>   var values = [];
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!values.length &amp;&amp; token.isIdent(this.kINHERIT)) {
       values.push(token.value);
       token = this.getToken(true, true);
       break;
     }
</PRE><PRE>     else if (token.isDimension()
             || token.isNumber(&quot;0&quot;)
             || token.isPercentage()
             || token.isIdent(&quot;auto&quot;)) {
       values.push(token.value);
     }
     else
       return &quot;&quot;;
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   var count = values.length;
   switch (count) {
     case 1:
       top = values[0];
       bottom = top;
       left = top;
       right = top;
       break;
     case 2:
       top = values[0];
       bottom = top;
       left = values[1];
       right = left;
       break;
     case 3:
       top = values[0];
       left = values[1];
       right = left;
       bottom = values[2];
       break;
     case 4:
       top = values[0];
       right = values[1];
       bottom = values[2];
       left = values[3];
       break;
     default:
       return &quot;&quot;;
   }
   this.forgetState();
   aDecl.push(this._createJscsspDeclarationFromValue(aProperty + &quot;-top&quot;, top));
   aDecl.push(this._createJscsspDeclarationFromValue(aProperty + &quot;-right&quot;, right));
   aDecl.push(this._createJscsspDeclarationFromValue(aProperty + &quot;-bottom&quot;, bottom));
   aDecl.push(this._createJscsspDeclarationFromValue(aProperty + &quot;-left&quot;, left));
  return top + &quot; &quot; + right + &quot; &quot; + bottom + &quot; &quot; + left;
 },
</PRE><PRE> parseBorderColorShorthand: function(token, aDecl, aAcceptPriority)
 {
   var top = null;
   var bottom = null;
   var left = null;
   var right = null;
</PRE><PRE>   var values = [];
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!values.length &amp;&amp; token.isIdent(this.kINHERIT)) {
       values.push(token.value);
       token = this.getToken(true, true);
       break;
     }
     
     else {
       var color = this.parseColor(token);
       if (color)
         values.push(color);
       else
         return &quot;&quot;;
     }
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   var count = values.length;
   switch (count) {
     case 1:
       top = values[0];
       bottom = top;
       left = top;
       right = top;
       break;
     case 2:
       top = values[0];
       bottom = top;
       left = values[1];
       right = left;
       break;
     case 3:
       top = values[0];
       left = values[1];
       right = left;
       bottom = values[2];
       break;
     case 4:
       top = values[0];
       right = values[1];
       bottom = values[2];
       left = values[3];
       break;
     default:
       return &quot;&quot;;
   }
   this.forgetState();
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-top-color&quot;, top));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-right-color&quot;, right));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-bottom-color&quot;, bottom));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-left-color&quot;, left));
   return top + &quot; &quot; + right + &quot; &quot; + bottom + &quot; &quot; + left;
 },
</PRE><PRE> parseCueShorthand: function(token, declarations, aAcceptPriority)
 {
   var before = &quot;&quot;;
   var after = &quot;&quot;;
</PRE><PRE>   var values = [];
   var values = [];
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!values.length &amp;&amp; token.isIdent(this.kINHERIT)) {
       values.push(token.value);
     }
</PRE><PRE>     else if (token.isIdent(&quot;none&quot;))
       values.push(token.value);
</PRE><PRE>       else if (token.isFunction(&quot;url(&quot;)) {
       var token = this.getToken(true, true);
       var urlContent = this.parseURL(token);
       if (urlContent)
         values.push(&quot;url(&quot; + urlContent);
       else
         return &quot;&quot;;
     }
     else
       return &quot;&quot;;
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   var count = values.length;
   switch (count) {
     case 1:
       before = values[0];
       after = before;
       break;
     case 2:
       before = values[0];
       after = values[1];
       break;
     default:
       return &quot;&quot;;
   }
   this.forgetState();
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;cue-before&quot;, before));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;cue-after&quot;, after));
   return before + &quot; &quot; + after;
 },
</PRE><PRE> parsePauseShorthand: function(token, declarations, aAcceptPriority)
 {
   var before = &quot;&quot;;
   var after = &quot;&quot;;
</PRE><PRE>   var values = [];
   var values = [];
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!values.length &amp;&amp; token.isIdent(this.kINHERIT)) {
       values.push(token.value);
     }
</PRE><PRE>     else if (token.isDimensionOfUnit(&quot;ms&quot;)
              || token.isDimensionOfUnit(&quot;s&quot;)
              || token.isPercentage()
              || token.isNumber(&quot;0&quot;))
       values.push(token.value);
     else
       return &quot;&quot;;
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   var count = values.length;
   switch (count) {
     case 1:
       before = values[0];
       after = before;
       break;
     case 2:
       before = values[0];
       after = values[1];
       break;
     default:
       return &quot;&quot;;
   }
   this.forgetState();
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;pause-before&quot;, before));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;pause-after&quot;, after));
   return before + &quot; &quot; + after;
 },
</PRE><PRE> parseBorderWidthShorthand: function(token, aDecl, aAcceptPriority)
 {
   var top = null;
   var bottom = null;
   var left = null;
   var right = null;</PRE><PRE>   var values = [];
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!values.length &amp;&amp; token.isIdent(this.kINHERIT)) {
       values.push(token.value);
     }
     
     else if (token.isDimension()
              || token.isNumber(&quot;0&quot;)
              || (token.isIdent() &amp;&amp; token.value in this.kBORDER_WIDTH_NAMES)) {
       values.push(token.value);
     }
     else
       return &quot;&quot;;
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   var count = values.length;
   switch (count) {
     case 1:
       top = values[0];
       bottom = top;
       left = top;
       right = top;
       break;
     case 2:
       top = values[0];
       bottom = top;
       left = values[1];
       right = left;
       break;
     case 3:
       top = values[0];
       left = values[1];
       right = left;
       bottom = values[2];
       break;
     case 4:
       top = values[0];
       right = values[1];
       bottom = values[2];
       left = values[3];
       break;
     default:
       return &quot;&quot;;
   }
   this.forgetState();
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-top-width&quot;, top));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-right-width&quot;, right));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-bottom-width&quot;, bottom));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-left-width&quot;, left));
   return top + &quot; &quot; + right + &quot; &quot; + bottom + &quot; &quot; + left;
 },
</PRE><PRE> parseBorderStyleShorthand: function(token, aDecl, aAcceptPriority)
 {
   var top = null;
   var bottom = null;
   var left = null;
   var right = null;
</PRE><PRE>   var values = [];
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!values.length &amp;&amp; token.isIdent(this.kINHERIT)) {
       values.push(token.value);
     }
     
     else if (token.isIdent() &amp;&amp; token.value in this.kBORDER_STYLE_NAMES) {
       values.push(token.value);
     }
     else
       return &quot;&quot;;
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   var count = values.length;
   switch (count) {
     case 1:
       top = values[0];
       bottom = top;
       left = top;
       right = top;
       break;
     case 2:
       top = values[0];
       bottom = top;
       left = values[1];
       right = left;
       break;
     case 3:
       top = values[0];
       left = values[1];
       right = left;
       bottom = values[2];
       break;
     case 4:
       top = values[0];
       right = values[1];
       bottom = values[2];
       left = values[3];
       break;
     default:
       return &quot;&quot;;
   }
   this.forgetState();
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-top-style&quot;, top));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-right-style&quot;, right));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-bottom-style&quot;, bottom));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;border-left-style&quot;, left));
   return top + &quot; &quot; + right + &quot; &quot; + bottom + &quot; &quot; + left;
 },
</PRE><PRE> parseBorderEdgeOrOutlineShorthand: function(token, aDecl, aAcceptPriority, aProperty)
 {
   var bWidth = null;
   var bStyle = null;
   var bColor = null;
</PRE><PRE>   while (true) {
     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!bWidth &amp;&amp;Â !bStyle &amp;&amp;Â !bColor
              &amp;&amp; token.isIdent(this.kINHERIT)) {
       bWidth = this.kINHERIT;
       bStyle = this.kINHERIT;
       bColor = this.kINHERIT;
     }
</PRE><PRE>     else if (!bWidth &amp;&amp;
              (token.isDimension()
               || (token.isIdent() &amp;&amp; token.value in this.kBORDER_WIDTH_NAMES)
               || token.isNumber(&quot;0&quot;))) {
       bWidth = token.value;
     }
</PRE><PRE>     else if (!bStyle &amp;&amp;
              (token.isIdent() &amp;&amp; token.value in this.kBORDER_STYLE_NAMES)) {
       bStyle = token.value;
     }
</PRE><PRE>     else {
       var color = (aProperty == &quot;outline&quot; &amp;&amp; token.isIdent(&quot;invert&quot;))
                  Â ? &quot;invert&quot;Â : this.parseColor(token);
       if (!bColor &amp;&amp; color)
         bColor = color;
       else
         return &quot;&quot;;
     }
     token = this.getToken(true, true);
   }
</PRE><PRE>   // create the declarations
   this.forgetState();
   bWidth = bWidthÂ ? bWidthÂ : &quot;medium&quot;;
   bStyle = bStyleÂ ? bStyleÂ : &quot;none&quot;;
   bColor = bColorÂ ? bColorÂ : &quot;-moz-initial&quot;;
</PRE><PRE>   function addPropertyToDecl(aSelf, aDecl, property, w, s, c) {
     aDecl.push(aSelf._createJscsspDeclarationFromValue(property + &quot;-width&quot;, w));
     aDecl.push(aSelf._createJscsspDeclarationFromValue(property + &quot;-style&quot;, s));
     aDecl.push(aSelf._createJscsspDeclarationFromValue(property + &quot;-color&quot;, c));
   }
</PRE><PRE>   if (aProperty == &quot;border&quot;) {
     addPropertyToDecl(this, aDecl, &quot;border-top&quot;, bWidth, bStyle, bColor);
     addPropertyToDecl(this, aDecl, &quot;border-right&quot;, bWidth, bStyle, bColor);
     addPropertyToDecl(this, aDecl, &quot;border-bottom&quot;, bWidth, bStyle, bColor);
     addPropertyToDecl(this, aDecl, &quot;border-left&quot;, bWidth, bStyle, bColor);
   }
   else
     addPropertyToDecl(this, aDecl, aProperty, bWidth, bStyle, bColor);
   return bWidth + &quot; &quot; + bStyle + &quot; &quot; + bColor;
 },
</PRE><PRE> parseBackgroundShorthand: function(token, aDecl, aAcceptPriority)
 {
   var kHPos = {&quot;left&quot;: true, &quot;right&quot;: true };
</PRE><PRE>   var kVPos = {&quot;top&quot;: true, &quot;bottom&quot;: true };
   var kPos = {&quot;left&quot;: true, &quot;right&quot;: true, &quot;top&quot;: true, &quot;bottom&quot;: true, &quot;center&quot;: true};
</PRE><PRE>   var bgColor = null;
   var bgRepeat = null;
   var bgAttachment = null;
   var bgImage = null;
   var bgPosition = null;
</PRE><PRE>   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!bgColor &amp;&amp;Â !bgRepeat &amp;&amp;Â !bgAttachment &amp;&amp;Â !bgImage &amp;&amp;Â !bgPosition
              &amp;&amp; token.isIdent(this.kINHERIT)) {
       bgColor = this.kINHERIT;
       bgRepeat = this.kINHERIT;
       bgAttachment = this.kINHERIT;
       bgImage = this.kINHERIT;
       bgPosition = this.kINHERIT;
     }
</PRE><PRE>     else {
       if (!bgAttachment &amp;&amp;
           (token.isIdent(&quot;scroll&quot;)
            || token.isIdent(&quot;fixed&quot;))) {
         bgAttachment = token.value;
       }
</PRE><PRE>       else if (!bgPosition &amp;&amp;
                ((token.isIdent() &amp;&amp; token.value in kPos)
                 || token.isDimension()
                 || token.isNumber(&quot;0&quot;)
                 || token.isPercentage())) {
         bgPosition = token.value;
         token = this.getToken(true, true);
         if (token.isDimension() || token.isNumber(&quot;0&quot;) || token.isPercentage()) {
           bgPosition += &quot; &quot; + token.value;
         }
         else if (token.isIdent() &amp;&amp; token.value in kPos) {
           if ((bgPosition in kHPos &amp;&amp; token.value in kHPos) ||
               (bgPosition in kVPos &amp;&amp; token.value in kVPos))
             return &quot;&quot;;
           bgPosition += &quot; &quot; + token.value;
         }
         else {
           this.ungetToken();
           bgPosition += &quot; center&quot;;
         }
       }
</PRE><PRE>       else if (!bgRepeat &amp;&amp;
                (token.isIdent(&quot;repeat&quot;)
                 || token.isIdent(&quot;repeat-x&quot;)
                 || token.isIdent(&quot;repeat-y&quot;)
                 || token.isIdent(&quot;no-repeat&quot;))) {
         bgRepeat = token.value;
       }
</PRE><PRE>       else if (!bgImage &amp;&amp;
                (token.isFunction(&quot;url(&quot;)
                 || token.isIdent(&quot;none&quot;))) {
         bgImage = token.value;
         if (token.isFunction(&quot;url(&quot;)) {
           token = this.getToken(true, true);
           var url = this.parseURL(token); // TODO
           if (url)
             bgImage += url;
           else
             return &quot;&quot;;
         }
       }
</PRE><PRE>       else if (!bgImage &amp;&amp;
                (token.isFunction(&quot;-moz-linear-gradient(&quot;)
                 || token.isFunction(&quot;-moz-radial-gradient(&quot;)
                 || token.isFunction(&quot;-moz-repeating-linear-gradient(&quot;)
                 || token.isFunction(&quot;-moz-repeating-radial-gradient(&quot;))) {
         var gradient = CssInspector.parseGradient(this, token);
         if (gradient)
           bgImage = CssInspector.serializeGradient(gradient);
         else
           return &quot;&quot;;
       }
</PRE><PRE>       else {
         var color = this.parseColor(token);
         if (!bgColor &amp;&amp; color)
           bgColor = color;
         else
           return &quot;&quot;;
       }
</PRE><PRE>     }
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   // create the declarations
   this.forgetState();
   bgColor = bgColorÂ ? bgColorÂ : &quot;transparent&quot;;
   bgImage = bgImageÂ ? bgImageÂ : &quot;none&quot;;
   bgRepeat = bgRepeatÂ ? bgRepeatÂ : &quot;repeat&quot;;
   bgAttachment = bgAttachmentÂ ? bgAttachmentÂ : &quot;scroll&quot;;
   bgPosition = bgPositionÂ ? bgPositionÂ : &quot;top left&quot;;
</PRE><PRE>   aDecl.push(this._createJscsspDeclarationFromValue(&quot;background-color&quot;, bgColor));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;background-image&quot;, bgImage));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;background-repeat&quot;, bgRepeat));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;background-attachment&quot;, bgAttachment));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;background-position&quot;, bgPosition));
   return bgColor + &quot; &quot; + bgImage + &quot; &quot; + bgRepeat + &quot; &quot; + bgAttachment + &quot; &quot; + bgPosition;
 },
</PRE><PRE> parseListStyleShorthand: function(token, aDecl, aAcceptPriority)
 {
   var kPosition = { &quot;inside&quot;: true, &quot;outside&quot;: true };
</PRE><PRE>   var lType = null;
   var lPosition = null;
   var lImage = null;
</PRE><PRE>   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!lType &amp;&amp;Â !lPosition &amp;&amp;Â ! lImage
              &amp;&amp; token.isIdent(this.kINHERIT)) {
       lType = this.kINHERIT;
       lPosition = this.kINHERIT;
       lImage = this.kINHERIT;
     }
</PRE><PRE>     else if (!lType &amp;&amp;
              (token.isIdent() &amp;&amp; token.value in this.kLIST_STYLE_TYPE_NAMES)) {
       lType = token.value;
     }
</PRE><PRE>     else if (!lPosition &amp;&amp;
              (token.isIdent() &amp;&amp; token.value in kPosition)) {
       lPosition = token.value;
     }
</PRE><PRE>     else if (!lImage &amp;&amp; token.isFunction(&quot;url&quot;)) {
       token = this.getToken(true, true);
       var urlContent = this.parseURL(token);
       if (urlContent) {
         lImage = &quot;url(&quot; + urlContent;
       }
       else
         return &quot;&quot;;
     }
     else if (!token.isIdent(&quot;none&quot;))
       return &quot;&quot;;
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   // create the declarations
   this.forgetState();
   lType = lTypeÂ ? lTypeÂ : &quot;none&quot;;
   lImage = lImageÂ ? lImageÂ : &quot;none&quot;;
   lPosition = lPositionÂ ? lPositionÂ : &quot;outside&quot;;
</PRE><PRE>   aDecl.push(this._createJscsspDeclarationFromValue(&quot;list-style-type&quot;, lType));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;list-style-position&quot;, lPosition));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;list-style-image&quot;, lImage));
   return lType + &quot; &quot; + lPosition + &quot; &quot; + lImage;
 },
</PRE><PRE> parseFontShorthand: function(token, aDecl, aAcceptPriority)
 {
   var kStyle = {&quot;italic&quot;: true, &quot;oblique&quot;: true };
   var kVariant = {&quot;small-caps&quot;: true };
   var kWeight = { &quot;bold&quot;: true, &quot;bolder&quot;: true, &quot;lighter&quot;: true,
                     &quot;100&quot;: true, &quot;200&quot;: true, &quot;300&quot;: true, &quot;400&quot;: true,
                     &quot;500&quot;: true, &quot;600&quot;: true, &quot;700&quot;: true, &quot;800&quot;: true,
                     &quot;900&quot;: true };
   var kSize = { &quot;xx-small&quot;: true, &quot;x-small&quot;: true, &quot;small&quot;: true, &quot;medium&quot;: true,
                   &quot;large&quot;: true, &quot;x-large&quot;: true, &quot;xx-large&quot;: true,
                   &quot;larger&quot;: true, &quot;smaller&quot;: true };
   var kValues = { &quot;caption&quot;: true, &quot;icon&quot;: true, &quot;menu&quot;: true, &quot;message-box&quot;: true, &quot;small-caption&quot;: true, &quot;status-bar&quot;: true };
   var kFamily = { &quot;serif&quot;: true, &quot;sans-serif&quot;: true, &quot;cursive&quot;: true, &quot;fantasy&quot;: true, &quot;monospace&quot;: true };
</PRE><PRE>   var fStyle = null;
   var fVariant = null;
   var fWeight = null;
   var fSize = null;
   var fLineHeight = null;
   var fFamily = &quot;&quot;;
   var fSystem = null;
   var fFamilyValues = [];
</PRE><PRE>   var normalCount = 0;
   while (true) {
</PRE><PRE>     if (!token.isNotNull())
       break;
</PRE><PRE>     if (token.isSymbol(&quot;;&quot;)
         || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
         || token.isSymbol(&quot;}&quot;)) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     }
</PRE><PRE>     else if (!fStyle &amp;&amp;Â !fVariant &amp;&amp;Â !fWeight
              &amp;&amp;Â !fSize &amp;&amp;Â !fLineHeight &amp;&amp;Â !fFamily
              &amp;&amp;Â !fSystem
              &amp;&amp; token.isIdent(this.kINHERIT)) {
       fStyle = this.kINHERIT;
       fVariant = this.kINHERIT;
       fWeight = this.kINHERIT;
       fSize = this.kINHERIT;
       fLineHeight = this.kINHERIT;
       fFamily = this.kINHERIT;
       fSystem = this.kINHERIT;
     }
</PRE><PRE>     else {
       if (!fSystem &amp;&amp; (token.isIdent() &amp;&amp; token.value in kValues)) {
         fSystem = token.value;
         break;
       }
</PRE><PRE>       else {
         if (!fStyle
                  &amp;&amp; token.isIdent()
                  &amp;&amp; (token.value in kStyle)) {
           fStyle = token.value;
         }
 
         else if (!fVariant
                  &amp;&amp; token.isIdent()
                  &amp;&amp; (token.value in kVariant)) {
           fVariant = token.value;
         }
 
         else if (!fWeight
                  &amp;&amp; (token.isIdent() || token.isNumber())
                  &amp;&amp; (token.value in kWeight)) {
           fWeight = token.value;
         }
 
         else if (!fSize
                  &amp;&amp; ((token.isIdent() &amp;&amp; (token.value in kSize))
                      || token.isDimension()
                      || token.isPercentage())) {
           fSize = token.value;
           var token = this.getToken(false, false);
           if (token.isSymbol(&quot;/&quot;)) {
             token = this.getToken(false, false);
             if (!fLineHeight &amp;&amp;
                 (token.isDimension() || token.isNumber() || token.isPercentage())) {
               fLineHeight = token.value;
             }
             else
               return &quot;&quot;;
           }
           else
             this.ungetToken();
         }
</PRE><PRE>         else if (token.isIdent(&quot;normal&quot;)) {
           normalCount++;
           if (normalCount &gt; 3)
             return &quot;&quot;;
         }
</PRE><PRE>         else if (!fFamily &amp;&amp; // *MUST* be last to be tested here
                  (token.isString()
                   || token.isIdent())) {
           var lastWasComma = false;
           while (true) {
             if (!token.isNotNull())
               break;
             else if (token.isSymbol(&quot;;&quot;)
                 || (aAcceptPriority &amp;&amp; token.isSymbol(&quot;!&quot;))
                 || token.isSymbol(&quot;}&quot;)) {
               this.ungetToken();
               break;
             }
             else if (token.isIdent() &amp;&amp; token.value in kFamily) {
               var value = new jscsspVariable(kJscsspPRIMITIVE_VALUE, null);
               value.value = token.value;
               fFamilyValues.push(value);
               fFamily += token.value;
               break;
             }
             else if (token.isString() || token.isIdent()) {
               var value = new jscsspVariable(kJscsspPRIMITIVE_VALUE, null);
               value.value = token.value;
               fFamilyValues.push(value);
               fFamily += token.value;
               lastWasComma = false;
             }
             else if (!lastWasComma &amp;&amp; token.isSymbol(&quot;,&quot;)) {
               fFamily += &quot;, &quot;;
               lastWasComma = true;
             }
             else
               return &quot;&quot;;
             token = this.getToken(true, true);
           }
         }
</PRE><PRE>         else {
           return &quot;&quot;;
         }
       }
</PRE><PRE>     }
</PRE><PRE>     token = this.getToken(true, true);
   }
</PRE><PRE>   // create the declarations
   this.forgetState();
   if (fSystem) {
     aDecl.push(this._createJscsspDeclarationFromValue(&quot;font&quot;, fSystem));
     return fSystem;
   }
   fStyle = fStyleÂ ? fStyleÂ : &quot;normal&quot;;
   fVariant = fVariantÂ ? fVariantÂ : &quot;normal&quot;;
   fWeight = fWeightÂ ? fWeightÂ : &quot;normal&quot;;
   fSize = fSizeÂ ? fSizeÂ : &quot;medium&quot;;
   fLineHeight = fLineHeightÂ ? fLineHeightÂ : &quot;normal&quot;;
   fFamily = fFamilyÂ ? fFamilyÂ : &quot;-moz-initial&quot;;
</PRE><PRE>   aDecl.push(this._createJscsspDeclarationFromValue(&quot;font-style&quot;, fStyle));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;font-variant&quot;, fVariant));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;font-weight&quot;, fWeight));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;font-size&quot;, fSize));
   aDecl.push(this._createJscsspDeclarationFromValue(&quot;line-height&quot;, fLineHeight));
   aDecl.push(this._createJscsspDeclarationFromValuesArray(&quot;font-family&quot;, fFamilyValues, fFamily));
   return fStyle + &quot; &quot; + fVariant + &quot; &quot; + fWeight + &quot; &quot; + fSize + &quot;/&quot; + fLineHeight + &quot; &quot; + fFamily;
 },
</PRE><PRE> _createJscsspDeclaration: function(property, value)
 {
   var decl = new jscsspDeclaration();
   decl.property = property;
   decl.value = this.trim11(value);
   decl.parsedCssText = property + &quot;: &quot; + value + &quot;;&quot;;
   return decl;
 },
</PRE><PRE> _createJscsspDeclarationFromValue: function(property, valueText)
 {
   var decl = new jscsspDeclaration();
   decl.property = property;
   var value = new jscsspVariable(kJscsspPRIMITIVE_VALUE, null);
   value.value = valueText;
   decl.values = [value];
   decl.valueText = valueText;
   decl.parsedCssText = property + &quot;: &quot; + valueText + &quot;;&quot;;
   return decl;
 },
</PRE><PRE> _createJscsspDeclarationFromValuesArray: function(property, values, valueText)
 {
   var decl = new jscsspDeclaration();
   decl.property = property;
   decl.values = values;
   decl.valueText = valueText;
   decl.parsedCssText = property + &quot;: &quot; + valueText + &quot;;&quot;;
   return decl;
 },
</PRE><PRE> parseURL: function(token)
 {
   var value = &quot;&quot;;
   if (token.isString())
   {
     value += token.value;
     token = this.getToken(true, true);
   }
   else
     while (true)
     {
       if (!token.isNotNull()) {
         this.reportError(kURL_EOF);
         return &quot;&quot;;
       }
       if (token.isWhiteSpace()) {
         nextToken = this.lookAhead(true, true);
         // if next token is not a closing parenthesis, that's an error
         if (!nextToken.isSymbol(&quot;)&quot;)) {
           this.reportError(kURL_WS_INSIDE);
           token = this.currentToken();
           break;
         }
       }
       if (token.isSymbol(&quot;)&quot;)) {
         break;
       }
       value += token.value;
       token = this.getToken(false, false);
     }
</PRE><PRE>   if (token.isSymbol(&quot;)&quot;)) {
     return value + &quot;)&quot;;
   }
   return &quot;&quot;;
 },
</PRE><PRE> parseFunctionArgument: function(token)
 {
   var value = &quot;&quot;;
   if (token.isString())
   {
     value += token.value;
     token = this.getToken(true, true);
   }
   else {
     var parenthesis = 1;
     while (true)
     {
       if (!token.isNotNull())
         return &quot;&quot;;
       if (token.isFunction() || token.isSymbol(&quot;(&quot;))
         parenthesis++;
       if (token.isSymbol(&quot;)&quot;)) {
         parenthesis--;
         if (!parenthesis)
           break;
       }
       value += token.value;
       token = this.getToken(false, false);
     }
   }
</PRE><PRE>   if (token.isSymbol(&quot;)&quot;))
     return value + &quot;)&quot;;
   return &quot;&quot;;
 },
</PRE><PRE> parseColor: function(token)
 {
   var color = &quot;&quot;;
   if (token.isFunction(&quot;rgb(&quot;)
       || token.isFunction(&quot;rgba(&quot;)) {
     color = token.value;
     var isRgba = token.isFunction(&quot;rgba(&quot;)
     token = this.getToken(true, true);
     if (!token.isNumber() &amp;&amp;Â !token.isPercentage())
       return &quot;&quot;;
     color += token.value;
     token = this.getToken(true, true);
     if (!token.isSymbol(&quot;,&quot;))
       return &quot;&quot;;
     color += &quot;, &quot;;
 
     token = this.getToken(true, true);
     if (!token.isNumber() &amp;&amp;Â !token.isPercentage())
       return &quot;&quot;;
     color += token.value;
     token = this.getToken(true, true);
     if (!token.isSymbol(&quot;,&quot;))
       return &quot;&quot;;
     color += &quot;, &quot;;
 
     token = this.getToken(true, true);
     if (!token.isNumber() &amp;&amp;Â !token.isPercentage())
       return &quot;&quot;;
     color += token.value;
 
     if (isRgba) {
       token = this.getToken(true, true);
       if (!token.isSymbol(&quot;,&quot;))
         return &quot;&quot;;
       color += &quot;, &quot;;
 
       token = this.getToken(true, true);
       if (!token.isNumber())
         return &quot;&quot;;
       color += token.value;
     }
 
     token = this.getToken(true, true);
     if (!token.isSymbol(&quot;)&quot;))
       return &quot;&quot;;
     color += token.value;
   }
 
   else if (token.isFunction(&quot;hsl(&quot;)
            || token.isFunction(&quot;hsla(&quot;)) {
     color = token.value;
     var isHsla = token.isFunction(&quot;hsla(&quot;)
     token = this.getToken(true, true);
     if (!token.isNumber())
       return &quot;&quot;;
     color += token.value;
     token = this.getToken(true, true);
     if (!token.isSymbol(&quot;,&quot;))
       return &quot;&quot;;
     color += &quot;, &quot;;
 
     token = this.getToken(true, true);
     if (!token.isPercentage())
       return &quot;&quot;;
     color += token.value;
     token = this.getToken(true, true);
     if (!token.isSymbol(&quot;,&quot;))
       return &quot;&quot;;
     color += &quot;, &quot;;
 
     token = this.getToken(true, true);
     if (!token.isPercentage())
       return &quot;&quot;;
     color += token.value;
 
     if (isHsla) {
       token = this.getToken(true, true);
       if (!token.isSymbol(&quot;,&quot;))
         return &quot;&quot;;
       color += &quot;, &quot;;
 
       token = this.getToken(true, true);
       if (!token.isNumber())
         return &quot;&quot;;
       color += token.value;
     }
 
     token = this.getToken(true, true);
     if (!token.isSymbol(&quot;)&quot;))
       return &quot;&quot;;
     color += token.value;
   }
</PRE><PRE>   else if (token.isIdent()
            &amp;&amp; (token.value in this.kCOLOR_NAMES))
     color = token.value;
</PRE><PRE>   else if (token.isSymbol(&quot;#&quot;)) {
     token = this.getHexValue();
     if (!token.isHex())
       return &quot;&quot;;
     var length = token.value.length;
     if (lengthÂ != 3 &amp;&amp; lengthÂ != 6)
       return &quot;&quot;;
     if (token.value.match( /[a-fA-F0-9]/g ).lengthÂ != length)
       return &quot;&quot;;
     color = &quot;#&quot; + token.value;
   }
   return color;
 },
</PRE><PRE> parseDeclaration: function(aToken, aDecl, aAcceptPriority, aExpandShorthands, aSheet) {
   this.preserveState();
   var blocks = [];
   if (aToken.isIdent()) {
     var descriptor = aToken.value.toLowerCase();
     var token = this.getToken(true, true);
     if (token.isSymbol(&quot;:&quot;)) {
       var token = this.getToken(true, true);
</PRE><PRE>       var value = &quot;&quot;;
       var declarations = [];
       if (aExpandShorthands)
         switch (descriptor) {
           case &quot;background&quot;:
             value = this.parseBackgroundShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;margin&quot;:
           case &quot;padding&quot;:
             value = this.parseMarginOrPaddingShorthand(token, declarations, aAcceptPriority, descriptor);
             break;
           case &quot;border-color&quot;:
             value = this.parseBorderColorShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;border-style&quot;:
             value = this.parseBorderStyleShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;border-width&quot;:
             value = this.parseBorderWidthShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;border-top&quot;:
           case &quot;border-right&quot;:
           case &quot;border-bottom&quot;:
           case &quot;border-left&quot;:
           case &quot;border&quot;:
           case &quot;outline&quot;:
             value = this.parseBorderEdgeOrOutlineShorthand(token, declarations, aAcceptPriority, descriptor);
             break;
           case &quot;cue&quot;:
             value = this.parseCueShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;pause&quot;:
             value = this.parsePauseShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;font&quot;:
             value = this.parseFontShorthand(token, declarations, aAcceptPriority);
             break;
           case &quot;list-style&quot;:
             value = this.parseListStyleShorthand(token, declarations, aAcceptPriority);
             break;
           default:
             value = this.parseDefaultPropertyValue(token, declarations, aAcceptPriority, descriptor, aSheet);
             break;
         }
       else
         value = this.parseDefaultPropertyValue(token, declarations, aAcceptPriority, descriptor, aSheet);
       token = this.currentToken();
       if (value) // no error above
       {
         var priority = false;
         if (token.isSymbol(&quot;!&quot;)) {
           token = this.getToken(true, true);
           if (token.isIdent(&quot;important&quot;)) {
             priority = true;
             token = this.getToken(true, true);
             if (token.isSymbol(&quot;;&quot;) || token.isSymbol(&quot;}&quot;)) {
               if (token.isSymbol(&quot;}&quot;))
                 this.ungetToken();
             }
             else return &quot;&quot;;
           }
           else return &quot;&quot;;
         }
         else if  (token.isNotNull() &amp;&amp;Â !token.isSymbol(&quot;;&quot;) &amp;&amp;Â !token.isSymbol(&quot;}&quot;))
           return &quot;&quot;;
         for (var i = 0; i &lt; declarations.length; i++) {
           declarations[i].priority = priority;
           aDecl.push(declarations[i]);
         }
         return descriptor + &quot;: &quot; + value + &quot;;&quot;;
       }
     }
   }
   else if (aToken.isComment()) {
     if (this.mPreserveComments) {
       this.forgetState();
       var comment = new jscsspComment();
       comment.parsedCssText = aToken.value;
       aDecl.push(comment);
     }
     return aToken.value;
   }
</PRE><PRE>   // we have an error here, let's skip it
   this.restoreState();
   var s = aToken.value;
   blocks = [];
   var token = this.getToken(false, false);
   while (token.isNotNull()) {
     s += token.value;
     if ((token.isSymbol(&quot;;&quot;) || token.isSymbol(&quot;}&quot;)) &amp;&amp;Â !blocks.length) {
       if (token.isSymbol(&quot;}&quot;))
         this.ungetToken();
       break;
     } else if (token.isSymbol(&quot;{&quot;)
                || token.isSymbol(&quot;(&quot;)
                || token.isSymbol(&quot;[&quot;)
                || token.isFunction()) {
       blocks.push(token.isFunction()Â ? &quot;(&quot;Â : token.value);
     } else if (token.isSymbol(&quot;}&quot;)
                || token.isSymbol(&quot;)&quot;)
                || token.isSymbol(&quot;]&quot;)) {
       if (blocks.length) {
         var ontop = blocks[blocks.length - 1];
         if ((token.isSymbol(&quot;}&quot;) &amp;&amp; ontop == &quot;{&quot;)
             || (token.isSymbol(&quot;)&quot;) &amp;&amp; ontop == &quot;(&quot;)
             || (token.isSymbol(&quot;]&quot;) &amp;&amp; ontop == &quot;[&quot;)) {
           blocks.pop();
         }
       }
     }
     token = this.getToken(false, false);
   }
   return &quot;&quot;;
 },
</PRE><PRE> parseKeyframesRule: function(aToken, aSheet) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   var s = aToken.value;
   var valid = false;
   var keyframesRule = new jscsspKeyframesRule();
   keyframesRule.currentLine = currentLine;
   this.preserveState();
   var token = this.getToken(true, true);
   var foundName = false;
   while (token.isNotNull()) {
     if (token.isIdent()) {
       // should be the keyframes' name
       foundName = true;
       s += &quot; &quot; + token.value;
       keyframesRule.name = token.value;
       token = this.getToken(true, true);
       if (token.isSymbol(&quot;{&quot;))
         this.ungetToken();
       else {
         // error...
         token.type = jscsspToken.NULL_TYPE;
         break;
       }
     }
     else if (token.isSymbol(&quot;{&quot;)) {
       if (!foundName) {
         token.type = jscsspToken.NULL_TYPE;
         // not a valid keyframes at-rule
       }
       break;
     }
     else {
       token.type = jscsspToken.NULL_TYPE;
       // not a valid keyframes at-rule
       break;
     }
     token = this.getToken(true, true);
   }
</PRE><PRE>   if (token.isSymbol(&quot;{&quot;) &amp;&amp; keyframesRule.name) {
     // ok let's parse keyframe rules now...
     s += &quot; { &quot;;
     token = this.getToken(true, false);
     while (token.isNotNull()) {
       if (token.isComment() &amp;&amp; this.mPreserveComments) {
         s += &quot; &quot; + token.value;
         var comment = new jscsspComment();
         comment.parsedCssText = token.value;
         keyframesRule.cssRules.push(comment);
       } else if (token.isSymbol(&quot;}&quot;)) {
         valid = true;
         break;
       } else {
         var r = this.parseKeyframeRule(token, keyframesRule, true);
         if (r)
           s += r;
       }
       token = this.getToken(true, false);
     }
   }
   if (valid) {
     this.forgetState();
     keyframesRule.currentLine = currentLine;
     keyframesRule.parsedCssText = s;
     aSheet.cssRules.push(keyframesRule);
     return true;
   }
   this.restoreState();
   return false;
 },
</PRE><PRE> parseKeyframeRule: function(aToken, aOwner) {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   this.preserveState();
   var token = aToken;
</PRE><PRE>   // find the keyframe keys
   var key = &quot;&quot;;
   while (token.isNotNull()) {
     if (token.isIdent() || token.isPercentage()) {
       if (token.isIdent()
           &amp;&amp;Â !token.isIdent(&quot;from&quot;)
           &amp;&amp;Â !token.isIdent(&quot;to&quot;)) {
         key = &quot;&quot;;
         break;
       }
       key += token.value;
       token = this.getToken(true, true);
       if (token.isSymbol(&quot;{&quot;)) {
         this.ungetToken();
         break;
       }
       else 
         if (token.isSymbol(&quot;,&quot;)) {
           key += &quot;, &quot;;
         }
         else {
           key = &quot;&quot;;
           break;
         }
     }
     else {
       key = &quot;&quot;;
       break;
     }
     token = this.getToken(true, true);
   }
</PRE><PRE>   var valid = false;
   var declarations = [];
   if (key) {
     var s = key;
     token = this.getToken(true, true);
     if (token.isSymbol(&quot;{&quot;)) {
       s += &quot; { &quot;;
       token = this.getToken(true, false);
       while (true) {
         if (!token.isNotNull()) {
           valid = true;
           break;
         }
         if (token.isSymbol(&quot;}&quot;)) {
           s += &quot;}&quot;;
           valid = true;
           break;
         } else {
           var d = this.parseDeclaration(token, declarations, true, true, aOwner);
           s += ((d &amp;&amp; declarations.length)Â ? &quot; &quot;Â : &quot;&quot;) + d;
         }
         token = this.getToken(true, false);
       }
     }
   }
   else {
     // key is invalid so the whole rule is invalid with it
   }
</PRE><PRE>   if (valid) {
     var rule = new jscsspKeyframeRule();
     rule.currentLine = currentLine;
     rule.parsedCssText = s;
     rule.declarations = declarations;
     rule.keyText = key;
     rule.parentRule = aOwner;
     aOwner.cssRules.push(rule);
     return s;
   }
   this.restoreState();
   s = this.currentToken().value;
   this.addUnknownAtRule(aOwner, s);
   return &quot;&quot;;
 },
</PRE><PRE> parseMediaRule: function(aToken, aSheet) {
</PRE><P>	this.mScanner.mMediaQueryMode = true;
	var currentLine = CountLF(this.mScanner.getAlreadyScanned());
</P><PRE>   var s = aToken.value;
   var valid = false;
   var mediaRule = new jscsspMediaRule();
   mediaRule.currentLine = currentLine;
   this.preserveState();
   var token = this.getToken(true, true);
   var foundMedia = false;
   while (token.isNotNull()) {
     if (token.isIdent()) {
       foundMedia = true;
       s += &quot; &quot; + token.value;
 		mediaRule.media.push(token.value);
       token = this.getToken(true, true);
       if (token.isSymbol(&quot;,&quot;)) {
         s += &quot;,&quot;;
       } else {
         if (token.isSymbol(&quot;{&quot;))
           this.ungetToken();
         else {
           // error...
           token.type = jscsspToken.NULL_TYPE;
           break;
         }
       }
     }
     else if (token.isSymbol(&quot;{&quot;))
       break;
     else if (foundMedia) {
       token.type = jscsspToken.NULL_TYPE;
       // not a media list
       break;
     }
     token = this.getToken(true, true);
   }
   if (token.isSymbol(&quot;{&quot;) &amp;&amp; mediaRule.media.length) {
     // ok let's parse style rules now...
     s += &quot; { &quot;;
     token = this.getToken(true, false);
     while (token.isNotNull()) {
       if (token.isComment() &amp;&amp; this.mPreserveComments) {
         s += &quot; &quot; + token.value;
         var comment = new jscsspComment();
         comment.parsedCssText = token.value;
         mediaRule.cssRules.push(comment);
       } else if (token.isSymbol(&quot;}&quot;)) {
         valid = true;
         break;
       } else {
         var r = this.parseStyleRule(token, mediaRule, true);
         if (r)
           s += r;
       }
       token = this.getToken(true, false);
     }
   }
</PRE><P>	if (valid) {
</P><PRE>     this.forgetState();
     mediaRule.parsedCssText = s;
     aSheet.cssRules.push(mediaRule);
     return true;
   }
   this.restoreState();
   return false;
 },
</PRE><PRE> trim11: function(str) {
   str = str.replace(/^\s+/, <I>);</I>
   for (var i = str.length - 1; i &gt;= 0; i--) {
     if (/\S/.test( str.charAt(i) )) { // XXX charat
       str = str.substring(0, i + 1);
       break;
     }
   }
   return str;
 },
</PRE><PRE> parseStyleRule: function(aToken, aOwner, aIsInsideMediaRule)
 {
   var currentLine = CountLF(this.mScanner.getAlreadyScanned());
   this.preserveState();
   // first let's see if we have a selector here...
   var selector = this.parseSelector(aToken, false);
   var valid = false;
   var declarations = [];
   if (selector) {
     selector = this.trim11(selector.selector);
     var s = selector;
     var token = this.getToken(true, true);
     if (token.isSymbol(&quot;{&quot;)) {
       s += &quot; { &quot;;
       var token = this.getToken(true, false);
       while (true) {
         if (!token.isNotNull()) {
           valid = true;
           break;
         }
         if (token.isSymbol(&quot;}&quot;)) {
           s += &quot;}&quot;;
           valid = true;
           break;
         } else {
           var d = this.parseDeclaration(token, declarations, true, true, aOwner);
           s += ((d &amp;&amp; declarations.length)Â ? &quot; &quot;Â : &quot;&quot;) + d;
         }
         token = this.getToken(true, false);
       }
     }
   }
   else {
     // selector is invalid so the whole rule is invalid with it
   }
</PRE><PRE>   if (valid) {
     var rule = new jscsspStyleRule();
     rule.currentLine = currentLine;
     rule.parsedCssText = s;
     rule.declarations = declarations;
     rule.mSelectorText = selector;
     if (aIsInsideMediaRule)
       rule.parentRule = aOwner;
     else
       rule.parentStyleSheet = aOwner;
     aOwner.cssRules.push(rule);
     return s;
   }
   this.restoreState();
   s = this.currentToken().value;
   this.addUnknownAtRule(aOwner, s);
   return &quot;&quot;;
 },
</PRE><PRE> parseSelector: function(aToken, aParseSelectorOnly) {
   var s = &quot;&quot;;
   var specificity = {a: 0, b: 0, c: 0, d: 0}; // CSS 2.1 section 6.4.3
   var isFirstInChain = true;
   var token = aToken;
   var valid = false;
   var combinatorFound = false;
   while (true) {
     if (!token.isNotNull()) {
       if (aParseSelectorOnly)
         return {selector: s, specificity: specificity };
       return &quot;&quot;;
     }
</PRE><PRE>     if (!aParseSelectorOnly &amp;&amp; token.isSymbol(&quot;{&quot;)) {
       // end of selector
       valid =Â !combinatorFound;
</PRE><P>	if (valid) this.ungetToken();
</P><PRE>       break;
     }
</PRE><PRE>     if (token.isSymbol(&quot;,&quot;)) { // group of selectors
       s += token.value;
       isFirstInChain = true;
       combinatorFound = false;
       token = this.getToken(false, true);
       continue;
     }
     // now combinators and grouping...
     else if (!combinatorFound
</PRE><P>&amp;&amp; (token.isWhiteSpace()
		    || token.isSymbol(&quot;&gt;&quot;)
</P><PRE>                   || token.isSymbol(&quot;+&quot;)
                   || token.isSymbol(&quot;~&quot;))) {
</PRE><P>	if (token.isWhiteSpace()) {
</P><PRE>         s += &quot; &quot;;
</PRE><P>	  var nextToken = this.lookAhead(true, true);
	  if (!nextToken.isNotNull()) {
</P><PRE>           if (aParseSelectorOnly)
             return {selector: s, specificity: specificity };
</PRE><P>	    return &quot;&quot;;
	  }
	  if (nextToken.isSymbol(&quot;&gt;&quot;)
	      || nextToken.isSymbol(&quot;+&quot;)
	      || nextToken.isSymbol(&quot;~&quot;)) {
</P><PRE>           token = this.getToken(true, true);
</PRE><P>	    s += token.value + &quot; &quot;;
	    combinatorFound = true;
	  }
	}
</P><PRE>       else {
         s += token.value;
</PRE><P>	  combinatorFound = true;
	}
	isFirstInChain = true;
</P><PRE>       token = this.getToken(true, true);
       continue;
     }
     else {
       var simpleSelector = this.parseSimpleSelector(token, isFirstInChain, true);
       if (!simpleSelector)
         break; // error
       s += simpleSelector.selector;
       specificity.b += simpleSelector.specificity.b;
       specificity.c += simpleSelector.specificity.c;
       specificity.d += simpleSelector.specificity.d;
</PRE><P>	isFirstInChain = false;
	combinatorFound = false;
</P><PRE>     }
</PRE><PRE>     token = this.getToken(false, true);
   }
</PRE><PRE>   if (valid) {
     return {selector: s, specificity: specificity };
   }
   return &quot;&quot;;
 },</PRE><PRE> isPseudoElement: function(aIdent)
 {
   switch (aIdent) {
     case &quot;first-letter&quot;:
     case &quot;first-line&quot;:
     case &quot;before&quot;:
     case &quot;after&quot;:
     case &quot;marker&quot;:
       return true;
       break;
     default: return false;
       break;
   }
 },
</PRE><PRE> parseSimpleSelector: function(token, isFirstInChain, canNegate)
 {
   var s = &quot;&quot;;
   var specificity = {a: 0, b: 0, c: 0, d: 0}; // CSS 2.1 section 6.4.3
   
   if (isFirstInChain
       &amp;&amp; (token.isSymbol(&quot;*&quot;) || token.isSymbol(&quot;|&quot;) || token.isIdent())) {
     // type or universal selector
     if (token.isSymbol(&quot;*&quot;) || token.isIdent()) {
       // we don't know yet if it's a prefix or a universal
       // selector
       s += token.value;
       var isIdent = token.isIdent();
       token = this.getToken(false, true);
       if (token.isSymbol(&quot;|&quot;)) {
         // it's a prefix
         s += token.value;
         token = this.getToken(false, true);
         if (token.isIdent() || token.isSymbol(&quot;*&quot;)) {
           // ok we now have a type element or universal
           // selector
           s += token.value;
           if (token.isIdent())
             specificity.d++;
         } else
           // oops that's an error...
           return null;
       } else {
         this.ungetToken();
         if (isIdent)
           specificity.d++;
       }
     } else if (token.isSymbol(&quot;|&quot;)) {
       s += token.value;
       token = this.getToken(false, true);
       if (token.isIdent() || token.isSymbol(&quot;*&quot;)) {
         s += token.value;
         if (token.isIdent())
           specificity.d++;
       } else
         // oops that's an error
         return null;
     }
   }
 
   else if (token.isSymbol(&quot;.&quot;) || token.isSymbol(&quot;#&quot;)) {
     var isClass = token.isSymbol(&quot;.&quot;);
     s += token.value;
     token = this.getToken(false, true);
     if (token.isIdent()) {
       s += token.value;
       if (isClass)
         specificity.c++;
       else
         specificity.b++;
     }
     else
       return null;
   }
</PRE><PRE>   else if (token.isSymbol(&quot;:&quot;)) {
     s += token.value;
     token = this.getToken(false, true);
     if (token.isSymbol(&quot;:&quot;)) {
       s += token.value;
       token = this.getToken(false, true);
     }
     if (token.isIdent()) {
       s += token.value;
       if (this.isPseudoElement(token.value))
         specificity.d++;
       else
         specificity.c++;
     }
     else if (token.isFunction()) {
       s += token.value;
       if (token.isFunction(&quot;:not(&quot;)) {
         if (!canNegate)
           return null;
         token = this.getToken(true, true);
         var simpleSelector = this.parseSimpleSelector(token, isFirstInChain, false);
         if (!simpleSelector)
           return null;
         else {
           s += simpleSelector.selector;
           token = this.getToken(true, true);
           if (token.isSymbol(&quot;)&quot;))
             s += &quot;)&quot;;
           else
             return null;
         }
         specificity.c++;
       }
       else {
         while (true) {
           token = this.getToken(false, true);
           if (token.isSymbol(&quot;)&quot;)) {
             s += &quot;)&quot;;
             break;
           } else
             s += token.value;
         }
         specificity.c++;
       }
     } else
       return null;
 
   } else if (token.isSymbol(&quot;[&quot;)) {
     s += &quot;[&quot;;
     token = this.getToken(true, true);
     if (token.isIdent() || token.isSymbol(&quot;*&quot;)) {
       s += token.value;
       var nextToken = this.getToken(true, true);
       if (token.isSymbol(&quot;|&quot;)) {
         s += &quot;|&quot;;
         token = this.getToken(true, true);
         if (token.isIdent())
           s += token.value;
         else
           return null;
       } else
         this.ungetToken();
     } else if (token.isSymbol(&quot;|&quot;)) {
       s += &quot;|&quot;;
       token = this.getToken(true, true);
       if (token.isIdent())
         s += token.value;
       else
         return null;
     }
     else
       return null;
 
     // nothing, =, *=, $=, ^=, |=
     token = this.getToken(true, true);
     if (token.isIncludes()
         || token.isDashmatch()
         || token.isBeginsmatch()
         || token.isEndsmatch()
         || token.isContainsmatch()
         || token.isSymbol(&quot;=&quot;)) {
       s += token.value;
       token = this.getToken(true, true);
       if (token.isString() || token.isIdent()) {
         s += token.value;
         token = this.getToken(true, true);
       }
       else
         return null;
   
       if (token.isSymbol(&quot;]&quot;)) {
         s += token.value;
         specificity.c++;
       }
       else
         return null;
     }
     else if (token.isSymbol(&quot;]&quot;)) {
       s += token.value;
       specificity.c++;
     }
     else
       return null;
       
   }
   else if (token.isWhiteSpace()) {
     var t = this.lookAhead(true, true);
     if (t.isSymbol('{'))
       return &quot;&quot;
   }
   if (s)
     return {selector: s, specificity: specificity };
   return null;
 },
</PRE><PRE> preserveState: function() {
   this.mPreservedTokens.push(this.currentToken());
   this.mScanner.preserveState();
 },
</PRE><PRE> restoreState: function() {
   if (this.mPreservedTokens.length) {
     this.mScanner.restoreState();
     this.mToken = this.mPreservedTokens.pop();
   }
 },
</PRE><PRE> forgetState: function() {
   if (this.mPreservedTokens.length) {
     this.mScanner.forgetState();
     this.mPreservedTokens.pop();
   }
 },
</PRE><PRE> parse: function(aString, aTryToPreserveWhitespaces, aTryToPreserveComments) {
   if (!aString)
     return null; // early way out if we can
</PRE><PRE>   this.mPreserveWS       = aTryToPreserveWhitespaces;
   this.mPreserveComments = aTryToPreserveComments;
   this.mPreservedTokens = [];
   this.mScanner.init(aString);
   var sheet = new jscsspStylesheet();
</PRE><PRE>   // @charset can only appear at first char of the stylesheet
   var token = this.getToken(false, false);
   if (!token.isNotNull())
     return;
   if (token.isAtRule(&quot;@charset&quot;)) {
     this.parseCharsetRule(token, sheet);
     token = this.getToken(false, false);
   }
</PRE><PRE>   var foundStyleRules = false;
   var foundImportRules = false;
   var foundNameSpaceRules = false;
   while (true) {
     if (!token.isNotNull())
       break;
     if (token.isWhiteSpace())
     {
       if (aTryToPreserveWhitespaces)
         this.addWhitespace(sheet, token.value);
     }
</PRE><PRE>     else if (token.isComment())
     {
       if (this.mPreserveComments)
         this.addComment(sheet, token.value);
     }
</PRE><PRE>     else if (token.isAtRule()) {
       if (token.isAtRule(&quot;@variables&quot;)) {
         if (!foundImportRules &amp;&amp;Â !foundStyleRules)
           this.parseVariablesRule(token, sheet);
         else {
           this.reportError(kVARIABLES_RULE_POSITION);
           this.addUnknownAtRule(sheet, token.value);
         }
       }
       else if (token.isAtRule(&quot;@import&quot;)) {
         // @import rules MUST occur before all style and namespace
         // rules
         if (!foundStyleRules &amp;&amp;Â !foundNameSpaceRules)
           foundImportRules = this.parseImportRule(token, sheet);
         else {
           this.reportError(kIMPORT_RULE_POSITION);
           this.addUnknownAtRule(sheet, token.value);
         }
       }
       else if (token.isAtRule(&quot;@namespace&quot;)) {
         // @namespace rules MUST occur before all style rule and
         // after all @import rules
         if (!foundStyleRules)
           foundNameSpaceRules = this.parseNamespaceRule(token, sheet);
         else {
           this.reportError(kNAMESPACE_RULE_POSITION);
           this.addUnknownAtRule(sheet, token.value);
         }
       }
       else if (token.isAtRule(&quot;@font-face&quot;)) {
         if (this.parseFontFaceRule(token, sheet))
           foundStyleRules = true;
         else
           this.addUnknownAtRule(sheet, token.value);
       }
       else if (token.isAtRule(&quot;@page&quot;)) {
         if (this.parsePageRule(token, sheet))
           foundStyleRules = true;
         else
           this.addUnknownAtRule(sheet, token.value);
       }
       else if (token.isAtRule(&quot;@media&quot;)) {
         if (this.parseMediaRule(token, sheet))
           foundStyleRules = true;
         else
           this.addUnknownAtRule(sheet, token.value);
       }
       else if (token.isAtRule(&quot;@keyframes&quot;)) {
         if (!this.parseKeyframesRule(token, sheet))
           this.addUnknownAtRule(sheet, token.value);
       }
       else if (token.isAtRule(&quot;@charset&quot;)) {
         this.reportError(kCHARSET_RULE_CHARSET_SOF);
         this.addUnknownAtRule(sheet, token.value);
       }
       else {
         this.reportError(kUNKNOWN_AT_RULE);
         this.addUnknownAtRule(sheet, token.value);
       }
     }
</PRE><PRE>     else // plain style rules
     {
       var ruleText = this.parseStyleRule(token, sheet, false);
       if (ruleText)
         foundStyleRules = true;
     }
     token = this.getToken(false);
   }
</PRE><PRE>   return sheet;
 }
</PRE><P>};
</P><P>
function jscsspToken(aType, aValue, aUnit)
{
</P><PRE> this.type = aType;
 this.value = aValue;
 this.unit = aUnit;
</PRE><P>}
</P><P>jscsspToken.NULL_TYPE = 0;
</P><P>jscsspToken.WHITESPACE_TYPE = 1;
jscsspToken.STRING_TYPE = 2;
jscsspToken.COMMENT_TYPE = 3;
jscsspToken.NUMBER_TYPE = 4;
jscsspToken.IDENT_TYPE = 5;
jscsspToken.FUNCTION_TYPE = 6;
jscsspToken.ATRULE_TYPE = 7;
jscsspToken.INCLUDES_TYPE = 8;
jscsspToken.DASHMATCH_TYPE = 9;
jscsspToken.BEGINSMATCH_TYPE = 10;
jscsspToken.ENDSMATCH_TYPE = 11;
jscsspToken.CONTAINSMATCH_TYPE = 12;
jscsspToken.SYMBOL_TYPE = 13;
jscsspToken.DIMENSION_TYPE = 14;
jscsspToken.PERCENTAGE_TYPE = 15;
jscsspToken.HEX_TYPE = 16;
</P><P>jscsspToken.prototype = {
</P><PRE> isNotNull: function ()
 {
   return this.type;
 },
</PRE><PRE> _isOfType: function (aType, aValue)
 {
   return (this.type == aType &amp;&amp; (!aValue || this.value.toLowerCase() == aValue));
 },
</PRE><PRE> isWhiteSpace: function(w)
 {
   return this._isOfType(jscsspToken.WHITESPACE_TYPE, w);
 },
</PRE><PRE> isString: function()
 {
   return this._isOfType(jscsspToken.STRING_TYPE);
 },
</PRE><PRE> isComment: function()
 {
   return this._isOfType(jscsspToken.COMMENT_TYPE);
 },
</PRE><PRE> isNumber: function(n)
 {
   return this._isOfType(jscsspToken.NUMBER_TYPE, n);
 },
</PRE><PRE> isSymbol: function(c)
 {
   return this._isOfType(jscsspToken.SYMBOL_TYPE, c);
 },
</PRE><PRE> isIdent: function(i)
 {
   return this._isOfType(jscsspToken.IDENT_TYPE, i);
 },
</PRE><PRE> isFunction: function(f)
 {
   return this._isOfType(jscsspToken.FUNCTION_TYPE, f);
 },
</PRE><PRE> isAtRule: function(a)
 {
   return this._isOfType(jscsspToken.ATRULE_TYPE, a);
 },
</PRE><PRE> isIncludes: function()
 {
   return this._isOfType(jscsspToken.INCLUDES_TYPE);
 },
</PRE><PRE> isDashmatch: function()
 {
   return this._isOfType(jscsspToken.DASHMATCH_TYPE);
 },
</PRE><PRE> isBeginsmatch: function()
 {
   return this._isOfType(jscsspToken.BEGINSMATCH_TYPE);
 },
</PRE><PRE> isEndsmatch: function()
 {
   return this._isOfType(jscsspToken.ENDSMATCH_TYPE);
 },
</PRE><PRE> isContainsmatch: function()
 {
   return this._isOfType(jscsspToken.CONTAINSMATCH_TYPE);
 },
</PRE><PRE> isSymbol: function(c)
 {
   return this._isOfType(jscsspToken.SYMBOL_TYPE, c);
 },
</PRE><PRE> isDimension: function()
 {
   return this._isOfType(jscsspToken.DIMENSION_TYPE);
 },
</PRE><PRE> isPercentage: function()
 {
   return this._isOfType(jscsspToken.PERCENTAGE_TYPE);
 },
</PRE><PRE> isHex: function()
 {
   return this._isOfType(jscsspToken.HEX_TYPE);
 },
</PRE><PRE> isDimensionOfUnit: function(aUnit)
 {
   return (this.isDimension() &amp;&amp; this.unit == aUnit);
 },
</PRE><PRE> isLength: function()
 {
   return (this.isPercentage() ||
           this.isDimensionOfUnit(&quot;cm&quot;) ||
           this.isDimensionOfUnit(&quot;mm&quot;) ||
           this.isDimensionOfUnit(&quot;in&quot;) ||
           this.isDimensionOfUnit(&quot;pc&quot;) ||
           this.isDimensionOfUnit(&quot;px&quot;) ||
           this.isDimensionOfUnit(&quot;em&quot;) ||
           this.isDimensionOfUnit(&quot;ex&quot;) ||
           this.isDimensionOfUnit(&quot;pt&quot;));
 },
</PRE><PRE> isAngle: function()
 {
   return (this.isDimensionOfUnit(&quot;deg&quot;) ||
           this.isDimensionOfUnit(&quot;rad&quot;) ||
           this.isDimensionOfUnit(&quot;grad&quot;));
 }</PRE><P>}
</P><P>var kJscsspUNKNOWN_RULE   = 0;
var kJscsspSTYLE_RULE     = 1
var kJscsspCHARSET_RULE   = 2;
var kJscsspIMPORT_RULE    = 3;
var kJscsspMEDIA_RULE     = 4;
var kJscsspFONT_FACE_RULE = 5;
var kJscsspPAGE_RULE      = 6;
</P><P>var kJscsspKEYFRAMES_RULE = 7;
var kJscsspKEYFRAME_RULE  = 8;
</P><P>var kJscsspNAMESPACE_RULE = 100;
var kJscsspCOMMENT        = 101;
var kJscsspWHITE_SPACE    = 102;
</P><P>var kJscsspVARIABLES_RULE = 200;
</P><P>var kJscsspSTYLE_DECLARATION = 1000;
</P><P>var gTABS = &quot;&quot;;
</P><P>function jscsspStylesheet()
{
</P><PRE> this.cssRules = [];
 this.variables = {};
</PRE><P>}
</P><P>jscsspStylesheet.prototype = {
</P><PRE> insertRule: function(aRule, aIndex) {
   try {
    this.cssRules.splice(aIndex, 1, aRule);
   }
   catch(e) {
   }
 },
</PRE><PRE> deleteRule: function(aIndex) {
   try {
     this.cssRules.splice(aIndex);
   }
   catch(e) {
   }
 },
</PRE><PRE> cssText: function() {
   var rv = &quot;&quot;;
   for (var i = 0; i &lt; this.cssRules.length; i++)
     rv += this.cssRules[i].cssText() + &quot;\n&quot;;
   return rv;
 },
</PRE><PRE> resolveVariables: function(aMedium) {
</PRE><PRE>   function ItemFoundInArray(aArray, aItem) {
     for (var i = 0; i &lt; aArray.length; i++)
       if (aItem == aArray[i])
         return true;
     return false;
   }
   
   for (var i = 0; i &lt; this.cssRules.length; i++)
   {
     var rule = this.cssRules[i];
     if (rule.type == kJscsspSTYLE_RULE || rule.type == kJscsspIMPORT_RULE)
       break;
     else if (rule.type == kJscsspVARIABLES_RULE &amp;&amp;
              (!rule.media.length || ItemFoundInArray(rule.media, aMedium))) {
       
       for (var j = 0; j &lt; rule.declarations.length; j++) {
         var valueText = &quot;&quot;;
         for (var k = 0; k &lt; rule.declarations[j].values.length; k++)
           valueText += (kÂ ? &quot; &quot;Â : &quot;&quot;) + rule.declarations[j].values[k].value;
         this.variables[rule.declarations[j].property] = valueText;
       }
     }
   }
 }
</PRE><P>};
</P><P>/* kJscsspCHARSET_RULE */
</P><P>function jscsspCharsetRule()
{
</P><PRE> this.type = kJscsspCHARSET_RULE;
 this.encoding = null;
 this.parsedCssText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspCharsetRule.prototype = {
</P><PRE> cssText: function() {
   return &quot;@charset &quot; + this.encoding + &quot;;&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(false, false);
   if (token.isAtRule(&quot;@charset&quot;)) {
     if (parser.parseCharsetRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.encoding = newRule.encoding;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspUNKNOWN_RULE */
</P><P>function jscsspErrorRule(aErrorMsg)
{
</P><PRE> this.error = aErrorMsgÂ ? aErrorMsgÂ : &quot;INVALID&quot;; 
 this.type = kJscsspUNKNOWN_RULE;
 this.parsedCssText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspErrorRule.prototype = {
</P><PRE> cssText: function() {
   return this.parsedCssText;
 }
</PRE><P>};
</P><P>/* kJscsspCOMMENT */
</P><P>function jscsspComment()
{
</P><PRE> this.type = kJscsspCOMMENT;
 this.parsedCssText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspComment.prototype = {
</P><PRE> cssText: function() {
   return this.parsedCssText;
 },
</PRE><PRE> setCssText: function(val) {
   var parser = new CSSParser(val);
   var token = parser.getToken(true, false);
   if (token.isComment())
     this.parsedCssText = token.value;
   else
     throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspWHITE_SPACE */
</P><P>function jscsspWhitespace()
{
</P><PRE> this.type = kJscsspWHITE_SPACE;
 this.parsedCssText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspWhitespace.prototype = {
</P><PRE> cssText: function() {
   return this.parsedCssText;
 }
</PRE><P>};
</P><P>/* kJscsspIMPORT_RULE */
</P><P>function jscsspImportRule()
{
</P><PRE> this.type = kJscsspIMPORT_RULE;
 this.parsedCssText = null;
 this.href = null;
 this.media = []; 
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspImportRule.prototype = {
</P><PRE> cssText: function() {
   var mediaString = this.media.join(&quot;, &quot;);
   return &quot;@import &quot; + this.href
                     + ((mediaString &amp;&amp; mediaStringÂ != &quot;all&quot;)Â ? mediaString + &quot; &quot;Â : &quot;&quot;)
                     + &quot;;&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@import&quot;)) {
     if (parser.parseImportRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.href = newRule.href;
       this.media = newRule.media;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspNAMESPACE_RULE */
</P><P>function jscsspNamespaceRule()
{
</P><PRE> this.type = kJscsspNAMESPACE_RULE;
 this.parsedCssText = null;
 this.prefix = null;
 this.url = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspNamespaceRule.prototype = {
</P><PRE> cssText: function() {
   return &quot;@namespace &quot; + (this.prefixÂ ? this.prefix + &quot; &quot;: &quot;&quot;)
                       + this.url
                       + &quot;;&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@namespace&quot;)) {
     if (parser.parseNamespaceRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.url = newRule.url;
       this.prefix = newRule.prefix;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspSTYLE_DECLARATION */
</P><P>function jscsspDeclaration()
{
</P><PRE> this.type = kJscsspSTYLE_DECLARATION;
 this.property = null;
 this.values = [];
 this.valueText = null;
 this.priority = null;
 this.parsedCssText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspDeclaration.prototype = {
</P><PRE> kCOMMA_SEPARATED: {
   &quot;cursor&quot;: true,
   &quot;font-family&quot;: true,
   &quot;voice-family&quot;: true,
   &quot;background-image&quot;: true
 },
</PRE><PRE> kUNMODIFIED_COMMA_SEPARATED_PROPERTIES: {
   &quot;text-shadow&quot;: true,
   &quot;box-shadow&quot;: true,
   &quot;-moz-transition&quot;: true,
   &quot;-moz-transition-property&quot;: true,
   &quot;-moz-transition-duration&quot;: true,
   &quot;-moz-transition-timing-function&quot;: true,
   &quot;-moz-transition-delay&quot;: true
 },
</PRE><PRE> cssText: function() {
   var prefixes = CssInspector.prefixesForProperty(this.property);
</PRE><PRE>   if (this.property in this.kUNMODIFIED_COMMA_SEPARATED_PROPERTIES) {
     if (prefixes) {
       var rv = &quot;&quot;;
       for (var propertyIndex = 0; propertyIndex &lt; prefixes.length; propertyIndex++) {
         var property = prefixes[propertyIndex];
         rv += (propertyIndexÂ ? gTABSÂ : &quot;&quot;) + property + &quot;: &quot;;
         rv += this.valueText + (this.priorityÂ ? &quot; !important&quot;Â : &quot;&quot;) + &quot;;&quot;;
         rv += ((prefixes.length &gt; 1 &amp;&amp; propertyIndexÂ != prefixes.length -1)Â ? &quot;\n&quot;Â : &quot;&quot;);
       }
       return rv;
     }
     return this.property + &quot;: &quot; + this.valueText +
            (this.priorityÂ ? &quot; !important&quot;Â : &quot;&quot;) + &quot;;&quot;
   }
</PRE><PRE>   if (prefixes) {
     var rv = &quot;&quot;;
     for (var propertyIndex = 0; propertyIndex &lt; prefixes.length; propertyIndex++) {
       var property = prefixes[propertyIndex];
       rv += (propertyIndexÂ ? gTABSÂ : &quot;&quot;) + property + &quot;: &quot;;
       var separator = (property in this.kCOMMA_SEPARATED)Â ? &quot;, &quot;Â : &quot; &quot;;
       for (var i = 0; i &lt; this.values.length; i++)
         if (this.values[i].cssText()Â != null)
           rv += (iÂ ? separatorÂ : &quot;&quot;) + this.values[i].cssText();
         else
           return null;
       rv += (this.priorityÂ ? &quot; !important&quot;Â : &quot;&quot;) + &quot;;&quot; +
             ((prefixes.length &gt; 1 &amp;&amp; propertyIndexÂ != prefixes.length -1)Â ? &quot;\n&quot;Â : &quot;&quot;);
     }
     return rv;
   }
</PRE><PRE>   var rv = this.property + &quot;: &quot;;
   var separator = (this.property in this.kCOMMA_SEPARATED)Â ? &quot;, &quot;Â : &quot; &quot;;
   var extras = {&quot;webkit&quot;: false, &quot;presto&quot;: false, &quot;trident&quot;: false, &quot;generic&quot;: false }
   for (var i = 0; i &lt; this.values.length; i++) {
     var v = this.values[i].cssText();
     if (vÂ != null) {
       var paren = v.indexOf(&quot;(&quot;);
       var kwd = v;
       if (parenÂ != -1)
         kwd = v.substr(0, paren);
       if (kwd in kCSS_VENDOR_VALUES) {
         for (var j in kCSS_VENDOR_VALUES[kwd]) {
           extras[j] = extras[j] || (kCSS_VENDOR_VALUES[kwd][j]Â != &quot;&quot;);
         }
       }
       rv += (iÂ ? separatorÂ : &quot;&quot;) + v;
     }
     else
       return null;
   }
   rv += (this.priorityÂ ? &quot; !important&quot;Â : &quot;&quot;) + &quot;;&quot;;
</PRE><PRE>   for (var j in extras) {
     if (extras[j]) {
       var str = &quot;\n&quot; + gTABS +  this.property + &quot;: &quot;;
       for (var i = 0; i &lt; this.values.length; i++) {
         var v = this.values[i].cssText();
         if (vÂ != null) {
           var paren = v.indexOf(&quot;(&quot;);
           var kwd = v;
           if (parenÂ != -1)
             kwd = v.substr(0, paren);
           if (kwd in kCSS_VENDOR_VALUES) {
             functor = kCSS_VENDOR_VALUES[kwd][j];
             if (functor) {
               v = (typeof functor == &quot;string&quot;)Â ? functorÂ : functor(v, j);
               if (!v) {
                 str = null;
                 break;
               }
             }
           }
           str += (iÂ ? separatorÂ : &quot;&quot;) + v;
         }
         else
           return null;
       }
       if (str)
         rv += str + &quot;;&quot;
       else
         rv += &quot;\n&quot; + gTABS + &quot;/* Impossible to translate property &quot; + this.property + &quot; for &quot; + j + &quot; */&quot;;
     }
   }
   return rv;
 },
</PRE><PRE> setCssText: function(val) {
   var declarations = [];
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (parser.parseDeclaration(token, declarations, true, true, null)
       &amp;&amp; declarations.length
       &amp;&amp; declarations[0].type == kJscsspSTYLE_DECLARATION) {
     var newDecl = declarations.cssRules[0];
     this.property = newDecl.property;
     this.value = newDecl.value;
     this.priority = newDecl.priority;
     this.parsedCssText = newRule.parsedCssText;
     return;
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspFONT_FACE_RULE */
</P><P>function jscsspFontFaceRule()
{
</P><PRE> this.type = kJscsspFONT_FACE_RULE;
 this.parsedCssText = null;
 this.descriptors = [];
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspFontFaceRule.prototype = {
</P><PRE> cssText: function() {
   var rv = gTABS + &quot;@font-face {\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.descriptors.length; i++)
     rv += gTABS + this.descriptors[i].cssText() + &quot;\n&quot;;
   gTABS = preservedGTABS;
   return rv + gTABS + &quot;}&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@font-face&quot;)) {
     if (parser.parseFontFaceRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.descriptors = newRule.descriptors;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspKEYFRAMES_RULE */
function jscsspKeyframesRule()
{
</P><PRE> this.type = kJscsspKEYFRAMES_RULE;
 this.parsedCssText = null;
 this.cssRules = [];
 this.name = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspKeyframesRule.prototype = {
</P><PRE> cssText: function() {
   var rv = gTABS
              + &quot;@keyframes &quot;
              + this.name + &quot; {\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.cssRules.length; i++)
     rv += gTABS + this.cssRules[i].cssText() + &quot;\n&quot;;
   gTABS = preservedGTABS;
   rv += gTABS + &quot;}\n&quot;;
   return rv;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@keyframes&quot;)) {
     if (parser.parseKeyframesRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.cssRules = newRule.cssRules;
       this.name = newRule.name;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspKEYFRAME_RULE */
function jscsspKeyframeRule()
{
</P><PRE> this.type = kJscsspKEYFRAME_RULE;
 this.parsedCssText = null;
 this.declarations = []
 this.keyText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspKeyframeRule.prototype = {
</P><PRE> cssText: function() {
   var rv = this.keyText + &quot; {\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.declarations.length; i++) {
     var declText = this.declarations[i].cssText();
     if (declText)
       rv += gTABS + this.declarations[i].cssText() + &quot;\n&quot;;
   }
   gTABS = preservedGTABS;
   return rv + gTABS + &quot;}&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (!token.isNotNull()) {
     if (parser.parseKeyframeRule(token, sheet, false)) {
       var newRule = sheet.cssRules[0];
       this.keyText = newRule.keyText;
       this.declarations = newRule.declarations;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspMEDIA_RULE */
</P><P>function jscsspMediaRule()
{
</P><PRE> this.type = kJscsspMEDIA_RULE;
 this.parsedCssText = null;
 this.cssRules = [];
 this.media = [];
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspMediaRule.prototype = {
</P><PRE> cssText: function() {
   var rv = gTABS + &quot;@media &quot; + this.media.join(&quot;, &quot;) + &quot; {\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.cssRules.length; i++)
     rv += gTABS + this.cssRules[i].cssText() + &quot;\n&quot;;
   gTABS = preservedGTABS;
   return rv + gTABS + &quot;}&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@media&quot;)) {
     if (parser.parseMediaRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.cssRules = newRule.cssRules;
       this.media = newRule.media;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspSTYLE_RULE */
</P><P>function jscsspStyleRule()
{
</P><PRE> this.type = kJscsspSTYLE_RULE;
 this.parsedCssText = null;
 this.declarations = []
 this.mSelectorText = null;
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspStyleRule.prototype = {
</P><PRE> cssText: function() {
   var rv = this.mSelectorText + &quot; {\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.declarations.length; i++) {
     var declText = this.declarations[i].cssText();
     if (declText)
       rv += gTABS + this.declarations[i].cssText() + &quot;\n&quot;;
   }
   gTABS = preservedGTABS;
   return rv + gTABS + &quot;}&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (!token.isNotNull()) {
     if (parser.parseStyleRule(token, sheet, false)) {
       var newRule = sheet.cssRules[0];
       this.mSelectorText = newRule.mSelectorText;
       this.declarations = newRule.declarations;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 },
</PRE><PRE> selectorText: function() {
   return this.mSelectorText;
 },
</PRE><PRE> setSelectorText: function(val) {
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (!token.isNotNull()) {
     var s = parser.parseSelector(token, true);
     if (s) {
       this.mSelectorText = s.selector;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspPAGE_RULE */
</P><P>function jscsspPageRule()
{
</P><PRE> this.type = kJscsspPAGE_RULE;
 this.parsedCssText = null;
 this.pageSelector = null;
 this.declarations = [];
 this.parentStyleSheet = null;
 this.parentRule = null;
</PRE><P>}
</P><P>jscsspPageRule.prototype = {
</P><PRE> cssText: function() {
   var rv = gTABS + &quot;@page &quot;
                  + (this.pageSelectorÂ ? this.pageSelector + &quot; &quot;: &quot;&quot;)
                  + &quot;{\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.declarations.length; i++)
     rv += gTABS + this.declarations[i].cssText() + &quot;\n&quot;;
   gTABS = preservedGTABS;
   return rv + gTABS + &quot;}&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@page&quot;)) {
     if (parser.parsePageRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.pageSelector = newRule.pageSelector;
       this.declarations = newRule.declarations;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>/* kJscsspVARIABLES_RULE */
</P><P>function jscsspVariablesRule()
{
</P><PRE> this.type = kJscsspVARIABLES_RULE;
 this.parsedCssText = null;
 this.declarations = [];
 this.parentStyleSheet = null;
 this.parentRule = null;
 this.media = null;
</PRE><P>}
</P><P>jscsspVariablesRule.prototype = {
</P><PRE> cssText: function() {
   var rv = gTABS + &quot;@variables &quot; +
                    (this.media.lengthÂ ? this.media.join(&quot;, &quot;) + &quot; &quot;Â : &quot;&quot;) +
                    &quot;{\n&quot;;
   var preservedGTABS = gTABS;
   gTABS += &quot;  &quot;;
   for (var i = 0; i &lt; this.declarations.length; i++)
     rv += gTABS + this.declarations[i].cssText() + &quot;\n&quot;;
   gTABS = preservedGTABS;
   return rv + gTABS + &quot;}&quot;;
 },
</PRE><PRE> setCssText: function(val) {
   var sheet = {cssRules: []};
   var parser = new CSSParser(val);
   var token = parser.getToken(true, true);
   if (token.isAtRule(&quot;@variables&quot;)) {
     if (parser.parseVariablesRule(token, sheet)) {
       var newRule = sheet.cssRules[0];
       this.declarations = newRule.declarations;
       this.parsedCssText = newRule.parsedCssText;
       return;
     }
   }
   throw DOMException.SYNTAX_ERR;
 }
</PRE><P>};
</P><P>var kJscsspINHERIT_VALUE = 0;
var kJscsspPRIMITIVE_VALUE = 1;
var kJscsspVARIABLE_VALUE = 4;
</P><P>function jscsspVariable(aType, aSheet)
{
</P><PRE> this.value = &quot;&quot;;
 this.type = aType;
 this.name  = null;
 this.parentRule = null;
 this.parentStyleSheet = aSheet;
</PRE><P>}
</P><P>jscsspVariable.prototype = {
</P><PRE> cssText: function() {
   if (this.type == kJscsspVARIABLE_VALUE)
     return this.resolveVariable(this.name, this.parentRule, this.parentStyleSheet);
   else
     return this.value;
 },
</PRE><PRE> setCssText: function(val) {
   if (this.type == kJscsspVARIABLE_VALUE)
     throw DOMException.SYNTAX_ERR;
   else
     this.value = val;
 },
</PRE><PRE> resolveVariable: function(aName, aRule, aSheet)
 {
   if (aName.toLowerCase() in aSheet.variables)
     return aSheet.variables[aName.toLowerCase()];
   return null;
 }
</PRE><P>};
</P><P>function ParseURL(buffer) {
</P><PRE> var result = { };
 result.protocol = &quot;&quot;;
 result.user = &quot;&quot;;
 result.password = &quot;&quot;;
 result.host = &quot;&quot;;
 result.port = &quot;&quot;;
 result.path = &quot;&quot;;
 result.query = &quot;&quot;;
</PRE><PRE> var section = &quot;PROTOCOL&quot;;
 var start = 0;
 var wasSlash = false;
</PRE><PRE> while(start &lt; buffer.length) {
   if(section == &quot;PROTOCOL&quot;) {
     if(buffer.charAt(start) == ':') {
       section = &quot;AFTER_PROTOCOL&quot;;
       start++;
     } else if(buffer.charAt(start) == '/' &amp;&amp; result.protocol.length() == 0) { 
       section = PATH;
     } else {
       result.protocol += buffer.charAt(start++);
     }
   } else if(section == &quot;AFTER_PROTOCOL&quot;) {
     if(buffer.charAt(start) == '/') {
   if(!wasSlash) {
         wasSlash = true;
   } else {
         wasSlash = false;
         section = &quot;USER&quot;;
   }
       start ++;
     } else {
       throw new ParseException(&quot;Protocol shell be separated with 2 slashes&quot;);
     }       
   } else if(section == &quot;USER&quot;) {
     if(buffer.charAt(start) == '/') {
       result.host = result.user;
       result.user = &quot;&quot;;
       section = &quot;PATH&quot;;
     } else if(buffer.charAt(start) == '?') {
       result.host = result.user;
       result.user = &quot;&quot;;
       section = &quot;QUERY&quot;;
       start++;
     } else if(buffer.charAt(start) == ':') {
       section = &quot;PASSWORD&quot;;
       start++;
     } else if(buffer.charAt(start) == '@') {
       section = &quot;HOST&quot;;
       start++;
     } else {
       result.user += buffer.charAt(start++);
     }
   } else if(section == &quot;PASSWORD&quot;) {
     if(buffer.charAt(start) == '/') {
       result.host = result.user;
       result.port = result.password;
       result.user = &quot;&quot;;
       result.password = &quot;&quot;;
       section = &quot;PATH&quot;;
     } else if(buffer.charAt(start) == '?') {
       result.host = result.user;
       result.port = result.password;
       result.user = &quot;&quot;;
       result.password = &quot;&quot;;
       section = &quot;QUERY&quot;;
       start ++;
     } else if(buffer.charAt(start) == '@') {
       section = &quot;HOST&quot;;
       start++;
     } else {
       result.password += buffer.charAt(start++);
     }
   } else if(section == &quot;HOST&quot;) {
     if(buffer.charAt(start) == '/') {
       section = &quot;PATH&quot;;
     } else if(buffer.charAt(start) == ':') {
       section = &quot;PORT&quot;;
       start++;
     } else if(buffer.charAt(start) == '?') {
       section = &quot;QUERY&quot;;
       start++;
     } else {
       result.host += buffer.charAt(start++);
     }
   } else if(section == &quot;PORT&quot;) {
     if(buffer.charAt(start) == '/') {
       section = &quot;PATH&quot;;
     } else if(buffer.charAt(start) == '?') {
       section = &quot;QUERY&quot;;
       start++;
     } else {
       result.port += buffer.charAt(start++);
     }
   } else if(section == &quot;PATH&quot;) {
     if(buffer.charAt(start) == '?') {
   section = &quot;QUERY&quot;;
   start ++;
     } else {
   result.path += buffer.charAt(start++);
     }
   } else if(section == &quot;QUERY&quot;) {
     result.query += buffer.charAt(start++);
   }
 }
</PRE><PRE> if(section == &quot;PROTOCOL&quot;) {
   result.host = result.protocol;
   result.protocol = &quot;http&quot;;
 } else if(section == &quot;AFTER_PROTOCOL&quot;) {
   throw new ParseException(&quot;Invalid url&quot;);
 } else if(section == &quot;USER&quot;) {
   result.host = result.user;
   result.user = &quot;&quot;;
 } else if(section == &quot;PASSWORD&quot;) {
   result.host = result.user;
   result.port = result.password;
   result.user = &quot;&quot;;
   result.password = &quot;&quot;;
 }
</PRE><PRE> return result;
</PRE><P>}
</P><P>function ParseException(description) {
</P><PRE>   this.description = description;
</PRE><P>}
</P><P>function CountLF(s)
{
</P><PRE> var nCR = s.match( /\n/g );
 return nCRÂ ? nCR.length + 1Â : 1;
</PRE><P>}
</P><P>
function FilterLinearGradientForOutput(aValue, aEngine)
{
</P><PRE> if (aEngine == &quot;generic&quot;)
   return aValue.substr(5);
</PRE><PRE> if (aEngine == &quot;webkit&quot;)
   return aValue.replace( /\-moz\-/g , &quot;-webkit-&quot;)
</PRE><PRE> if (aEngineÂ != &quot;webkit20110101&quot;)
   return &quot;&quot;;
</PRE><PRE> var g = CssInspector.parseBackgroundImages(aValue)[0];
</PRE><PRE> var cancelled = false;
 var str = &quot;-webkit-gradient(linear, &quot;;
 var position = (&quot;position&quot; in g.value)Â ? g.value.position.toLowerCase()Â : &quot;&quot;;
 var angle    = (&quot;angle&quot; in g.value)Â ? g.value.angle.toLowerCase()Â : &quot;&quot;;
 // normalize angle
 if (angle) {
   var match = angle.match(/^([0-9\-\.\\+]+)([a-z]*)/);
   var angle = parseFloat(match[1]);
   var unit  = match[2];
   switch (unit) {
     case &quot;grad&quot;: angle = angle * 90 / 100; break;
     case &quot;rad&quot;:  angle = angle * 180 / Math.PI; break;
     default: break;
   }
   while (angle &lt; 0)
     angle += 360;
   while (angle &gt;= 360)
     angle -= 360;
 }
 // get startpoint w/o keywords
 var startpoint = [];
 var endpoint = [];
 if (positionÂ != &quot;&quot;) {
   if (position == &quot;center&quot;)
     position = &quot;center center&quot;;
   startpoint = position.split(&quot; &quot;);
   if (angle == &quot;&quot; &amp;&amp; angleÂ != 0) {
     // no angle, then we just turn the point 180 degrees around center
     switch (startpoint[0]) {
       case &quot;left&quot;:   endpoint.push(&quot;right&quot;); break;
       case &quot;center&quot;: endpoint.push(&quot;center&quot;); break;
       case &quot;right&quot;:  endpoint.push(&quot;left&quot;); break;
       default: {
           var match = startpoint[0].match(/^([0-9\-\.\\+]+)([a-z]*)/);
           var v     = parseFloat(match[0]);
           var unit  = match[1];
           if (unit == &quot;%&quot;) {
             endpoint.push((100-v) + &quot;%&quot;);
           }
           else
             cancelled = true;
         }
         break;
     }
     if (!cancelled)
       switch (startpoint[1]) {
         case &quot;top&quot;:    endpoint.push(&quot;bottom&quot;); break;
         case &quot;center&quot;: endpoint.push(&quot;center&quot;); break;
         case &quot;bottom&quot;: endpoint.push(&quot;top&quot;); break;
         default: {
             var match = startpoint[1].match(/^([0-9\-\.\\+]+)([a-z]*)/);
             var v     = parseFloat(match[0]);
             var unit  = match[1];
             if (unit == &quot;%&quot;) {
               endpoint.push((100-v) + &quot;%&quot;);
             }
             else
               cancelled = true;
           }
           break;
       }
   }
   else {
     switch (angle) {
       case 0:    endpoint.push(&quot;right&quot;); endpoint.push(startpoint[1]); break;
       case 90:   endpoint.push(startpoint[0]); endpoint.push(&quot;top&quot;); break;
       case 180:  endpoint.push(&quot;left&quot;); endpoint.push(startpoint[1]); break;
       case 270:  endpoint.push(startpoint[0]); endpoint.push(&quot;bottom&quot;); break;
       default:     cancelled = true; break;
     }
   }
 }
 else {
   // no position defined, we accept only vertical and horizontal
   if (angle == &quot;&quot;)
     angle = 270;
   switch (angle) {
     case 0:    startpoint= [&quot;left&quot;, &quot;center&quot;];   endpoint = [&quot;right&quot;, &quot;center&quot;]; break;
     case 90:   startpoint= [&quot;center&quot;, &quot;bottom&quot;]; endpoint = [&quot;center&quot;, &quot;top&quot;]; break;
     case 180:  startpoint= [&quot;right&quot;, &quot;center&quot;];  endpoint = [&quot;left&quot;, &quot;center&quot;]; break;
     case 270:  startpoint= [&quot;center&quot;, &quot;top&quot;];    endpoint = [&quot;center&quot;, &quot;bottom&quot;]; break;
     default:     cancelled = true; break;
   }
 }
</PRE><PRE> if (cancelled)
   return &quot;&quot;;
</PRE><PRE> str += startpoint.join(&quot; &quot;) + &quot;, &quot; + endpoint.join(&quot; &quot;);
 if (!g.value.stops[0].position)
   g.value.stops[0].position = &quot;0%&quot;;
 if (!g.value.stops[g.value.stops.length-1].position)
   g.value.stops[g.value.stops.length-1].position = &quot;100%&quot;;
 var current = 0;
 for (var i = 0; i &lt; g.value.stops.length &amp;&amp;Â !cancelled; i++) {
   var s = g.value.stops[i];
   if (s.position) {
     if (s.position.indexOf(&quot;%&quot;) == -1) {
       cancelled = true;
       break;
     }
   }
   else {
     var j = i + 1;
     while (j &lt; g.value.stops.length &amp;&amp;Â !g.value.stops[j].position)
       j++;
     var inc = parseFloat(g.value.stops[j].position) - current;
     for (var k = i; k &lt; j; k++) {
       g.value.stops[k].position = (current + inc * (k - i + 1) / (j - i + 1)) + &quot;%&quot;;
     }
   }
   current = parseFloat(s.position);
   str += &quot;, color-stop(&quot; + (parseFloat(current) / 100) + &quot;, &quot; + s.color + &quot;)&quot;;
 }
</PRE><PRE> if (cancelled)
   return &quot;&quot;;
 return str + &quot;)&quot;;
</PRE><P>}
</P><P>function FilterRadialGradientForOutput(aValue, aEngine)
{
</P><PRE> if (aEngine == &quot;generic&quot;)
   return aValue.substr(5);
</PRE><PRE> else if (aEngine == &quot;webkit&quot;)
   return aValue.replace( /\-moz\-/g , &quot;-webkit-&quot;)
</PRE><PRE> else if (aEngineÂ != &quot;webkit20110101&quot;)
   return &quot;&quot;;
</PRE><PRE> var g = CssInspector.parseBackgroundImages(aValue)[0];
</PRE><PRE> var shape = (&quot;shape&quot; in g.value)Â ? g.value.shapeÂ : &quot;&quot;;
 var size  = (&quot;size&quot;  in g.value)Â ? g.value.sizeÂ : &quot;&quot;;
 if (shapeÂ != &quot;circle&quot;
     || (sizeÂ != &quot;farthest-corner&quot; &amp;&amp; sizeÂ != &quot;cover&quot;))
   return &quot;&quot;;
</PRE><PRE> if (g.value.stops.length &lt;2
     ||Â !(&quot;position&quot; in g.value.stops[0])
     ||Â !g.value.stops[g.value.stops.length - 1].position
     ||Â !(&quot;position&quot; in g.value.stops[0])
     ||Â !g.value.stops[g.value.stops.length - 1].position)
   return &quot;&quot;;
</PRE><PRE> for (var i = 0; i &lt; g.value.stops.length; i++) {
   var s = g.value.stops[i];
   if ((&quot;position&quot; in s) &amp;&amp; s.position &amp;&amp; s.position.indexOf(&quot;px&quot;) == -1)
     return &quot;&quot;;
 }
</PRE><PRE> var str = &quot;-webkit-gradient(radial, &quot;;
 var position  = (&quot;position&quot;  in g.value)Â ? g.value.positionÂ : &quot;center center&quot;;
 str += position + &quot;, &quot; +  parseFloat(g.value.stops[0].position) + &quot;, &quot;;
 str += position + &quot;, &quot; +  parseFloat(g.value.stops[g.value.stops.length - 1].position);
</PRE><PRE> // at this point we're sure to deal with pixels
 var current = parseFloat(g.value.stops[0].position);
 for (var i = 0; i &lt; g.value.stops.length; i++) {
   var s = g.value.stops[i];
   if (!(&quot;position&quot; in s) ||Â !s.position) {
     var j = i + 1;
     while (j &lt; g.value.stops.length &amp;&amp;Â !g.value.stops[j].position)
       j++;
     var inc = parseFloat(g.value.stops[j].position) - current;
     for (var k = i; k &lt; j; k++) {
       g.value.stops[k].position = (current + inc * (k - i + 1) / (j - i + 1)) + &quot;px&quot;;
     }
   }
   current = parseFloat(s.position);
   var c = (current - parseFloat(g.value.stops[0].position)) /
           (parseFloat(g.value.stops[g.value.stops.length - 1].position) - parseFloat(g.value.stops[0].position));
   str += &quot;, color-stop(&quot; + c + &quot;, &quot; + s.color + &quot;)&quot;;
 }
 str += &quot;)&quot;
 return str;
</PRE><P>}
</P><P>function FilterRepeatingGradientForOutput(aValue, aEngine)
{
</P><PRE> if (aEngine == &quot;generic&quot;)
   return aValue.substr(5);
</PRE><PRE> else if (aEngine == &quot;webkit&quot;)
   return aValue.replace( /\-moz\-/g , &quot;-webkit-&quot;)
</PRE><PRE> return &quot;&quot;;
</PRE><P>}
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:British_Columbia/mwe_cssParser.js">http://2014.igem.org/Team:British_Columbia/mwe_cssParser.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:British_Columbia/mwe_cssParser.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:British_Columbia/mwe_cssParser.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:British_Columbia/mwe_cssParser.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:British_Columbia/mwe_cssParser.js&amp;oldid=106526" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
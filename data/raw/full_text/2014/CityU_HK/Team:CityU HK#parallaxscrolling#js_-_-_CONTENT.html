<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_CityU_HK_parallaxscrolling_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:CityU_HK/parallaxscrolling/js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:CityU_HK/parallaxscrolling/js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:CityU_HK/parallaxscrolling/js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:CityU_HK/parallaxscrolling/js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:CityU_HK/parallaxscrolling/js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:CityU HK/parallaxscrolling/js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><P>/*!
</P><PRE>* skrollr
*
* <A href="https://github.com/Prinzhorn/skrollr" class="external free" rel="nofollow">https://github.com/Prinzhorn/skrollr</A>
*
* free to use under terms of MIT license
*/
</PRE><P>(function(window, document, undefined) {
	'use strict';
</P><P>	/*
	 * Global api.
	 */
	var skrollr = window.skrollr = {
		get: function() {
			return _instance;
		},
		//Main entry point.
		init: function(options) {
			return _instance || new Skrollr(options);
		},
		VERSION: '0.5.10'
	};
</P><P>	//Minify optimization.
	var hasProp = Object.prototype.hasOwnProperty;
</P><P>	//They will be filled when skrollr gets initialized.
	var documentElement;
	var body;
</P><P>	var RENDERED_CLASS = 'rendered';
	var UNRENDERED_CLASS = 'un' + RENDERED_CLASS;
	var SKROLLABLE_CLASS = 'skrollable';
	var SKROLLR_CLASS = 'skrollr';
	var NO_SKROLLR_CLASS = 'no-' + SKROLLR_CLASS;
</P><P>	var DEFAULT_EASING = 'linear';
	var DEFAULT_DURATION = 1000;
</P><P>	var SMOOTH_SCROLLING_DURATION = 200;
</P><P>	var ANCHOR_START = 'start';
	var ANCHOR_END = 'end';
	var ANCHOR_TOP = 'top';
	var ANCHOR_CENTER = 'center';
	var ANCHOR_BOTTOM = 'bottom';
</P><P>	var SKROLLABLE_HAS_RENDERED_CLASS_PROPERTY = '___has_rendered_class';
</P><P>	//The property which will be added to the DOM element to hold the ID of the skrollable.
	var SKROLLABLE_ID_DOM_PROPERTY = '___skrollable_id';
</P><P>	var requestAnimFrame = window.requestAnimationFrame;
</P><P>	//Request animation frame polyfill.
	//Credits go to Erik Möller (<A href="http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating" class="external free" rel="nofollow">http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating</A>)
	(function() {
		var vendors = ['ms', 'moz', 'webkit', 'o'];
		var i;
</P><P>		for(i = 0; i &lt; vendors.length &amp;&amp; !requestAnimFrame; i++) {
			requestAnimFrame = window[vendors[i] + 'RequestAnimationFrame'];
		}
</P><P>		var lastTime = 0;
</P><P>		if (!requestAnimFrame) {
			requestAnimFrame = function(callback) {
				var currTime = _now();
				var timeToCall = Math.max(0, 30 - (currTime - lastTime));
</P><P>				window.setTimeout(function() {
					callback(currTime + timeToCall);
				}, timeToCall);
</P><P>				lastTime = currTime + timeToCall;
			};
		}
	}());
</P><P>
	var rxTrim = /^\s*(.+)\s*$/m;
</P><P>	//Find all data-attributes. data-[_constant]-[offset]-[anchor]-[anchor].
	var rxKeyframeAttribute = /^data(?:-(_\w+))?(?:-?(-?\d+))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;
</P><P>	var rxPropValue = /\s*([a-z\-\[\]]+)\s*:\s*(.+?)\s*(?:;|$)/gi;
</P><P>	//Easing function names follow the property in square brackets.
	var rxPropEasing = /^([a-z\-]+)\[(\w+)\]$/;
</P><P>	var rxCamelCase = /-([a-z])/g;
	var rxCamelCaseFn = function(str, letter) {
		return letter.toUpperCase();
	};
</P><P>	//Numeric values with optional sign.
	var rxNumericValue = /[\-+]?[\d]*\.?[\d]+/g;
</P><P>	//Used to replace occurences of {?} with a number.
	var rxInterpolateString = /\{\?\}/g;
</P><P>	//Finds rgb(a) colors, which don't use the percentage notation.
	var rxRGBAIntegerColor = /rgba?\(\s*-?\d+\s*,\s*-?\d+\s*,\s*-?\d+/g;
</P><P>	//Finds all gradients.
	var rxGradient = /[a-z\-]+-gradient/g;
</P><P>	//Vendor prefix. Will be set once skrollr gets initialized.
	var theCSSPrefix;
	var theDashedCSSPrefix;
</P><P>	//Will be called once (when skrollr gets initialized).
	var detectCSSPrefix = function() {
		//Only relevant prefixes. May be extended.
		//Could be dangerous if there will ever be a CSS property which actually starts with &quot;ms&quot;. Don't hope so.
		var rxPrefixes = /^(?:O|Moz|webkit|ms)/;
</P><P>		//Detect prefix for current browser by finding the first property using a prefix.
		if(window.getComputedStyle) {
			var style = window.getComputedStyle(body, null);
</P><P>			for(var k in style) {
				//We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.
				theCSSPrefix = (k.match(rxPrefixes) || (+k == k &amp;&amp; style[k].match(rxPrefixes)));
</P><P>				if(theCSSPrefix) {
					break;
				}
			}
		}
</P><P>		//Empty string if no prefix detected
		theCSSPrefix = (theCSSPrefix || [<I>])[0];</I></P><P>		//Will be &quot;--&quot; if no prefix detected. No problem, browser will ignore &quot;--transform&quot; and stuff.
		theDashedCSSPrefix = '-' + theCSSPrefix.toLowerCase() + '-';
	};
</P><P>	//Built-in easing functions.
	var easings = {
		begin: function() {
			return 0;
		},
		end: function() {
			return 1;
		},
		linear: function(p) {
			return p;
		},
		quadratic: function(p) {
			return p * p;
		},
		cubic: function(p) {
			return p * p * p;
		},
		swing: function(p) {
			return (-Math.cos(p * Math.PI) / 2) + 0.5;
		},
		sqrt: function(p) {
			return Math.sqrt(p);
		},
		//see <A href="https://www.desmos.com/calculator/tbr20s8vd2" class="external free" rel="nofollow">https://www.desmos.com/calculator/tbr20s8vd2</A> for how I did this
		bounce: function(p) {
			var a;
</P><P>			if(p &lt;= 0.5083) {
				a = 3;
			} else if(p &lt;= 0.8489) {
				a = 9;
			} else if(p &lt;= 0.96208) {
				a = 27;
			} else if(p &lt;= 0.99981) {
				a = 91;
			} else {
				return 1;
			}
</P><P>			return 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a);
		}
	};
</P><P>	/**
	 * Constructor.
	 */
	function Skrollr(options) {
		documentElement = document.documentElement;
		body = document.body;
</P><P>		detectCSSPrefix();
</P><P>		_instance = this;
</P><P>		options = options || {};
</P><P>		_constants = options.constants || {};
</P><P>		//We allow defining custom easings or overwrite existing
		if(options.easing) {
			for(var e in options.easing) {
				easings[e] = options.easing[e];
			}
		}
</P><P>		_listeners = {
			//Function to be called right before rendering.
			beforerender: options.beforerender,
</P><P>			//Function to be called right after finishing rendering.
			render: options.render
		};
</P><P>		//forceHeight is true by default
		_forceHeight = options.forceHeight !== false;
</P><P>		_smoothScrollingEnabled = options.smoothScrolling !== false;
</P><P>		//Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.
		_smoothScrolling = {
			targetTop: _instance.getScrollTop()
		};
</P><P>		if(_forceHeight) {
			_scale = options.scale || 1;
		}
</P><P>		//Remove &quot;no-skrollr&quot; and add &quot;skrollr&quot; to the HTML element.
		_updateClass(documentElement, [SKROLLR_CLASS], [NO_SKROLLR_CLASS]);
</P><P>		if(_forceHeight) {
			//Add a dummy element in order to get a large enough scrollbar.
			//On mobile and later desktop versions a #skrollr-body element takes this role.
</P><P>			var dummy = document.getElementById('skrollr-body') || document.createElement('div');
			var dummyStyle = dummy.style;
</P><P>			dummyStyle.minWidth = '1px';
			dummyStyle.position = 'absolute';
			dummyStyle.top = dummyStyle.zIndex = '0';
</P><P>			//It's the dummy we just created.
			if(!dummy.id) {
				//Give the dummy element a small width and move it to the right to not overlap or interfere with the content.
				//Fixes #76.
				dummyStyle.width = '1px';
				dummyStyle.right = '0';
</P><P>				body.appendChild(dummy);
			}
</P><P>			//Update height of dummy div when window size is changed.
			_reflow = function() {
				//Will be recalculated by _updateDependentKeyFrames.
				_maxKeyFrame = 0;
</P><P>				_updateDependentKeyFrames();
</P><P>				dummyStyle.height = (_maxKeyFrame + documentElement.clientHeight) + 'px';
</P><P>				if(skrollr.iscroll) {
					window.setTimeout(function () {
						skrollr.iscroll.refresh();
					}, 0);
				}
			};
		} else {
			_reflow = function() {
				_maxKeyFrame = body.scrollHeight - documentElement.clientHeight;
				_updateDependentKeyFrames();
				_forceRender = true;
</P><P>				if(skrollr.iscroll) {
					window.setTimeout(function () {
						skrollr.iscroll.refresh();
					}, 0);
				}
			};
		}
</P><P>		_instance.refresh();
</P><P>		_addEvent('resize', _reflow);
</P><P>		//Let's go.
		(function animloop(){
			//This is how the cool kids use requestAnimationFrame
			//<A href="http://paulirish.com/2011/requestanimationframe-for-smart-animating/" class="external free" rel="nofollow">http://paulirish.com/2011/requestanimationframe-for-smart-animating/</A>
			requestAnimFrame(animloop);
			_render();
		}());
</P><P>		return _instance;
	}
</P><P>	/**
	 * (Re)parses some or all elements.
	 */
	Skrollr.prototype.refresh = function(elements) {
		var elementIndex;
		var ignoreID = false;
</P><P>		//Completely reparse anything without argument.
		if(elements === undefined) {
			//Ignore that some elements may already have a skrollable ID.
			ignoreID = true;
</P><P>			_skrollables = [];
			_skrollableIdCounter = 0;
</P><P>			elements = document.getElementsByTagName('*');
		} else {
			//We accept a single element or an array of elements.
			elements = [].concat(elements);
		}
</P><P>		for(elementIndex = 0; elementIndex &lt; elements.length; elementIndex++) {
			var el = elements[elementIndex];
			var anchorTarget = el;
			var keyFrames = [];
</P><P>			//If this particular element should be smooth scrolled.
			var smoothScrollThis = _smoothScrollingEnabled;
</P><P>			if(!el.attributes) {
				continue;
			}
</P><P>			//Iterate over all attributes and search for key frame attributes.
			for (var attributeIndex = 0; attributeIndex &lt; el.attributes.length; attributeIndex++) {
				var attr = el.attributes[attributeIndex];
</P><P>				if(attr.name === 'data-anchor-target') {
					anchorTarget = document.querySelector(attr.value);
</P><P>					if(anchorTarget === null) {
						throw 'Unable to find anchor target &quot;' + attr.value + '&quot;';
					}
</P><P>					continue;
				}
</P><P>				//Global smooth scrolling can be overridden by the element attribute.
				if(attr.name === 'data-smooth-scrolling') {
					smoothScrollThis = attr.value !== 'off';
</P><P>					continue;
				}
</P><P>				var match = attr.name.match(rxKeyframeAttribute);
</P><P>				if(match !== null) {
					var constant = match[1];
</P><P>					//If there is a constant, get it's value or fall back to 0.
					constant = constant &amp;&amp; _constants[constant.substr(1)] || 0;
</P><P>					//Parse key frame offset. If undefined will be casted to 0.
					var offset = (match[2] | 0) + constant;
					var anchor1 = match[3];
					//If second anchor is not set, the first will be taken for both.
					var anchor2 = match[4] || anchor1;
</P><P>					var kf = {
						offset: offset,
						props: attr.value,
						//Point back to the element as well.
						element: el
					};
</P><P>					keyFrames.push(kf);
</P><P>					//&quot;absolute&quot; (or &quot;classic&quot;) mode, where numbers mean absolute scroll offset.
					if(!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {
						kf.mode = 'absolute';
</P><P>						//data-end needs to be calculated after all key frames are know.
						if(anchor1 === ANCHOR_END) {
							kf.isEnd = true;
						} else {
							//For data-start we can already set the key frame w/o calculations.
							//#59: &quot;scale&quot; options should only affect absolute mode.
							kf.frame = offset * _scale;
</P><P>							delete kf.offset;
						}
					}
					//&quot;relative&quot; mode, where numbers are relative to anchors.
					else {
						kf.mode = 'relative';
						kf.anchors = [anchor1, anchor2];
					}
				}
			}
</P><P>			//Does this element have key frames?
			if(keyFrames.length) {
				//Will hold the original style and class attributes before we controlled the element (see #80).
				var styleAttr, classAttr;
</P><P>				var id;
</P><P>				if(!ignoreID &amp;&amp; SKROLLABLE_ID_DOM_PROPERTY in el) {
					//We already have this element under control. Grab the corresponding skrollable id.
					id = el[SKROLLABLE_ID_DOM_PROPERTY];
					styleAttr = _skrollables[id].styleAttr;
					classAttr = _skrollables[id].classAttr;
				} else {
					//It's an unknown element. Asign it a new skrollable id.
					id = (el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++);
					styleAttr = el.style.cssText;
					classAttr = _getClass(el);
				}
</P><P>				var skrollable = _skrollables[id] = {
					element: el,
					styleAttr: styleAttr,
					classAttr: classAttr,
					anchorTarget: anchorTarget,
					keyFrames: keyFrames,
					smoothScrolling: smoothScrollThis
				};
</P><P>				_updateClass(el, [SKROLLABLE_CLASS, RENDERED_CLASS], [UNRENDERED_CLASS]);
				skrollable[SKROLLABLE_HAS_RENDERED_CLASS_PROPERTY] = true;
			}
		}
</P><P>		//Reflow for the first time.
		_reflow();
</P><P>		//Now that we got all key frame numbers right, actually parse the properties.
		for(elementIndex = 0; elementIndex &lt; elements.length; elementIndex++) {
			var sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];
</P><P>			if(sk === undefined) {
				continue;
			}
</P><P>			//Make sure they are in order
			sk.keyFrames.sort(_keyFrameComparator);
</P><P>			//Parse the property string to objects
			_parseProps(sk);
</P><P>			//Fill key frames with missing properties from left and right
			_fillProps(sk);
		}
</P><P>		return _instance;
	};
</P><P>	/**
	 * Transform &quot;relative&quot; mode to &quot;absolute&quot; mode.
	 * That is, calculate anchor position and offset of element.
	 */
	Skrollr.prototype.relativeToAbsolute = function(element, viewportAnchor, elementAnchor) {
		var viewportHeight = documentElement.clientHeight;
		var box = element.getBoundingClientRect();
		var absolute = box.top;
</P><P>		//#100: IE doesn't supply &quot;height&quot; with getBoundingClientRect.
		var boxHeight = box.bottom - box.top;
</P><P>		if(viewportAnchor === ANCHOR_BOTTOM) {
			absolute -= viewportHeight;
		} else if(viewportAnchor === ANCHOR_CENTER) {
			absolute -= viewportHeight / 2;
		}
</P><P>		if(elementAnchor === ANCHOR_BOTTOM) {
			absolute += boxHeight;
		} else if(elementAnchor === ANCHOR_CENTER) {
			absolute += boxHeight / 2;
		}
</P><P>		//Compensate scrolling since getBoundingClientRect is relative to viewport.
		absolute += _instance.getScrollTop();
</P><P>		return (absolute + 0.5) | 0;
	};
</P><P>	/**
	 * Animates scroll top to new position.
	 */
	Skrollr.prototype.animateTo = function(top, options) {
		options = options || {};
</P><P>		var now = _now();
		var scrollTop = _instance.getScrollTop();
</P><P>		//Setting this to a new value will automatically cause the current animation to stop, if any.
		_scrollAnimation = {
			startTop: scrollTop,
			topDiff: top - scrollTop,
			targetTop: top,
			duration: options.duration || DEFAULT_DURATION,
			startTime: now,
			endTime: now + (options.duration || DEFAULT_DURATION),
			easing: easings[options.easing || DEFAULT_EASING],
			done: options.done
		};
</P><P>		//Don't queue the animation if there's nothing to animate.
		if(!_scrollAnimation.topDiff) {
			if(_scrollAnimation.done) {
				_scrollAnimation.done.call(_instance, false);
			}
</P><P>			_scrollAnimation = undefined;
		}
</P><P>		return _instance;
	};
</P><P>	/**
	 * Stops animateTo animation.
	 */
	Skrollr.prototype.stopAnimateTo = function() {
		if(_scrollAnimation &amp;&amp; _scrollAnimation.done) {
			_scrollAnimation.done.call(_instance, true);
		}
</P><P>		_scrollAnimation = undefined;
	};
</P><P>	/**
	 * Returns if an animation caused by animateTo is currently running.
	 */
	Skrollr.prototype.isAnimatingTo = function() {
		return !!_scrollAnimation;
	};
</P><P>	Skrollr.prototype.setScrollTop = function(top) {
		//skrollr.iscroll is an instance of iscroll available in mobile mode
		if(skrollr.iscroll) {
			//Notice the minus.
			skrollr.iscroll.scrollTo(0, -top);
		} else {
			window.scrollTo(0, top);
		}
</P><P>		return _instance;
	};
</P><P>	Skrollr.prototype.getScrollTop = function() {
		//skrollr.iscroll is an instance of iscroll available in mobile mode
		if(skrollr.iscroll) {
			return -skrollr.iscroll.y;
		} else {
			return window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;
		}
	};
</P><P>	Skrollr.prototype.on = function(name, fn) {
		_listeners[name] = fn;
</P><P>		return _instance;
	};
</P><P>	Skrollr.prototype.off = function(name) {
		delete _listeners[name];
</P><P>		return _instance;
	};
</P><P>	/*
		Private methods.
	*/
</P><P>	/**
	 * Updates key frames which depend on others.
	 * That is &quot;end&quot; in &quot;absolute&quot; mode and all key frames in &quot;relative&quot; mode.
	 */
	var _updateDependentKeyFrames = function() {
		var skrollable;
		var element;
		var anchorTarget;
		var keyFrames;
		var kf;
		var skrollableIndex;
		var keyFrameIndex;
</P><P>		//For relative mode, we need to reset style and class. See #80
		var styleAttr;
		var classAttr;
</P><P>		//First process all relative-mode elements and find the max key frame.
		for(skrollableIndex = 0; skrollableIndex &lt; _skrollables.length; skrollableIndex++) {
			skrollable = _skrollables[skrollableIndex];
			element = skrollable.element;
			anchorTarget = skrollable.anchorTarget;
			keyFrames = skrollable.keyFrames;
</P><P>			for(keyFrameIndex = 0; keyFrameIndex &lt; keyFrames.length; keyFrameIndex++) {
				kf = keyFrames[keyFrameIndex];
</P><P>				if(kf.mode === 'relative') {
					//Save the current style and class (#80)
					styleAttr = element.style.cssText;
					classAttr = _getClass(element);
</P><P>					//Reset style and class to original (#80)
					element.style.cssText = skrollable.styleAttr;
					_updateClass(element, skrollable.classAttr);
</P><P>					kf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - kf.offset;
</P><P>					//Now set style and class back to what skrollr did to it.
					element.style.cssText = styleAttr;
					_updateClass(element, classAttr);
				}
</P><P>				//Only search for max key frame when forceHeight is enabled.
				if(_forceHeight) {
					//Find the max key frame, but don't use one of the data-end ones for comparison.
					if(!kf.isEnd &amp;&amp; kf.frame &gt; _maxKeyFrame) {
						_maxKeyFrame = kf.frame;
					}
				}
			}
		}
</P><P>		//Now process all data-end keyframes.
		for(skrollableIndex = 0; skrollableIndex &lt; _skrollables.length; skrollableIndex++) {
			skrollable = _skrollables[skrollableIndex];
			keyFrames = skrollable.keyFrames;
</P><P>			for(keyFrameIndex = 0; keyFrameIndex &lt; keyFrames.length; keyFrameIndex++) {
				kf = keyFrames[keyFrameIndex];
</P><P>				if(kf.isEnd) {
					kf.frame = _maxKeyFrame - kf.offset;
				}
			}
		}
	};
</P><P>	/**
	 * Calculates and sets the style properties for the element at the given frame.
	 * @param fakeFrame The frame to render at when smooth scrolling is enabled.
	 * @param actualFrame The actual frame we are at.
	 */
	var _calcSteps = function(fakeFrame, actualFrame) {
		//Iterate over all skrollables.
		for(var skrollableIndex = 0; skrollableIndex &lt; _skrollables.length; skrollableIndex++) {
			var skrollable = _skrollables[skrollableIndex];
			var frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;
			var frames = skrollable.keyFrames;
			var firstFrame = frames[0].frame;
			var lastFrame = frames[frames.length - 1].frame;
			var atFirst = frame &lt;= firstFrame;
			var atLast = frame &gt;= lastFrame;
			var key;
			var value;
</P><P>			//If we are before/after or exactly at the first/last frame, the element gets all props from this key frame.
			if(atFirst || atLast) {
				var props = frames[atFirst ? 0 : frames.length - 1].props;
</P><P>				for(key in props) {
					if(hasProp.call(props, key)) {
						value = _interpolateString(props[key].value);
</P><P>						skrollr.setStyle(skrollable.element, key, value);
					}
				}
</P><P>				//Add the unrendered class when before or after first/last frame.
				if(skrollable[SKROLLABLE_HAS_RENDERED_CLASS_PROPERTY] &amp;&amp; (frame &lt; firstFrame || frame &gt; lastFrame)) {
					_updateClass(skrollable.element, [UNRENDERED_CLASS], [RENDERED_CLASS]);
</P><P>					//Does a faster job than sth. like hasClass('string')
					skrollable[SKROLLABLE_HAS_RENDERED_CLASS_PROPERTY] = false;
				}
</P><P>				continue;
			}
</P><P>			//We are between two frames.
			if(!skrollable[SKROLLABLE_HAS_RENDERED_CLASS_PROPERTY]) {
				_updateClass(skrollable.element, [RENDERED_CLASS], [UNRENDERED_CLASS]);
</P><P>				skrollable[SKROLLABLE_HAS_RENDERED_CLASS_PROPERTY] = true;
			}
</P><P>			//Find out between which two key frames we are right now.
			for(var keyFrameIndex = 0; keyFrameIndex &lt; frames.length - 1; keyFrameIndex++) {
				if(frame &gt;= frames[keyFrameIndex].frame &amp;&amp; frame &lt;= frames[keyFrameIndex + 1].frame) {
					var left = frames[keyFrameIndex];
					var right = frames[keyFrameIndex + 1];
</P><P>					for(key in left.props) {
						if(hasProp.call(left.props, key)) {
							var progress = (frame - left.frame) / (right.frame - left.frame);
</P><P>							//Transform the current progress using the given easing function.
							progress = left.props[key].easing(progress);
</P><P>							//Interpolate between the two values
							value = _calcInterpolation(left.props[key].value, right.props[key].value, progress);
</P><P>							value = _interpolateString(value);
</P><P>							skrollr.setStyle(skrollable.element, key, value);
						}
					}
</P><P>					break;
				}
			}
		}
	};
</P><P>	/**
	 * Renders all elements
	 */
	var _render = function() {
		//We may render something else than the actual scrollbar position.
		var renderTop = _instance.getScrollTop();
</P><P>		//If there's an animation, which ends in current render call, call the callback after rendering.
		var afterAnimationCallback;
		var now = _now();
		var progress;
</P><P>		//Before actually rendering handle the scroll animation, if any.
		if(_scrollAnimation) {
			//It's over
			if(now &gt;= _scrollAnimation.endTime) {
				renderTop = _scrollAnimation.targetTop;
				afterAnimationCallback = _scrollAnimation.done;
				_scrollAnimation = undefined;
			} else {
				//Map the current progress to the new progress using given easing function.
				progress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);
</P><P>				renderTop = (_scrollAnimation.startTop + progress * _scrollAnimation.topDiff) | 0;
			}
</P><P>			_instance.setScrollTop(renderTop);
		}
		//Smooth scrolling only if there's no animation running.
		else {
			var smoothScrollingDiff = _smoothScrolling.targetTop - renderTop;
</P><P>			//The user scrolled, start new smooth scrolling.
			if(smoothScrollingDiff) {
				_smoothScrolling = {
					startTop: _lastTop,
					topDiff: renderTop - _lastTop,
					targetTop: renderTop,
					startTime: _lastRenderCall,
					endTime: _lastRenderCall + SMOOTH_SCROLLING_DURATION
				};
			}
</P><P>			//Interpolate the internal scroll position (not the actual scrollbar).
			if(now &lt;= _smoothScrolling.endTime) {
				//Map the current progress to the new progress using easing function.
				progress = easings.sqrt((now - _smoothScrolling.startTime) / SMOOTH_SCROLLING_DURATION);
</P><P>				renderTop = (_smoothScrolling.startTop + progress * _smoothScrolling.topDiff) | 0;
			}
		}
</P><P>		//In OSX it's possible to have a negative scrolltop, so, we set it to zero.
		if(renderTop &lt; 0) {
			renderTop = 0;
		}
</P><P>		//Did the scroll position even change?
		if(_forceRender || _lastTop !== renderTop) {
			//Remember in which direction are we scrolling?
			_direction = (renderTop &gt;= _lastTop) ? 'down' : 'up';
</P><P>			_forceRender = false;
</P><P>			var listenerParams = {
				curTop: renderTop,
				lastTop: _lastTop,
				maxTop: _maxKeyFrame,
				direction: _direction
			};
</P><P>			//Tell the listener we are about to render.
			var continueRendering = _listeners.beforerender &amp;&amp; _listeners.beforerender.call(_instance, listenerParams);
</P><P>			//The beforerender listener function is able the cancel rendering.
			if(continueRendering !== false) {
				//Now actually interpolate all the styles.
				_calcSteps(renderTop, _instance.getScrollTop());
</P><P>				//Remember when we last rendered.
				_lastTop = renderTop;
</P><P>				if(_listeners.render) {
					_listeners.render.call(_instance, listenerParams);
				}
			}
</P><P>			if(afterAnimationCallback) {
				afterAnimationCallback.call(_instance, false);
			}
		}
</P><P>		_lastRenderCall = now;
	};
</P><P>	/**
	 * Parses the properties for each key frame of the given skrollable.
	 */
	var _parseProps = function(skrollable) {
		//Iterate over all key frames
		for(var keyFrameIndex = 0; keyFrameIndex &lt; skrollable.keyFrames.length; keyFrameIndex++) {
			var frame = skrollable.keyFrames[keyFrameIndex];
			var easing;
			var value;
			var prop;
			var props = {};
</P><P>			var match;
</P><P>			while((match = rxPropValue.exec(frame.props)) !== null) {
				prop = match[1];
				value = match[2];
</P><P>				easing = prop.match(rxPropEasing);
</P><P>				//Is there an easing specified for this prop?
				if(easing !== null) {
					prop = easing[1];
					easing = easing[2];
				} else {
					easing = DEFAULT_EASING;
				}
</P><P>				//Exclamation point at first position forces the value to be taken literal.
				value = value.indexOf('!') ? _parseProp(value) : [value.slice(1)];
</P><P>				//Save the prop for this key frame with his value and easing function
				props[prop] = {
					value: value,
					easing: easings[easing]
				};
			}
</P><P>			frame.props = props;
		}
	};
</P><P>	/**
	 * Parses a value extracting numeric values and generating a format string
	 * for later interpolation of the new values in old string.
	 *
	 * @param val The CSS value to be parsed.
	 * @return Something like [&quot;rgba(?%,?%, ?%,?)&quot;, 100, 50, 0, .7]
	 * where the first element is the format string later used
	 * and all following elements are the numeric value.
	 */
	var _parseProp = function(val) {
		var numbers = [];
</P><P>		//One special case, where floats don't work.
		//We replace all occurences of rgba colors
		//which don't use percentage notation with the percentage notation.
		rxRGBAIntegerColor.lastIndex = 0;
		val = val.replace(rxRGBAIntegerColor, function(rgba) {
			return rgba.replace(rxNumericValue, function(n) {
				return n / 255 * 100 + '%';
			});
		});
</P><P>		//Handle prefixing of &quot;gradient&quot; values.
		//For now only the prefixed value will be set. Unprefixed isn't supported anyway.
		rxGradient.lastIndex = 0;
		val = val.replace(rxGradient, function(s) {
			return theDashedCSSPrefix + s;
		});
</P><P>
		//Now parse ANY number inside this string and create a format string.
		val = val.replace(rxNumericValue, function(n) {
			numbers.push(+n);
			return '{?}';
		});
</P><P>		//Add the formatstring as first value.
		numbers.unshift(val);
</P><P>		return numbers;
	};
</P><P>	/**
	 * Fills the key frames with missing left and right hand properties.
	 * If key frame 1 has property X and key frame 2 is missing X,
	 * but key frame 3 has X again, then we need to assign X to key frame 2 too.
	 *
	 * @param sk A skrollable.
	 */
	var _fillProps = function(sk) {
		//Will collect the properties key frame by key frame
		var propList = {};
		var keyFrameIndex;
</P><P>		//Iterate over all key frames from left to right
		for(keyFrameIndex = 0; keyFrameIndex &lt; sk.keyFrames.length; keyFrameIndex++) {
			_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);
		}
</P><P>		//Now do the same from right to fill the last gaps
</P><P>		propList = {};
</P><P>		//Iterate over all key frames from right to left
		for(keyFrameIndex = sk.keyFrames.length - 1; keyFrameIndex &gt;= 0; keyFrameIndex--) {
			_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);
		}
	};
</P><P>	var _fillPropForFrame = function(frame, propList) {
		var key;
</P><P>		//For each key frame iterate over all right hand properties and assign them,
		//but only if the current key frame doesn't have the property by itself
		for(key in propList) {
			//The current frame misses this property, so assign it.
			if(!hasProp.call(frame.props, key)) {
				frame.props[key] = propList[key];
			}
		}
</P><P>		//Iterate over all props of the current frame and collect them
		for(key in frame.props) {
			propList[key] = frame.props[key];
		}
	};
</P><P>	/**
	 * Calculates the new values for two given values array.
	 */
	var _calcInterpolation = function(val1, val2, progress) {
		//They both need to have the same length
		if(val1.length !== val2.length) {
			throw 'Can\'t interpolate between &quot;' + val1[0] + '&quot; and &quot;' + val2[0] + '&quot;';
		}
</P><P>		//Add the format string as first element.
		var interpolated = [val1[0]];
</P><P>		for(var valueIndex = 1; valueIndex &lt; val1.length; valueIndex++) {
			//That's the line where the two numbers are actually interpolated.
			interpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);
		}
</P><P>		return interpolated;
	};
</P><P>	/**
	 * Interpolates the numeric values into the format string.
	 */
	var _interpolateString = function(val) {
		var valueIndex = 1;
</P><P>		rxInterpolateString.lastIndex = 0;
</P><P>		return val[0].replace(rxInterpolateString, function() {
			return val[valueIndex++];
		});
	};
</P><P>	/**
	 * Set the CSS property on the given element. Sets prefixed properties as well.
	 */
	skrollr.setStyle = function(el, prop, val) {
		var style = el.style;
</P><P>		//Camel case.
		prop = prop.replace(rxCamelCase, rxCamelCaseFn).replace('-', <I>);</I></P><P>		//Make sure z-index gets a &lt;integer&gt;.
		//This is the only &lt;integer&gt; case we need to handle.
		if(prop === 'zIndex') {
			//Floor
			style[prop] = <I> + (val | 0);</I>
		}
		//#64: &quot;float&quot; can't be set across browsers. Needs to use &quot;cssFloat&quot; for all except IE.
		else if(prop === 'float') {
			style.styleFloat = style.cssFloat = val;
		}
		else {
			//Need try-catch for old IE.
			try {
				//Set prefixed property.
				style[theCSSPrefix + prop.slice(0,1).toUpperCase() + prop.slice(1)] = val;
</P><P>				//Set unprefixed.
				style[prop] = val;
			} catch(ignore) {}
		}
	};
</P><P>	/**
	 * Cross browser event handling.
	 */
	var _addEvent = function(name, fn) {
		if(window.addEventListener) {
			window.addEventListener(name, fn, false);
		} else {
			window.attachEvent('on' + name, fn);
		}
	};
</P><P>	/**
	 * Returns a string of space separated classnames for the current element.
	 * Works with SVG as well.
	 */
	var _getClass = function(element) {
		var prop = 'className';
</P><P>		//SVG support by using className.baseVal instead of just className
		if(window.SVGElement &amp;&amp; element instanceof window.SVGElement) {
			element = element[prop];
			prop = 'baseVal';
		}
</P><P>		return element[prop];
	};
</P><P>	/**
	 * Adds and removes a CSS classes.
	 * Works with SVG as well.
	 * add and remove are either arrays of strings,
	 * or if remove is ommited add is a string and overwrites all classes.
	 */
	var _updateClass = function(element, add, remove) {
		var prop = 'className';
</P><P>		//SVG support by using className.baseVal instead of just className
		if(window.SVGElement &amp;&amp; element instanceof window.SVGElement) {
			element = element[prop];
			prop = 'baseVal';
		}
</P><P>		//When remove is ommited, we want to overwrite/set the classes.
		if(remove === undefined) {
			element[prop] = add;
			return;
		}
</P><P>		//Cache current classes. We will work on a string before passing back to DOM.
		var val = element[prop];
</P><P>		//All classes to be added.
		for(var classAddIndex = 0; classAddIndex &lt; add.length; classAddIndex++) {
			//Only add if el not already has class.
			if(_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {
				val += ' ' + add[classAddIndex];
			}
		}
</P><P>		//All classes to be removed.
		for(var classRemoveIndex = 0; classRemoveIndex &lt; remove.length; classRemoveIndex++) {
			val = _untrim(val).replace(_untrim(remove[classRemoveIndex]), ' ');
		}
</P><P>		element[prop] = _trim(val);
	};
</P><P>	var _trim = function(a) {
		return a.replace(rxTrim, '$1');
	};
</P><P>	/**
	 * Adds a space before and after the string.
	 */
	var _untrim = function(a) {
		return ' ' + a + ' ';
	};
</P><P>	var _now = Date.now || function() {
		return +new Date();
	};
</P><P>	var _keyFrameComparator = function(a, b) {
		return a.frame - b.frame;
	};
</P><P>	/*
	 * Private variables.
	 */
</P><P>	//Singleton
	var _instance;
</P><P>	/*
		A list of all elements which should be animated associated with their the metadata.
		Exmaple skrollable with two key frames animating from 100px width to 20px:
</P><P>		skrollable = {
			element: &lt;the DOM element&gt;,
			styleAttr: &lt;style attribute of the element before skrollr&gt;,
			classAttr: &lt;class attribute of the element before skrollr&gt;,
			keyFrames: [
				{
					frame: 100,
					props: {
						width: {
							value: ['{?}px', 100],
							easing: &lt;reference to easing function&gt;
						}
					},
					mode: &quot;absolute&quot;
				},
				{
					frame: 200,
					props: {
						width: {
							value: ['{?}px', 20],
							easing: &lt;reference to easing function&gt;
						}
					},
					mode: &quot;absolute&quot;
				}
			]
		};
	*/
	var _skrollables;
</P><P>	var _listeners;
	var _forceHeight;
	var _maxKeyFrame = 0;
	var _reflow;
</P><P>	var _scale = 1;
	var _constants;
</P><P>	//Current direction (up/down).
	var _direction = 'down';
</P><P>	//The last top offset value. Needed to determine direction.
	var _lastTop = -1;
</P><P>	//The last time we called the render method (doesn't mean we rendered!).
	var _lastRenderCall = _now();
</P><P>	//Will contain data about a running scrollbar animation, if any.
	var _scrollAnimation;
</P><P>	var _smoothScrollingEnabled;
</P><P>	//Will contain settins for smooth scrolling if enabled.
	var _smoothScrolling;
</P><P>	//Can be set by any operation/event to force rendering even if the scrollbar didn't move.
	var _forceRender;
</P><P>	//Each skrollable gets an unique ID incremented for each skrollable.
	//The ID is the index in the _skrollables array.
	var _skrollableIdCounter = 0;
}(window, document));
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:CityU_HK/parallaxscrolling/js">http://2014.igem.org/Team:CityU_HK/parallaxscrolling/js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:CityU_HK/parallaxscrolling/js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:CityU_HK/parallaxscrolling/js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:CityU_HK/parallaxscrolling/js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:CityU_HK/parallaxscrolling/js&amp;oldid=132277" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
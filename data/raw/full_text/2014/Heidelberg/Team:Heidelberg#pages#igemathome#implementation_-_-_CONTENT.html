<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Heidelberg_pages_igemathome_implementation"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Heidelberg/pages/igemathome/implementation">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Heidelberg/pages/igemathome/implementation&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Heidelberg/pages/igemathome/implementation&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Heidelberg/pages/igemathome/implementation&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Heidelberg/pages/igemathome/implementation" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Heidelberg/pages/igemathome/implementation</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><TABLE id="toc" class="toc"><TBODY><TR><TD><DIV id="toctitle"><H2>Contents</H2></DIV><UL><LI class="toclevel-1 tocsection-1"><A href="#Introduction"><SPAN class="tocnumber">1</SPAN><SPAN class="toctext">Introduction</SPAN></A></LI><LI class="toclevel-1"><A href="#General_Concepts_of_the_Boinc_Platform"><SPAN class="tocnumber">2</SPAN><SPAN class="toctext">General Concepts of the Boinc Platform</SPAN></A></LI><LI class="toclevel-2 tocsection-2"><A href="#Encapsulating_multiple_processes_via_Slots"><SPAN class="tocnumber">2.1</SPAN><SPAN class="toctext">Encapsulating multiple processes via Slots</SPAN></A></LI><LI class="toclevel-2 tocsection-3"><A href="#Resolving_file_names_.5BBOINC_Resolving_Files.5D"><SPAN class="tocnumber">2.2</SPAN><SPAN class="toctext">Resolving file names [BOINC Resolving Files]</SPAN></A></LI></UL><LI class="toclevel-1 tocsection-4"><A href="#Bundling"><SPAN class="tocnumber">3</SPAN><SPAN class="toctext">Bundling</SPAN></A></LI><LI class="toclevel-2 tocsection-5"><A href="#Java_Applications"><SPAN class="tocnumber">3.1</SPAN><SPAN class="toctext">Java Applications</SPAN></A></LI><LI class="toclevel-3 tocsection-6"><A href="#JNI_.28Java_Native_Interface.29"><SPAN class="tocnumber">3.1.1</SPAN><SPAN class="toctext">JNI (Java Native Interface)</SPAN></A></LI><LI class="toclevel-3 tocsection-7"><A href="#BoincAPIWrapper"><SPAN class="tocnumber">3.1.2</SPAN><SPAN class="toctext">BoincAPIWrapper</SPAN></A></LI><LI class="toclevel-3 tocsection-8"><A href="#Problems"><SPAN class="tocnumber">3.1.3</SPAN><SPAN class="toctext">Problems</SPAN></A></LI><LI class="toclevel-3 tocsection-9"><A href="#Compilation"><SPAN class="tocnumber">3.1.4</SPAN><SPAN class="toctext">Compilation</SPAN></A></LI><LI class="toclevel-4 tocsection-10"><A href="#Windows"><SPAN class="tocnumber">3.1.4.1</SPAN><SPAN class="toctext">Windows</SPAN></A></LI><LI class="toclevel-4 tocsection-11"><A href="#Linux"><SPAN class="tocnumber">3.1.4.2</SPAN><SPAN class="toctext">Linux</SPAN></A></LI><LI class="toclevel-3 tocsection-12"><A href="#Packaging_the_Java_Runtime"><SPAN class="tocnumber">3.1.5</SPAN><SPAN class="toctext">Packaging the Java Runtime</SPAN></A></LI><LI class="toclevel-2 tocsection-13"><A href="#Python_Applications"><SPAN class="tocnumber">3.2</SPAN><SPAN class="toctext">Python Applications</SPAN></A></LI><LI class="toclevel-3 tocsection-14"><A href="#The_Python_Loader"><SPAN class="tocnumber">3.2.1</SPAN><SPAN class="toctext">The Python Loader</SPAN></A></LI><LI class="toclevel-3 tocsection-15"><A href="#Nuitka"><SPAN class="tocnumber">3.2.2</SPAN><SPAN class="toctext">Nuitka</SPAN></A></LI><LI class="toclevel-3 tocsection-16"><A href="#Static_linking"><SPAN class="tocnumber">3.2.3</SPAN><SPAN class="toctext">Static linking</SPAN></A></LI><LI class="toclevel-2 tocsection-17"><A href="#Creating_portable_executables_for_Linux"><SPAN class="tocnumber">3.3</SPAN><SPAN class="toctext">Creating portable executables for Linux</SPAN></A></LI><LI class="toclevel-1 tocsection-18"><A href="#References"><SPAN class="tocnumber">4</SPAN><SPAN class="toctext">References</SPAN></A></LI></TD></TR></TBODY></TABLE><H2><SPAN class="mw-headline" id="Introduction">Introduction</SPAN></H2><P>Most widely used programming languages in science often have the flaw of dependencies to runtime components that have to be installed on the executing system. For example Python, one of the most prominent programing languages in science, requires the installation of the Python runtime containing all standard functions and the Python interpreter which reads the actual program source code and executes the instructions defined. Without these components a python program cannot be run. Our aim being to enable the distributed execution of our software, these requirements represent a serious flaw. It was required to add components to the software that automatically extract runtime dependencies and pass through the access to essential functions of the BOINC API. As an additional layer of complexity independent from the scientific computation application is added, we decided to implement the functionality enabling portability of applications in a dedicated peace of software, the loader application. This application takes care of solving all dependencies required for the scientific application to run, allowing the simple distribution of python and java applications without having to bother about structural program-language dependencies. As both programing languages are designed for platform independency, the source code written can be used for all main target platforms of the BOINC platform without adaptation.
</P><H2><SPAN class="mw-headline" id="General_Concepts_of_the_Boinc_Platform">General Concepts of the Boinc Platform</SPAN></H2><DIV class="pull-right col-lg-6 col-md-6 col-sm-8 col-xs-12"><DIV class="thumbnail"><DIV class="caption"><SPAN style="font-weight:bold;">Figure 2) File references in the BOINC storage modal</SPAN><P>Diagram of the directory structure used by the BOINC PlatformSource: <A href="http://boinc.berkeley.edu/trac/wiki/BoincFiles">BOINC Wiki</A></P></DIV></DIV></DIV>

BOINC applications are run via the BOINC client, which takes care of the communication with the server, the execution and monitoring of the distributed applications, resource requirement checks for the scientific application and the management of completed jobs. It also offers access to a few of these functions via the BOINC Application Programming Interface, which can be called by scientific applications by compiling against the BOINC API library. The most important concepts when programing BOINC applications are described in detail in the following sections.
<H3><SPAN class="mw-headline" id="Encapsulating_multiple_processes_via_Slots">Encapsulating multiple processes via Slots</SPAN></H3><P>The BOINC client builds up a file structure, which saves the executables, input files and result files into a project directory, separating them from temporary files of the application which are saved in slot directories. The working directory of the application is set to a slot directory, so that files written by relative path do not get overwritten by multiple instances of an application running at the same time. To allow access to the project files, these must be described in templates files of the BOINC system associating the with a logical filename <A href="#References">BOINC Input and output templates</A></P><H3><SPAN class="mw-headline" id="Resolving_file_names_.5BBOINC_Resolving_Files.5D">Resolving file names [BOINC Resolving Files]</SPAN></H3><P>The storage model of the BOINC Platform is based on the requirement of immutable files that are downloaded/uploaded from/to the server. To allow applications to access different input files without requiring a change in the program code, files can be resolved via a logical name. For demonstration, one can imagine an application that takes 2 input files, ‘’input1.txt’’ and ‘’input2.txt’’ and generates an output file, ‘’output.txt’’ from these two. As the input files are different for each job, they cannot be saved under the same filename, because of the BOINC Platform requirements. By defining these files in the BOINC Platform, they can be associated with a logical name (input1.txt, input2.txt and output.txt) while in reality a different filename is accessed after resolving the logical file name to a  value completely independent of the logical filename. This functionality is enabled via the <CODE>boinc_resolve_filename</CODE> API function, which will generate output similar to <CODE>../../projects/igemathome/name_used_for_staging</CODE> referring to corresponding input files in the project directory (see Figure 2).
</P><H2><SPAN class="mw-headline" id="Bundling">Bundling</SPAN></H2><P>This section explains different concepts used and steps required to enable the bundling of a scientific application written in Java or Python with the corresponding runtime dependencies.
</P><H3><SPAN class="mw-headline" id="Java_Applications">Java Applications</SPAN></H3><P>Java applications require the installation of the Java Virtual Machine, which interprets the byte-code created by the Java compiler and executes the appropriate functions. It also delivers the Java Class Library, which enables access to the Standard Library of Java, implementing platform abstraction. To allow these applications to run we wrote a java application launcher based on the javafxpackager. It extracts the Java runtime into the Project folder of the BOINC Application, initializes the Java Virtual Machine and launchers the specified jar containing the scientific application. As Java offers methods for calling native C and C++ code via the Java Native Interface, we utilized this functionality to allow access to the Application Programming Interface of the BOINC Platform. 
</P><H4><SPAN class="mw-headline" id="JNI_.28Java_Native_Interface.29">JNI (Java Native Interface)</SPAN></H4><P>The Java Native Interface allow the execution of Java code initiated from a native application as well as the execution of native code called from Java applications. The former is called the Invocation API and was used to allow the loader to set up a complete Java Virtual Machine. To access the invocation API, the main library (jvm.dll on Windows or jvm.so on Linux) is dynamically loaded in the loader application, allowing to change the Java Runtime version without requiring recompilation of the loader application, making the process more flexible and modularized. The parameters required for the initialization and launch of the JVM are read from a file called <I>package.cfg</I>. The syntax and parameters of this file may be viewed in the provided package.example.cfg file in the deploy folder of the source code.
The latter ability to run native C/C++ code called by Java applications was used to implement an interface to the BOINC Platform API, allowing the use of functions to ease integration into the distributed computation system. To accomplish this, it is required to compile the native program components as shared libraries which then are dynamically loaded by the JVM on the use of native code functions. The source code of these files has to follow a specific structure generated by the program ‘’javah’’, based on a defined Java class containing function definitions prefixed by the ‘’native’’ keyword. These generated header files, can then be used to write implementations of the functions in C/C++ and converting objects to/from Java via access to the JNIEnv structure <A href="#References">[JNI Design overview]</A>.
</P><H4><SPAN class="mw-headline" id="BoincAPIWrapper">BoincAPIWrapper</SPAN></H4><P>The BoincAPIWrapper allows the most important BOINC API functions to be called from Java applications, translating the calls directly into C/C++ applications. The Boinc API functions can be accessed via the class <CODE>org.igemathome.wrapper.BoincApiWrapper</CODE> which contains methods named exactly the same as the C/C++ BOINC Api and thus can be accessed and simply be reading the BOINC API documentation. 
</P><H4><SPAN class="mw-headline" id="Problems">Problems</SPAN></H4><P>After implementing the main methods of the BOINC API via the Java Native Interface we encountered some serious problems. Mainly the applications segfaulted inside the JVM after initializing the BOINC API. After multiple days of searching we realized, that the problem was caused by the redirection of standard Output and standard Error by the <CODE>boinc_init_diagnostics()</CODE> function with rewrote the file descriptor for these outputs. As the JVM did not realize the descriptors were rewritten, it tried to access the old address of the file descriptor resulting in access to memory regions not allocated for the program, thus resulting in Segmentation Faults. We were able to work around these errors by removing all calls to the <CODE>freopen()</CODE> function, yet realized later on that this problem only accrued if the BoincAPIWrapper was called outside of the launcher context via the classic java launcher using the command <CODE>java –jar FILENAME</CODE>. It seems, that the standard Output and standard Error streams are handled differently when using the embedded version of the JVM.
</P><H4><SPAN class="mw-headline" id="Compilation">Compilation</SPAN></H4><P>This section explains how to compile your own version of the Java launcher and package it to a portable binary. The Build system of the Java Launcher is implemented as Makefiles for the compilation under UNIX like operating systems and as Microsoft Visual Studio Project files for Windows Operating Systems. The BOINC source code and an installed Java Development Kit are required for the compilation of the software. For the generation of portable binaries under Linux the usage of the provided change root is recommended (for further information read the section <A href="#Linux_Binary_Compatability">Linux Binary Compatability</A>).
</P><H5><SPAN class="mw-headline" id="Windows">Windows</SPAN></H5><P>The project files for the Windows version of the launcher and BoincAPIWrapper can be found in the path <CODE>src/cpp/launcher/win</CODE> and <CODE>src/cpp/libboincAPIWrapper/win</CODE> in the <A href="/">BOINC Java Wrapper</A>  source code. Probably one must change the paths of the referencing project files in Visual Studio to point to the path of the BOINC source code and edit the include path of the Project to refer to the installation path of the JDK subfolders <CODE>include</CODE> and <CODE>include/win32</CODE>. The Java component of the BoincApiWrapper, can be compiled into a Java Archive (jar) by using standard build instructions for the Java compiler: TODO
</P><H5><SPAN class="mw-headline" id="Linux">Linux</SPAN></H5><P>On Linux the process of compiling is a bit more complex, as a change root should be used for building the program to get portable binaries that run on multiple Linux distributions. Please download the change root appropriate for your platform (32bit or 64bit) via the download link <A href="#Download">below</A>, extract it and follow <A href="https://help.ubuntu.com/community/BasicChroot" class="external text" rel="nofollow">these</A> instructions, yet skipping the steps including <CODE>deboostrap</CODE> and using the provided chroot instead. The Makefile in the project root will automatically compile the native library, compile the Java component of the BoincAPIWrapper and insert them into the Java runtime provided in the <CODE>runtime</CODE> folder. For the Makefiles to run correctly it is required to set two environment variables, then the script may be run:
</P><PRE>
export BOINC_HOME=PATH_TO_BOINC_SOURCE_CODE
export JAVA_HOME=PATH_TO_JAVA_DEVELOPMENT_KIT
make deploy
</PRE><P>This will create the files launcher and runtime.zip in the deploy folder of the source code. In the deploy folder, a example package.cfg is provided. By changing the parameters in the package.cfg, the launcher can then be used to extract the JRE and fire up the provided jar for calculation.
</P><H4><SPAN class="mw-headline" id="Packaging_the_Java_Runtime">Packaging the Java Runtime</SPAN></H4><DIV class="pull-right col-lg-6 col-md-6 col-sm-8 col-xs-12"><DIV class="thumbnail"><PRE>
runtime.zip
    └── runtime
        └── jre
            ├── bin
            │   ├── attach.dll
            │   ├── awt.dll
            │   ├── <SPAN style="color:red;">boincAPIWrapper.dll</SPAN>
            │  ...
            ├── COPYRIGHT
            ├── lib
            │   ├── accessibility.properties
            │   ├── applet
            │  ...
            │   ├── ext
            │   │   ├── access-bridge-32.jar
            │   │   ├── cldrdata.jar
            │   │   ├── dnsns.jar
            │   │   ├── <SPAN style="color:red;">igemathome.jar</SPAN>
            │  ... ...   
            ├── LICENSE
            ├── README.txt
            ├── THIRDPARTYLICENSEREADME.txt
            ├── THIRDPARTYLICENSEREADME-JAVAFX.txt
            └── Welcome.html
</PRE><DIV class="caption"><SPAN style="font-weight:bold;">Figure 3) Directory structure of the Java runtime packaged into a zip file.</SPAN><P>Output shortened, added files for the BoincAPIWrapper highlighted in red</P></DIV></DIV></DIV>

The loader expects the Java Runtime to be located inside a zip file named runtime.zip, this file is resolved via boinc_resolve_filename, to enable the distribution of multiple runtime version. The directory structure of such a zip file is visible in Figure 3, which simply represents a full copy of the jre folder. As highlighted, the compiled files of the BoincAPIWrapper have to be integrated into the right directories for correct functionality. The compiled jar of the BOINC API should be placed into the path <CODE>runtime/jre/lib/ext</CODE> whereas the corresponding native library should be placed at <CODE>runtime/jre/bin</CODE><H3><SPAN class="mw-headline" id="Python_Applications">Python Applications</SPAN></H3><P>Python applications normally require an installed version of the Python runtime. This requirement can be avoided, by either packaging a complete version of the python runtime with the executable or by using the method of &quot;freezing&quot; python files into binary code, and including these files into the executable at compile time. We decided to use the latter method, because of the availability of a tool named Nuitka which automatically recuses through the dependencies of a python application and saves all required files for an application to run into a specified directory and accelerates the execution by 2 folds. After successfully packaging the super secondary structure modelling software Modeller, we later noticed that this process does not work correctly when trying to package applications containing NumPy, a python module required by our linker software CRAUT. For this reason we had to fallback to two different ways of packaging python applications for the distribution via iGEM@home: Packaging via Nuitka and statically linking the python runtime into a loader executable. The following sections explain the principles behind both methods and how we utilized these to enable python application distribution.
</P><H4><SPAN class="mw-headline" id="The_Python_Loader">The Python Loader</SPAN></H4><P>The python loader is written completely from scratch in pure C code, allowing access to the python embedded API. Dependent on the application we bundled the python loader additionally implements a file signature check on files delivered via the BOINC platform. This was required to avoid licensing issue with the Modeller software, as it is only free for academic use. By verifying the files added distributed, we can guarantee that the calculations made are submitted to the application only if the input files are verified by the loader application. 
</P><H4><SPAN class="mw-headline" id="Nuitka">Nuitka</SPAN></H4><P>Nuitka uses a special method to create applications that are independent from the python runtime. The python code is first rewritten into C++ code, implementing large portions of python code directly and thus allowing higher execution speeds. Only functions that cannot be executed in C++ are actually run by the python interpreter. For higher modularization, we extended Nuitka to allow the creation of standalone shared python libraries which then can be loaded via a python loader application. The python loader application still requires a minimal set of available python files to start the embedded python interpreter, yet as soon as the shared library is loaded all no additional dependencies are required independent of the modules used by the python application. This allows stronger separation between the python loader and the scientific calculation application. 
</P><H4><SPAN class="mw-headline" id="Static_linking">Static linking</SPAN></H4><P>To make linker generator CRAUT portable for the BOINC platform, we utilized principles used by a Github project called NumpyBuiltinExample, which provides a script for Linux operating systems that compiles python, numpy and an example application, in the end linking them all together into a single statically linked executable.
</P><H3><SPAN class="mw-headline" id="Creating_portable_executables_for_Linux">Creating portable executables for Linux</SPAN></H3><P>As there are very many different Linux distributions available, the profile of installed libraries on Linux systems is very inhomogeneous. Thus, relying on the existence of libraries on a Linux system will not result in an application that runs on the many different flavors of Linux installations. The dependency to libraries can be prohibited by linking the applications statically, thus copying all relevant parts of code into the executable itself. Yet, there are some libraries that cannot be included in this fashion. Statically linking to the standard C Library for instance, will result in unstable applications, as the C Runtime relies heavily on partly distribution specific file structures. But also linking dynamically to the C-runtime does not solve the issue, as this requires the same or a newer version of the Standard C Library to be installed on the System executing the program. The only way to work around all the above issues, enabling the creation of portable applications is to compile the program against an old version of the Standard C Library and relying on the backwards compatibility of the installed libraries on newer systems. For this reason we provide a package containing Debian squeeze, which uses a relatively old C Library so that portable applications can be compiled in this environment by simply using the Linux command <CODE>chroot</CODE>.
</P><H2><SPAN class="mw-headline" id="References">References</SPAN></H2><P>[JNI Design Overview]  [<A href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html" class="external autonumber" rel="nofollow">[1]</A>]
</P><P>[BOINC Resolving Files] [<A href="http://boinc.berkeley.edu/trac/wiki/BoincFiles" class="external autonumber" rel="nofollow">[2]</A>]
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:Heidelberg/pages/igemathome/implementation">http://2014.igem.org/Team:Heidelberg/pages/igemathome/implementation</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Heidelberg/pages/igemathome/implementation" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Heidelberg/pages/igemathome/implementation" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Heidelberg/pages/igemathome/implementation&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Heidelberg/pages/igemathome/implementation&amp;oldid=293229" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
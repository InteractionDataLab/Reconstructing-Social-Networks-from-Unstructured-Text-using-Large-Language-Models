<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Heidelberg_pages_Linker-Software_Docu"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Heidelberg/pages/Linker-Software_Docu">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Heidelberg/pages/Linker-Software_Docu&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Heidelberg/pages/Linker-Software_Docu&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Heidelberg/pages/Linker-Software_Docu&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Heidelberg/pages/Linker-Software_Docu" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Heidelberg/pages/Linker-Software Docu</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><TABLE id="toc" class="toc"><TBODY><TR><TD><DIV id="toctitle"><H2>Contents</H2></DIV><UL><LI class="toclevel-1 tocsection-1"><A href="#General"><SPAN class="tocnumber">1</SPAN><SPAN class="toctext">General</SPAN></A></LI><LI class="toclevel-2 tocsection-2"><A href="#Usage"><SPAN class="tocnumber">1.1</SPAN><SPAN class="toctext">Usage</SPAN></A></LI><LI class="toclevel-3 tocsection-3"><A href="#Bundeled_version"><SPAN class="tocnumber">1.1.1</SPAN><SPAN class="toctext">Bundeled version</SPAN></A></LI><LI class="toclevel-3 tocsection-4"><A href="#The_python_file"><SPAN class="tocnumber">1.1.2</SPAN><SPAN class="toctext">The python file</SPAN></A></LI></UL><LI class="toclevel-1 tocsection-5"><A href="#Biggest_problems_we_had"><SPAN class="tocnumber">2</SPAN><SPAN class="toctext">Biggest problems we had</SPAN></A></LI><LI class="toclevel-2 tocsection-6"><A href="#RAM_usage"><SPAN class="tocnumber">2.1</SPAN><SPAN class="toctext">RAM usage</SPAN></A></LI><LI class="toclevel-3 tocsection-7"><A href="#Array_Size"><SPAN class="tocnumber">2.1.1</SPAN><SPAN class="toctext">Array Size</SPAN></A></LI><LI class="toclevel-2 tocsection-8"><A href="#Runtime"><SPAN class="tocnumber">2.2</SPAN><SPAN class="toctext">Runtime</SPAN></A></LI><LI class="toclevel-2 tocsection-9"><A href="#Flexible_ends"><SPAN class="tocnumber">2.3</SPAN><SPAN class="toctext">Flexible ends</SPAN></A></LI><LI class="toclevel-2 tocsection-10"><A href="#Path_storage"><SPAN class="tocnumber">2.4</SPAN><SPAN class="toctext">Path storage</SPAN></A></LI><LI class="toclevel-2 tocsection-11"><A href="#Differences_in_proteins"><SPAN class="tocnumber">2.5</SPAN><SPAN class="toctext">Differences in proteins</SPAN></A></LI><LI class="toclevel-1 tocsection-12"><A href="#Different_definitions"><SPAN class="tocnumber">3</SPAN><SPAN class="toctext">Different definitions</SPAN></A></LI><LI class="toclevel-2 tocsection-13"><A href="#Protein_data"><SPAN class="tocnumber">3.1</SPAN><SPAN class="toctext">Protein data</SPAN></A></LI><LI class="toclevel-2 tocsection-14"><A href="#List_of_angles_and_rods"><SPAN class="tocnumber">3.2</SPAN><SPAN class="toctext">List of angles and rods</SPAN></A></LI><LI class="toclevel-2 tocsection-15"><A href="#General_definitions"><SPAN class="tocnumber">3.3</SPAN><SPAN class="toctext">General definitions</SPAN></A></LI><LI class="toclevel-1 tocsection-16"><A href="#Functions"><SPAN class="tocnumber">4</SPAN><SPAN class="toctext">Functions</SPAN></A></LI><LI class="toclevel-2 tocsection-17"><A href="#imported_python_modules"><SPAN class="tocnumber">4.1</SPAN><SPAN class="toctext">imported python modules</SPAN></A></LI><LI class="toclevel-3 tocsection-18"><A href="#necessary"><SPAN class="tocnumber">4.1.1</SPAN><SPAN class="toctext">necessary</SPAN></A></LI><LI class="toclevel-3 tocsection-19"><A href="#recommended"><SPAN class="tocnumber">4.1.2</SPAN><SPAN class="toctext">recommended</SPAN></A></LI><LI class="toclevel-2 tocsection-20"><A href="#selfwritten_functions"><SPAN class="tocnumber">4.2</SPAN><SPAN class="toctext">selfwritten functions</SPAN></A></LI><LI class="toclevel-3 tocsection-21"><A href="#angle_between_connections_array.28startingarray.2C_middlearray.2C_endingarray.29:"><SPAN class="tocnumber">4.2.1</SPAN><SPAN class="toctext">angle_between_connections_array(startingarray, middlearray, endingarray):</SPAN></A></LI><LI class="toclevel-3 tocsection-22"><A href="#angle_between_vectors.28vect1.2C_vect2.29:"><SPAN class="tocnumber">4.2.2</SPAN><SPAN class="toctext">angle_between_vectors(vect1, vect2):</SPAN></A></LI><LI class="toclevel-3 tocsection-23"><A href="#distance_from_connection.28Startarray.2C_Endarray.2C_Points.29:"><SPAN class="tocnumber">4.2.3</SPAN><SPAN class="toctext">distance_from_connection(Startarray, Endarray, Points):</SPAN></A></LI><LI class="toclevel-3 tocsection-24"><A href="#punktebeigerade.28minabstand.2C_pkte.2C_gerade.2C_aufpunkt.2C_laenge.29:"><SPAN class="tocnumber">4.2.4</SPAN><SPAN class="toctext">punktebeigerade(minabstand, pkte, gerade, aufpunkt, laenge):</SPAN></A></LI><LI class="toclevel-3 tocsection-25"><A href="#test_accessible_angles.28winkelarray.2C_length.2C_anfangspunkt.2C_proteinpoints.2C_gerade.3Dnp.array.28.5B0.2C_0.2C_1.5D.29.29:"><SPAN class="tocnumber">4.2.5</SPAN><SPAN class="toctext">test_accessible_angles(winkelarray, length, anfangspunkt, proteinpoints, gerade=np.array([0, 0, 1])):</SPAN></A></LI><LI class="toclevel-3 tocsection-26"><A href="#reduce_angles_from_redundancies.28winkelarray.29:"><SPAN class="tocnumber">4.2.6</SPAN><SPAN class="toctext">reduce_angles_from_redundancies(winkelarray):</SPAN></A></LI><LI class="toclevel-3 tocsection-27"><A href="#make_displacements.28lengtharray.2C_displacementarray.29:"><SPAN class="tocnumber">4.2.7</SPAN><SPAN class="toctext">make_displacements(lengtharray, displacementarray):</SPAN></A></LI><LI class="toclevel-3 tocsection-28"><A href="#sort_out_by_protein.28startingarray.2C_endingarray.2C_proteinpoints.2C_mindist.2C_beforearray_.3D_None.29:"><SPAN class="tocnumber">4.2.8</SPAN><SPAN class="toctext">sort_out_by_protein(startingarray, endingarray, proteinpoints, mindist, beforearray = None):</SPAN></A></LI><LI class="toclevel-3 tocsection-29"><A href="#naechstepunkte.28anfangsarray.2C_verschiebungsarray.29:"><SPAN class="tocnumber">4.2.9</SPAN><SPAN class="toctext">naechstepunkte(anfangsarray, verschiebungsarray):</SPAN></A></LI><LI class="toclevel-3 tocsection-30"><A href="#aussortierennachpunken.28punktearray.2C_proteinpunkte.2C_minabstand.2C_maxabstand.29:"><SPAN class="tocnumber">4.2.10</SPAN><SPAN class="toctext">aussortierennachpunken(punktearray, proteinpunkte, minabstand, maxabstand):</SPAN></A></LI><LI class="toclevel-3 tocsection-31"><A href="#angle_weighing.28anglearray.2C_angletosequence.3Dangletosequence.29:"><SPAN class="tocnumber">4.2.11</SPAN><SPAN class="toctext">angle_weighing(anglearray, angletosequence=angletosequence):</SPAN></A></LI><LI class="toclevel-3 tocsection-32"><A href="#angle_function.28StartingArray.2C_MiddleArray.2C_EndingArray.29:"><SPAN class="tocnumber">4.2.12</SPAN><SPAN class="toctext">angle_function(StartingArray, MiddleArray, EndingArray):</SPAN></A></LI><LI class="toclevel-3 tocsection-33"><A href="#unpreferable_places.28Start.2C_End.2C_ProteinPoints.2C_AminoacidNumberArray.2C_ToBeWeighedAAInput.2C_WeighingofAA.2C_substratelist.29:"><SPAN class="tocnumber">4.2.13</SPAN><SPAN class="toctext">unpreferable_places(Start, End, ProteinPoints, AminoacidNumberArray, ToBeWeighedAAInput, WeighingofAA, substratelist):</SPAN></A></LI><LI class="toclevel-3 tocsection-34"><A href="#distance_from_surface.28beforearray.2C_testarray.2C_ProteinPoints.2C_Afterpoint_.3D_None.29:"><SPAN class="tocnumber">4.2.14</SPAN><SPAN class="toctext">distance_from_surface(beforearray, testarray, ProteinPoints, Afterpoint = None):</SPAN></A></LI><LI class="toclevel-3 tocsection-35"><A href="#weighing_function_rigids.28StartPoint.2C_FirstArray.2C_SecondArray.2C_ThirdArray.2C_EndPoint.2C_ProteinPoints.2CAminoacidNumberArray.2C_ToBeWeighedAA.2C_WeighingofAA.3DNone.2C_substratelist.3DNone.29:"><SPAN class="tocnumber">4.2.15</SPAN><SPAN class="toctext">weighing_function_rigids(StartPoint, FirstArray, SecondArray, ThirdArray, EndPoint, ProteinPoints,AminoacidNumberArray, ToBeWeighedAA, WeighingofAA=None, substratelist=None):</SPAN></A></LI><LI class="toclevel-3 tocsection-36"><A href="#weighing_function_flex.28StartPoint.2C_FirstArray.2C_SecondArray.2C_ThirdArray.2C_EndPoint.2C_ProteinPoints.2C_AminoacidNumberArray.2C_ToBeWeighedAA.2C_WeighingofAA_.3D_None.2C_substratelist_.3D_None.29:"><SPAN class="tocnumber">4.2.16</SPAN><SPAN class="toctext">weighing_function_flex(StartPoint, FirstArray, SecondArray, ThirdArray,  EndPoint, ProteinPoints, AminoacidNumberArray,  ToBeWeighedAA, WeighingofAA = None, substratelist = None):</SPAN></A></LI><LI class="toclevel-3 tocsection-37"><A href="#make_weighingarrays.28Userstring.29:"><SPAN class="tocnumber">4.2.17</SPAN><SPAN class="toctext">make_weighingarrays(Userstring):</SPAN></A></LI><LI class="toclevel-3 tocsection-38"><A href="#sort_out_by_angle_.28startingarray.2C_middlearray.2C_endingarray.2C_angletosequence.29:"><SPAN class="tocnumber">4.2.18</SPAN><SPAN class="toctext">sort_out_by_angle (startingarray, middlearray, endingarray, angletosequence):</SPAN></A></LI><LI class="toclevel-3 tocsection-39"><A href="#make_small_generator.28PointArray.2C_repetition.2C_RAM.2C_tobesplitlength.2C_ProteinArray_.3D_None.29:"><SPAN class="tocnumber">4.2.19</SPAN><SPAN class="toctext">make_small_generator(PointArray, repetition, RAM, tobesplitlength, ProteinArray = None):</SPAN></A></LI><LI class="toclevel-3 tocsection-40"><A href="#make_small_generator_offset.28listofarraysinRAM.2C_PointArray.2C_repetition.2C_RAM.2C_tobesplitlength.2C_ProteinArray_.3D_None.29:"><SPAN class="tocnumber">4.2.20</SPAN><SPAN class="toctext">make_small_generator_offset(listofarraysinRAM, PointArray, repetition, RAM, tobesplitlength,  ProteinArray = None):</SPAN></A></LI><LI class="toclevel-3 tocsection-41"><A href="#sort_out_by_distance.28startingpoints.2C_endingpoints.2C_firstpoints.2C_distance.2C_variation.29:"><SPAN class="tocnumber">4.2.21</SPAN><SPAN class="toctext">sort_out_by_distance(startingpoints, endingpoints, firstpoints, distance, variation):</SPAN></A></LI><LI class="toclevel-3 tocsection-42"><A href="#sort_out_by_length_.28comefrompoints.2C_gotopoints.2C_linkerlaengen.29:"><SPAN class="tocnumber">4.2.22</SPAN><SPAN class="toctext">sort_out_by_length (comefrompoints, gotopoints, linkerlaengen):</SPAN></A></LI><LI class="toclevel-3 tocsection-43"><A href="#length_to_sequence.28lengtharray.2C_linkerdatenbank.2C_linkerlaengen.29:"><SPAN class="tocnumber">4.2.23</SPAN><SPAN class="toctext">length_to_sequence(lengtharray, linkerdatenbank, linkerlaengen):</SPAN></A></LI><LI class="toclevel-3 tocsection-44"><A href="#angle_to_sequence.28anglearray.2C_angletosequence.2C_angleseparators.29:"><SPAN class="tocnumber">4.2.24</SPAN><SPAN class="toctext">angle_to_sequence(anglearray, angletosequence, angleseparators):</SPAN></A></LI><LI class="toclevel-3 tocsection-45"><A href="#translate_paths_to_sequences.28startpoint.2C_firstflex.2C_secondflex.2C_thirdflex.2C_firstrig.2C_secondrig.2C_thirdrig.2C_endpoint.2C_linkerdb.2C_linkerlKO.2C_angletosequence.2C_angleseparators.2C_weightflex.2C_weightrig.29:"><SPAN class="tocnumber">4.2.25</SPAN><SPAN class="toctext">translate_paths_to_sequences(startpoint, firstflex, secondflex, thirdflex, firstrig, secondrig, thirdrig, endpoint, linkerdb, linkerlKO, angletosequence, angleseparators, weightflex, weightrig):</SPAN></A></LI></TD></TR></TBODY></TABLE><H1><SPAN class="mw-headline" id="General">General</SPAN></H1><P>During the iGEM competition we have written a software, that can predict the best linker to circularize a protein.  At first, connections between the ends of proteins are found, these are weighted on their quality for the linker and then these paths are retranslated to biological sequences.
The software is mainly made possible by python's numpy package for easily handling and processing huge amount of data. Numpy is one of the most used python packages in scientific computing, providing a powerful N-dimensional array object and fast C/C++ written functions to process them. Thus we were able to handle the huge amount of different linker paths (in the scale of 10^9 paths).   
Python, as a high level programming language with its various packages, enabled us to write such a powerfull software within the short time period of this years iGEM competition. Being an interpreter language, python's runtime of course is much higher. As python is able to integrate fast C-Code natively, the runtime of Numpy calculations is not that much higher than compared to classical precompiled C-code. This is achieved by using the same type of entries in an array, so that the whole array can be processed  at once. On the other hand this consumes much more memory, since the whole array has to be loaded in the RAM in every processing step, causing one of the major problems for us. Therefore, the software requires at least 2 GB of free RAM.
</P><H2><SPAN class="mw-headline" id="Usage">Usage</SPAN></H2><P>Two different versions can be downloaded. One is a bundeled version with reduced features, but enhanced usability. The other is the source code, where in the beginning definitions need to be made in the code, giving the full usability at hand of the user. If not all features are needed, we recommend using the reduced version. The bundeled version can be used only on linux PCs.
Both versions require minimum 2GB of free RAM.  
</P><H3><SPAN class="mw-headline" id="Bundeled_version">Bundeled version</SPAN></H3><P>Please download CRAUT from <A href="https://github.com/igemsoftware/Heidelberg_2014" class="external text" rel="nofollow">here </A>here. You only need to add the protein structure file in PDB format and an instructions file. For detailed information please see the README in the folder.
</P><P>The bundeled version is nicer accessible more user friendly, butdoes not provide full usability. Mainly, it is missing adjustability. Some functions that can not be used are:
</P><P>Weighting of different aminoacids: A function, which allows you to define aminoacids and regions that should be omitted by the linker.
</P><P>Checkpointing: The program has to run in total at once, it can not be stopped  during the calculation, because no files are stored during computation. Calculations can take up to days.
</P><P>Size of linkers: As no checkpointing is enabled in this version, also the maximum angles are reduced to two angles in the linker. This shold be sufficient for most proteins. but If this does not produce results, please refer to the python version from the website.
</P><P>Circularizing only a part of the protein: The complete protein, provided by the PDB file is circularized, in contrast to the the complete version, where the user can define the amino acid site  where the protein circularization should occure.
</P><P>Ignoring different parts of proteins: It is not possible to ignore additional parts of the PDB. Only the defined subunit will be processed, other subunis are ignored.
</P><P>Attachment-Sequences: The exchange of attachment-sequences (normally GG in the beginning of the linker) has to be done manually.
</P><H3><SPAN class="mw-headline" id="The_python_file">The python file</SPAN></H3><P>For this version you need a running python 2.7 environment, please see below on the used packages. Please download the .py file from <A href="#.23.23here.23.23.23">###here###</A> and insert the data in the header of the code to the different variables.
</P><P>Two folders have to be creaded in the same directory as  the python program is running, one named &quot;files&quot;, in which checkpoints are saved, and one called &quot;protein&quot;, which contains the PDB file.
</P><P>There can be made several choices on which parts of the protein should be taken into account for circularization and with which sequences this should be done. The extein sequence or the sortase scar should be inserted at ScarsAtEnd variable.
Also a weighting of certain amino acids can be defined in the beginning.
</P><P>The software will store temporary data  after reaching a processing checkpoint so that calculation can be resumed afterwards again.  The code is split in different procedures, that can be run in IDEs like <A href="https://pythonhosted.org/spyder/overview.html" class="external text" rel="nofollow">spyder </A> separately. Each of these sections defines a piece of code, 
</P><P>One 
Afterwards the calculations can just be resumed at one of the various pickle.load  checkpoints.
</P><P>For most proteins, not too many paths need to be checked, which results to a runtime of  so it runs in several hours on a 2.6GHz intel i5. The software might calculate several days for the linkers. For big proteins and long linkers, about 8 GB of RAM are needed to run completely. But for
</P><P>In the end a single results file is saved on the disk, containing the sequnces of the linkers and the weightings of them.
</P><H1><SPAN class="mw-headline" id="Biggest_problems_we_had">Biggest problems we had</SPAN></H1><P>We encountered many bigger or smaller problems while programming. Some are quite serious issues and are mainly due to the brute force approach ansatz we made, but were mainly solved to an acceptable extent. 
</P><H2><SPAN class="mw-headline" id="RAM_usage">RAM usage</SPAN></H2><P>For example w The calculation of the distance from the connection in a path to the protein is calculated, encompasses always the distance of all of the atoms of the protein to this connection. This easily results in arrays of 100 000 000 * 3 * 6000 * 3 shape can occur, which is just too much for normal RAM sized Computer. 
</P><P>On the other hand, using numpy arrays, the bigger the processed arrays are , the faster the program is in total, because every functions only have to be loaded once .  Therefore in each step the arrays are sliced in a way, that the following procedure can take place in the RAM of the computer, see <A href="#make_small_generator_offset.28listofarraysinRAM.2C_PointArray.2C_repetition.2C_RAM.2C_tobesplitlength.2C_ProteinArray_.3D_None.29:">functions</A> part.
</P><H3><SPAN class="mw-headline" id="Array_Size">Array Size</SPAN></H3><P>Arrays with about 300 000 000 float 16 entries, like they occur for large proteins,  while <A href="/wiki/index.php?title=Software-representation&amp;action=edit&amp;redlink=1" class="new" title="Software-representation (page does not exist)">point generation</A> are too large in size for the RAM. Thus we had to manually store  them on the harddrive for processing. Of course also this slowed the  procedure down. But fortunately we could use python's <A href="http://www.h5py.org/" class="external text" rel="nofollow">|h5py</A> package,  which allowed us, just taking out certain lines from the array stored on  the disk.
</P><H2><SPAN class="mw-headline" id="Runtime">Runtime</SPAN></H2><P>The longest calculation took about 11days on a 2.6 GHz intel i5 CPU with 8GB RAM and an SSD harddrive. Therefore, results are frequently stored on the harddisk using python's <A href="#cpickle">cpickle</A> package, which allows a fast storage of complete numpy objects. Thus calculations can be stopped and restarted after certain points.
On the other hand, calculation time increases with the number of points for the connections and for the protein. Reducing the points of the protein to the atoms on the surface would be the next step to take, which could reduce calculation time to one sixth of the time now.
Due to lack of time, we often had to make the tradeoff between fast programming and fast calculation. Having the huge resources of <A href="/wiki/index.php?title=IGEM@home&amp;action=edit&amp;redlink=1" class="new" title="IGEM@home (page does not exist)">###i@h###</A> we clearly decided for fast programming and not optimizing the code yet for velocity.
</P><H2><SPAN class="mw-headline" id="Flexible_ends">Flexible ends</SPAN></H2><P>Long flexible (non helical) regions might cause problems until now are kind of an issue, but we have implemented several functions that should handle those. The problem is, that tThe number of possible conformations of  two or three OF WHAT? exceedes our capabilities and could not be easily handeled in the building-block system we choose to implement. Therefore also helical regions are handeled as straight connections, but with varying length. After the flexible regions there are no angular restraints given to the attached helical block.
</P><H2><SPAN class="mw-headline" id="Path_storage">Path storage</SPAN></H2><P>The  possible paths are always stored as the angle points of the paths under following variables: firstpointsflexible, secondpointsflexible,  thirdpointsflexible, firstpointstriangle, secondpointstriangle,  thirdpointstriangle, erstepunkte, zweitepunkte and drittepunkte. As each point in 3d has three coordinates, all of these variables are n*3  arrays. The first index identifies the path then. This creates the possibility it  possible, that a path is just deleted, to erase a path by deleting the line of all the  arrays. This way also the arrays can be easily sliced, making it  possible to process parts of an array in a fast way.
</P><H2><SPAN class="mw-headline" id="Differences_in_proteins">Differences in proteins</SPAN></H2><P>Proteins can differ widely in their size and sometimes even in their definition in the PDB files. It was a big issue we encountered in setting up to set up a stable version running with all these different PDBs varying in size by the factor of 20.
</P><H1><SPAN class="mw-headline" id="Different_definitions">Different definitions</SPAN></H1><H2><SPAN class="mw-headline" id="Protein_data">Protein data</SPAN></H2><P>In  the PDB file, all coordinates of non-hydrogen atoms are stored. These are then loaded into arrays x, y and z, just containing one coordinate of each a point. these are arrays of length n. Since this kind of array is  complicated to  handle, the information is restored in different point arrays of shape  n*3.
</P><UL><LI>PointsOfAllSubunits:  These are all points from the PDB file, that should not be ignored. The user has to decide, which parts of the protein should not be taken into  account.
</LI></UL><UL><LI>pkte:  These are all the points of part ???, that should be circularized, so this are all the atom-coordinates between N- and C-terminus
</LI></UL><UL><LI>OtherPoints: These are all points of PointsOfAllSubunits that are not in pkte.
</LI></UL><H2><SPAN class="mw-headline" id="List_of_angles_and_rods">List of angles and rods</SPAN></H2><P>Rods: &quot;AEAAAK&quot;, &quot;AEAAAKA&quot;, &quot;AEAAAKAA&quot;, &quot;AEAAAKEAAAK&quot;,  &quot;AEAAAKEAAAKA&quot;, &quot;AEAAAKEAAAKEAAAKA&quot;, &quot;AEAAAKEAAAKEAAAKEAAAKA&quot;,  &quot;AEAAAKEAAAKEAAAKEAAAKEAAAKA&quot;
</P><P>Angles,  alwys mean, then std and the pattern: [(29.7, 8.5, &quot;NVL&quot;), (38.7, 30.,  &quot;KTA&quot;),  (60., 12., &quot;AADGTL&quot;), (74.5, 27., &quot;VNLTA&quot;),  (117., 12.,  &quot;AAAHPEA&quot;), (140., 15., &quot;ASLPAA&quot;), (160., 5., &quot;ATGDLA&quot;)]
</P><H2><SPAN class="mw-headline" id="General_definitions">General definitions</SPAN></H2><UL><LI>minabstand: the radius of an alpha-helix, also the minimal distance an atom needs from a connection
</LI></UL><UL><LI>LengthOfAngle: The distance between the end of an angle pattern and the geometrical turning point. 
</LI></UL><UL><LI>LengthOfFlexibleAA: 3.5 Å</LI></UL><UL><LI>FlexAtStartSeq and FlexAtEndSeq: This is not only the regions missing from the PDB on both sides, but are also the flexible endsof the linker and the extein on the other side.
</LI></UL><H1><SPAN class="mw-headline" id="Functions">Functions</SPAN></H1><H2><SPAN class="mw-headline" id="imported_python_modules">imported python modules</SPAN></H2><H3><SPAN class="mw-headline" id="necessary">necessary</SPAN></H3><P>numpy: the basic module for numerical calculations in large scale
h5py: Storing arrays on the harddisk, allowes slicing of the arrays on the disk.
os: Used for reading and writing files
sys: module used for exiting the program at certain points.
</P><H3><SPAN class="mw-headline" id="recommended">recommended</SPAN></H3><P>matplotlib.pyplot: can be used for what
from mpl_toolkits.mplot3d,  Axes3D: for what
time: is nedd to see the progression of the calculations and observe the calculation times.
fnmatch: allows wildcard search in strings, important for finding specific linker patterns
cPickle: used for intermediate storing of the arrays, so that calculations coul be continued after restarting the program.
</P><H2><SPAN class="mw-headline" id="selfwritten_functions">selfwritten functions</SPAN></H2><H3><SPAN class="mw-headline" id="angle_between_connections_array.28startingarray.2C_middlearray.2C_endingarray.29:">angle_between_connections_array(startingarray, middlearray, endingarray):</SPAN></H3><DL><DD>    calculates the angles between the vectors from startingarray to middlearray and middlearray to endingarray. If there is no displacement between the arrays it returns zero as angle. startingarray and endingarray can be only one single point, middlearray should always be an array of points in 3d space.
</DD><DD>   returns values between [0,pi] in an array of size Startarray.
</DD></DL><H3><SPAN class="mw-headline" id="angle_between_vectors.28vect1.2C_vect2.29:">angle_between_vectors(vect1, vect2):</SPAN></H3><DL><DD> calculates the angle between two arrays of vectors. If one of the vectors  is 0, the angle is set to 0. The result is based on arccos.
</DD><DD> returns the angles between two vectors.
</DD></DL><H3><SPAN class="mw-headline" id="distance_from_connection.28Startarray.2C_Endarray.2C_Points.29:">distance_from_connection(Startarray, Endarray, Points):</SPAN></H3><DL><DD>takes a connection from Startarray to Endarray and calculates the perpendicular distance of the points from the connection. Startarray or Endarray can also be single points.
</DD><DD>returns an array of size (Startarray * points) with all perpendicular distances or distances of the endpoints.
</DD></DL><H3><SPAN class="mw-headline" id="punktebeigerade.28minabstand.2C_pkte.2C_gerade.2C_aufpunkt.2C_laenge.29:">punktebeigerade(minabstand, pkte, gerade, aufpunkt, laenge):</SPAN></H3><DL><DD>checks whether there are points too close to a straight line coming from aufpunkt with in direction of gerade with length laenge.
</DD><DD>returns True if no point of pkte is closer to the straight line than minabstand
</DD></DL><H3><SPAN class="mw-headline" id="test_accessible_angles.28winkelarray.2C_length.2C_anfangspunkt.2C_proteinpoints.2C_gerade.3Dnp.array.28.5B0.2C_0.2C_1.5D.29.29:">test_accessible_angles(winkelarray, length, anfangspunkt, proteinpoints, gerade=np.array([0, 0, 1])):</SPAN></H3><DL><DD> winkelarray is an array of angles that should be checked, whether they are accessible from anfangspunkt. Accessible means that no point of proteinpoints is too close to the straight line, which is produced by rotating gerade with the angles of winkelarray. Gerade always starts at anfangspunkt angles are measured from z-axis, if gerade is not defined else.
</DD><DD>returns a boolean array with which winkelarray can be sliced.
</DD></DL><H3><SPAN class="mw-headline" id="reduce_angles_from_redundancies.28winkelarray.29:">reduce_angles_from_redundancies(winkelarray):</SPAN></H3><DL><DD>takes an array of angles in the format [phi, theta] and looks which angles produce the same result in the vector.
</DD><DD>returns an array with all indices, that can be deleted along the 0 axis of winkelarray.
</DD></DL><H3><SPAN class="mw-headline" id="make_displacements.28lengtharray.2C_displacementarray.29:">make_displacements(lengtharray, displacementarray):</SPAN></H3><DL><DD>generates all possible displacements from displacementarray (an array of  vectors) and lengtharray (array of different lengths)
</DD><DD>returns an array with displacementvectors in different lengths
</DD></DL><H3><SPAN class="mw-headline" id="sort_out_by_protein.28startingarray.2C_endingarray.2C_proteinpoints.2C_mindist.2C_beforearray_.3D_None.29:">sort_out_by_protein(startingarray, endingarray, proteinpoints, mindist, beforearray = None):</SPAN></H3><DL><DD>sorts out the connections between startingarray and endingarray with proteinpoints. A connection is sorted out, if one point of the proteinpoints is nearer to the connection, than mindist.
</DD><DD>returns only the points for the connections, that are good. If beforearray is set, returns also beforearray
</DD></DL><H3><SPAN class="mw-headline" id="naechstepunkte.28anfangsarray.2C_verschiebungsarray.29:">naechstepunkte(anfangsarray, verschiebungsarray):</SPAN></H3><DL><DD>generates for each point of anfangsarray, all points that are made by displacements of that point with verschiebungsarray.
</DD><DD>returns two arrays of equal size, the enlarged anfangsarray and the array resulting from verschiebungsarray.
</DD></DL><H3><SPAN class="mw-headline" id="aussortierennachpunken.28punktearray.2C_proteinpunkte.2C_minabstand.2C_maxabstand.29:">aussortierennachpunken(punktearray, proteinpunkte, minabstand, maxabstand):</SPAN></H3><DL><DD>sorts all the points of punktearray out, that are nearer than minabstand to one of the points from proteinpunkte, or farther away than maxabstand.
</DD></DL><DL><DD>returns a boolean array, with which one can slice punktearray.
</DD></DL><H3><SPAN class="mw-headline" id="angle_weighing.28anglearray.2C_angletosequence.3Dangletosequence.29:">angle_weighing(anglearray, angletosequence=angletosequence):</SPAN></H3><DL><DD>weighting of the angles form anglearray. The better an angle fits to the angles provided by angletosequence, the lower the value is. The best angle gets a weighing of 1, the worst angle of 2. 
</DD><DD>returns a weighingarray for the angles of anglearray. Each weighing is in the range between 1 and 2. The weighing is based on gaussian distributions.
</DD></DL><H3><SPAN class="mw-headline" id="angle_function.28StartingArray.2C_MiddleArray.2C_EndingArray.29:">angle_function(StartingArray, MiddleArray, EndingArray):</SPAN></H3><DL><DD>makes a weighing of the connection from Startingarray, over Middlearray to Endingarray based on the weighing of the angles.
</DD><DD>returns an angle weighting for each connection.
</DD></DL><H3><SPAN class="mw-headline" id="unpreferable_places.28Start.2C_End.2C_ProteinPoints.2C_AminoacidNumberArray.2C_ToBeWeighedAAInput.2C_WeighingofAA.2C_substratelist.29:">unpreferable_places(Start, End, ProteinPoints, AminoacidNumberArray, ToBeWeighedAAInput, WeighingofAA, substratelist):</SPAN></H3><DL><DD>Calculates a weighting for the connection from the points of Start to the points of End based on the distance from regions that should be omitted. These aminoacids should be defined in the ToBeWeighedAAInput array and the WeighingofAA array defines how important this region is. If one wants whole substrates to be omitted, they should be added in the substratelist. The total returned number is normalized, so the weighting of the regions is independent of the number of places, that should be omitted.
</DD></DL><DL><DD>Parameters:
</DD><DD>Start: The points where the rod starts,
</DD><DD>End: The points where the rod ends
</DD><DD>ProteinPoints: The points of the protein, that should be taken into account.
</DD><DD>AminoacidNumberArray: The array, that tells, to which amino acid one atom belongs
</DD><DD>ToBeWeighedAAInput: One output of make_weighing_arrays
</DD><DD>substratelist: A list of tuples (amino acid nr, size of substrate). Amino acid nr, is the amino acid, where the substrate binds to.
</DD></DL><DL><DD>returns the weighing of the connections, because of the regions, where the linker passes through.
</DD></DL><H3><SPAN class="mw-headline" id="distance_from_surface.28beforearray.2C_testarray.2C_ProteinPoints.2C_Afterpoint_.3D_None.29:">distance_from_surface(beforearray, testarray, ProteinPoints, Afterpoint = None):</SPAN></H3><DL><DD>calculates the distances of the testarray points from the surface as just the minimum of the distances to all proteinpoints. It doesn't calculate the points that are equal to the points of the beforearray, so that these are not taken twice. Additionally, it checks that the points don't lie on the endpoint.
</DD></DL><DL><DD>Returns the weighting of the distance by subtracting mindist, dividing it through mindist for making it unitless and then squaring, so that the values are better distributed. 
</DD></DL><H3><SPAN class="mw-headline" id="weighing_function_rigids.28StartPoint.2C_FirstArray.2C_SecondArray.2C_ThirdArray.2C_EndPoint.2C_ProteinPoints.2CAminoacidNumberArray.2C_ToBeWeighedAA.2C_WeighingofAA.3DNone.2C_substratelist.3DNone.29:">weighing_function_rigids(StartPoint, FirstArray, SecondArray, ThirdArray, EndPoint, ProteinPoints,AminoacidNumberArray, ToBeWeighedAA, WeighingofAA=None, substratelist=None):</SPAN></H3><DL><DD>makes the weighting of rigid linkers, with angle, distance, length and regions distribution.
</DD><DD>returns a list of 5 arrays: weighedvalue, normed lenghtweighing, Angleweighing, Siteinfluence and the distances
</DD></DL><H3><SPAN class="mw-headline" id="weighing_function_flex.28StartPoint.2C_FirstArray.2C_SecondArray.2C_ThirdArray.2C_EndPoint.2C_ProteinPoints.2C_AminoacidNumberArray.2C_ToBeWeighedAA.2C_WeighingofAA_.3D_None.2C_substratelist_.3D_None.29:">weighing_function_flex(StartPoint, FirstArray, SecondArray, ThirdArray,  EndPoint, ProteinPoints, AminoacidNumberArray,  ToBeWeighedAA, WeighingofAA = None, substratelist = None):</SPAN></H3><DL><DD>makes the weighting of flexible linkers, with angle, distance, length and regions distribution.
</DD><DD>returns a list of 5 arrays: weighedvalue, normed lenghtweighing, Angleweighing, Siteinfluence and the distances
</DD></DL><H3><SPAN class="mw-headline" id="make_weighingarrays.28Userstring.29:">make_weighingarrays(Userstring):</SPAN></H3><DL><DD>Userstring is of the shape: 273,10 280-290,5 298,7,35.6  etc. (spaces separate entries, &quot;,&quot; is for single residues &quot;-&quot; for anges, second &quot;,&quot; for the diameter of the substrate)
</DD></DL><DL><DD>If nothing should be weighted, insert &quot;&quot;
</DD><DD>returns the information in arrayform (Shouldbeweighed and Weighingarray) and a substratelist
</DD></DL><H3><SPAN class="mw-headline" id="sort_out_by_angle_.28startingarray.2C_middlearray.2C_endingarray.2C_angletosequence.29:">sort_out_by_angle (startingarray, middlearray, endingarray, angletosequence):</SPAN></H3><DL><DD>sorts out the paths from startingarray over middlearray to endingarray. A path is sorted out, when the angle it would need is too far away from the possible angles in angletosequence
</DD><DD>returns a boolian array which paths to keep, middle and endingarray must have same dimension, if startingarray is only one point, it returns only middlearray and endingarray, else all three arrays are returned
</DD></DL><H3><SPAN class="mw-headline" id="make_small_generator.28PointArray.2C_repetition.2C_RAM.2C_tobesplitlength.2C_ProteinArray_.3D_None.29:">make_small_generator(PointArray, repetition, RAM, tobesplitlength, ProteinArray = None):</SPAN></H3><DL><DD>calculates how often PointArray needs to be split so that the following calculations still fit into the RAM.
</DD></DL><DL><DD>RAM in GByte
</DD><DD>repetition means how often is the largest array repeated. Repetition must be manually found and adjusted as the real amount of repetitions is only a hint.
</DD><DD>returns MakeSmall and teiler
</DD></DL><H3><SPAN class="mw-headline" id="make_small_generator_offset.28listofarraysinRAM.2C_PointArray.2C_repetition.2C_RAM.2C_tobesplitlength.2C_ProteinArray_.3D_None.29:">make_small_generator_offset(listofarraysinRAM, PointArray, repetition, RAM, tobesplitlength,  ProteinArray = None):</SPAN></H3><DL><DD>calculates how often PointArray needs to be split so that the following calculations still fit into the RAM.
</DD><DD>In the listofarraysinRAM can be either just the arrays or the size of the arrays, same for PointArray 
</DD></DL><DL><DD>RAM in GByte,
</DD><DD>repetition means how often is the largest  array repeated. Repetition must be manually found and adjusted as the  real amount of repetitions is only a hint.
</DD></DL><DL><DD>returns MakeSmall and teiler
</DD></DL><H3><SPAN class="mw-headline" id="sort_out_by_distance.28startingpoints.2C_endingpoints.2C_firstpoints.2C_distance.2C_variation.29:">sort_out_by_distance(startingpoints, endingpoints, firstpoints, distance, variation):</SPAN></H3><DL><DD>generates all possible connections from startingpoints to endingpoints, that lie in one of the distances plus minus the variation.
</DD><DD>returns three arrays with all possible paths, made out of all possible combinations startingpoints to endingpoints that are in a certain distance
</DD></DL><H3><SPAN class="mw-headline" id="sort_out_by_length_.28comefrompoints.2C_gotopoints.2C_linkerlaengen.29:">sort_out_by_length (comefrompoints, gotopoints, linkerlaengen):</SPAN></H3><DL><DD>sorts out the connections between comefrompoints and gotopoints, when they don't fit to the linkerlengths from linkerlaengen.
</DD></DL><DL><DD>Either comefrompoints or gotopoints can be only one point, but never both of them.
</DD><DD>returns a boolean array, with which you can slice the points, True means the values are kept
</DD></DL><H3><SPAN class="mw-headline" id="length_to_sequence.28lengtharray.2C_linkerdatenbank.2C_linkerlaengen.29:">length_to_sequence(lengtharray, linkerdatenbank, linkerlaengen):</SPAN></H3><DL><DD>translates the length from lengtharray to sequences according to the different linkerpieces in linkerdatenbank.
</DD><DD>returns an array of the sequences that reproduce the length
</DD></DL><H3><SPAN class="mw-headline" id="angle_to_sequence.28anglearray.2C_angletosequence.2C_angleseparators.29:">angle_to_sequence(anglearray, angletosequence, angleseparators):</SPAN></H3><DL><DD>translates the angles from anglearray to sequences according to the different angletosequence data.
</DD><DD>returns an array of the sequences that reproduce the angles
</DD></DL><H3><SPAN class="mw-headline" id="translate_paths_to_sequences.28startpoint.2C_firstflex.2C_secondflex.2C_thirdflex.2C_firstrig.2C_secondrig.2C_thirdrig.2C_endpoint.2C_linkerdb.2C_linkerlKO.2C_angletosequence.2C_angleseparators.2C_weightflex.2C_weightrig.29:">translate_paths_to_sequences(startpoint, firstflex, secondflex, thirdflex, firstrig, secondrig, thirdrig, endpoint, linkerdb, linkerlKO, angletosequence, angleseparators, weightflex, weightrig):</SPAN></H3><DL><DD>translates all paths to sequences according to the patterns provided in angleosequence and linkerdb
</DD><DD>returns an array with sequences for each path
</DD></DL><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:Heidelberg/pages/Linker-Software_Docu">http://2014.igem.org/Team:Heidelberg/pages/Linker-Software_Docu</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Heidelberg/pages/Linker-Software_Docu" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Heidelberg/pages/Linker-Software_Docu" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Heidelberg/pages/Linker-Software_Docu&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Heidelberg/pages/Linker-Software_Docu&amp;oldid=401572" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
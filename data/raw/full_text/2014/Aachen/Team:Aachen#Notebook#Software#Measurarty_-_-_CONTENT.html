<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Aachen_Notebook_Software_Measurarty"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Aachen/Notebook/Software/Measurarty">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Aachen/Notebook/Software/Measurarty&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Aachen/Notebook/Software/Measurarty&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Aachen/Notebook/Software/Measurarty&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Aachen/Notebook/Software/Measurarty" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Aachen/Notebook/Software/Measurarty</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><DIV class="navDiv" style="top:14px; position:fixed; z-index: 1; border-bottom-style: solid; border-bottom-width: 3px; border-bottom-color: #bf1521;"><NAV style="width: 1250px;"><UL align="left" style=""><LI style="width:129px"><A href="https://2014.igem.org/Team:Aachen/Project">Project</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Project/2D_Biosensor">2D Biosensor</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Project/FRET_Reporter">The REACh Construct</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Project/Model">Modeling</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Project/Measurement_Device"><I>WatsOn</I></A></LI><LI style="border-bottom:2px solid; border-bottom-color: white;"><A href="https://2014.igem.org/Team:Aachen/Project/Gal3">Galectin-3</A></LI><LI style="border-bottom:2px solid; border-bottom-color: white;"><A href="https://2014.igem.org/Team:Aachen/OD/F device">OD/F Device</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Parts">Parts</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Achievements">Achievements</A></LI></UL><LI style="width:216px"><A href="https://2014.igem.org/Team:Aachen/Interlab_Study">Interlab Study</A></LI><LI style="width:250px"><A href="https://2014.igem.org/Team:Aachen/PolicyPractices">Policy &amp; Practices</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Collaborations/Kaiser-Karls-Gymnasium">Kaiser-Karls-Gymnasium</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Collaborations/Neanderlab">NEAnderLab</A></LI><LI style="border-bottom:2px solid; border-bottom-color: white;"><A href="https://2014.igem.org/Team:Aachen/Collaborations/MakerFaire">MakerFaire</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Safety">Safety</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/PolicyPractices/Economics">Economical View</A></LI><LI style="border-bottom:2px solid; border-bottom-color: white;"><A href="https://2014.igem.org/Team:Aachen/PolicyPractices/BioBrickIntellectualProperty">BBa Intellectual Property</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Blog">Blog</A></LI><LI style="width:215px"><A href="https://2014.igem.org/Team:Aachen/Collaborations">Collaborations</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Meetup">Aachen Meetup</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Collaborations/Bielefeld">Bielefeld</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Collaborations/Methane_Sensor">Braunschweig</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Collaborations/Freiburg">Freiburg</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Collaborations/Heidelberg">Heidelberg</A></LI><LI style="width:157px"><A href="https://2014.igem.org/Team:Aachen/Notebook">Notebook</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Notebook/Wetlab">Wetlab</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Notebook/Protocols">Protocols</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Notebook/Engineering">Engineering</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Notebook/Software">Software</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Notebook/LabEquipment">Equipment</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Notebook/Index">Abbreviations</A></LI><LI style="width:109px"><A href="https://2014.igem.org/Team:Aachen/Attributions">Team</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Attributions#members">Members</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Attributions#instructors">Instructors</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Attributions#partners">Partners</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/Attributions#support">Attributions</A></LI><LI><A href="https://2014.igem.org/Team:Aachen/SecretHappenings"><I>Mr Holmes</I></A></LI></NAV></DIV><DIV id="contentdiv" style="margin-left: auto; margin-right: auto; width: 100%; position: absolute; bottom: 15px; top: 60px;"><TABLE class="transbg" width="100%" cellspacing="0"><TBODY><TR><TD class="contentcell" width="95%" align="justify"><H1><SPAN class="mw-headline" id="Measurarty"><I>Measurarty</I></SPAN></H1><P><I>Measurarty</I> is the evil player in the game of <I>Cellock Holmes</I> and <I>WatsOn</I>.
<I>Measurarty</I> is the pathogen detection logic behind our project.
Using our <I>Measurarty</I> algorithm, we want to automatically detect pathogens from the chip photos delivered by WatsOn, without human interaction.
Besides reducing the risk of human errors, this makes our device usable by almost everyone.
</P><P><CENTER><UL class="menusmall-grid"><LI style="width: 156px;margin-left: 8px;margin-right: 8px;"><A class="menulink" href="https://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty#intro" style="color:black"><DIV class="menusmall-item menusmall-info"><DIV class="menukachel">Intro</DIV></DIV></A></LI><LI style="width: 156px;margin-left: 8px;margin-right: 8px;"><A class="menulink" href="https://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty#SRM" style="color:black"><DIV class="menusmall-item menusmall-info"><DIV class="menukachel">SRM!</DIV></DIV></A></LI><LI style="width: 156px;margin-left: 8px;margin-right: 8px;"><A class="menulink" href="https://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty#segment" style="color:black"><DIV class="menusmall-item menusmall-info"><DIV class="menukachel">Segment!</DIV></DIV></A></LI><LI style="width: 156px;margin-left: 8px;margin-right: 8px;"><A class="menulink" href="https://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty#classification" style="color:black"><DIV class="menusmall-item menusmall-info"><DIV class="menukachel">Classify!</DIV></DIV></A></LI><LI style="width: 156px;margin-left: 8px;margin-right: 8px;"><A class="menulink" href="https://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty#measurartyachievements" style="color:black"><DIV class="menusmall-item menusmall-info"><DIV class="menukachel">Achieve-ments</DIV></DIV></A></LI></UL></CENTER></P></TD></TR></TBODY></TABLE><TABLE class="transbg" width="100%" cellspacing="0"><TBODY><TR><TD class="contentcell" width="95%" align="center"><H2><SPAN class="mw-headline" id="Measurarty_-_An_Introduction"><I>Measurarty</I> - An Introduction </SPAN></H2><P>Our <A href="https://2014.igem.org/Team:Aachen/Notebook/Engineering/WatsOn#watsonsoftware" class="external text" rel="nofollow">device control software</A> is able to take images of incubated chips inside WatsOn. Yet, that does not bring the user closer to the answer of the question:
</P><CENTER><B>What's on the chip?</B></CENTER><P>In fact, answering this question seems trivial for a human: Just check whether a colony grown has grown on the chip and you're done. This task is even easier with our chip system, because these show fluorescence wherever a pathogen has been detected.
</P><P>But is this an easy task for a computer? Actually not. The task of automatic detection is tried by several disciplines in computer science, from pattern recognition over machine learning to by medical imaging chairs.
</P><P>Here, we would like to present a pipeline for this task that makes use of <B>easy segmentation and classification algorithms</B>.
First, <I>Measurarty</I> segments the target image using <B>Statistical Region Merging (SRM)</B> in order to find regions of similar properties. After this step, we can segment the picture using <B>histogram thresholding</B> in <A href="http://en.wikipedia.org/wiki/HSL_and_HSV" class="external text" rel="nofollow">HSV color space</A> to find candidate regions for pathogens.
Finally, a classification algorithm can detect the pathogen on our chips.
</P><P>To demonstrate the algorithm, the following sample image will be discussed.
</P></TD></TR><TR><TD><B>Image taken from WatsOn to be analyzed by <I>Measurarty</I> algorithm</B></TD></TR></TBODY></TABLE></DIV><H2><SPAN class="mw-headline" id="Statistical_Region_Merging_.28SRM.29"> Statistical Region Merging (SRM) </SPAN></H2><P>Before briefly introducing Statistical Region Merging (SRM), we would like to explain why we need this step, and why this algorithm is an ideal choice.
</P><P>Compared to other clustering algorithms, SRM is quite leight weight, yet delivers <I>deterministic</I> results and is not dependent on a certain seed (like <I>k</I>-means, for example).
</P><P>On the other hand, it can create as many refinements as one wants and is thus flexible enough for the our purposes. Finally, there's already been knowledge about this algorithm in the group.
</P><P>Statistical Region Merging (SRM) (Nook and Nielson, 2004) is a clustering technique also used directly for image segmentation.
A region $R$ is a set of pixels and the cardinality $\lvert R \rvert$ determines how many pixels are in one region.
Starting with a sorted set of connected regions (w. r. t. some distance function $f$), two regions $R$ and $R'$ are merged if the qualification criteria $\vert \overline{R'}-\overline{R} \vert \leq \sqrt{b^2(R)+b^2(R')}$ with $b(R) = g \cdot \sqrt{\frac{\ln \frac{\mathcal{R}_{\lvert R \rvert}}{\delta}}{2Q\lvert R \rvert}}$ is fulfilled.
Therefore, $\mathcal{R}_{\lvert R \rvert}$ is the set of regions with $\lvert R \rvert$ pixels.
Typically $Q$ is chosen as $Q \in \lbrack 256, 1\rbrack$ and $\delta = \frac{1}{\lvert I \rvert^2}$.
</P><P>The $Q$ parameter mainly influences the merging process. For an example, see the figure <I>SRM Regions</I> below. The lower the chosen value for $Q$, more coarse the regions become. Using a union-find structure, the segmentation does not need to be recalculated for each $Q$ level. For the step from $q$ to $\frac{q}{2}$, just the qualification criteria needs to be applied to the regions from the $q$ result. A MATLAB implementation is also available (Boltz, 2009).
</P><DIV class="figure" style="margin: 10px 40px 10px 40px; border:0px solid #aaa;padding:0px;"><TABLE><TBODY><TR><TD><B>SRM regions in random colors</B>Different regions from an SRM run starting at $Q=256$ (top left) and going to $Q=1$ (bottom right). Each region is assigned a random color. </TD><TD><B>SRM regions (average color)</B>Different regions from an SRM run starting at $Q=256$ (top left) and going to $Q=1$ (bottom right). Each region is assigned the average color of that region.
</TD></TR></TBODY></TABLE></DIV><H3><SPAN class="mw-headline" id="SRM_Clustering"> SRM Clustering </SPAN></H3><P>In our project, we used Statistical Region Merging for clustering. In contrast to other algorithms, such as <I>k-means</I>, this approach is highly deterministic.
For our purposes we only have one SRM run for $Q=256$.
</P><P>In MATLAB, we use the previously mentioned code from MATLAB Fileexchange (Boltz, 2009).
For our Qt-based GUI we implemented the SRM method ourselves.
</P><P>The SRM clustering reduces the amount of different colors in the image and hence eases the recognition of parts belonging together.
</P><DIV class="codediv"><PRE><CODE class="matlab">
Qlevel = 256;
[maps,images]=singlesrm(double(image),Qlevel);
</CODE></PRE></DIV><P>Finally, if applied to our test-image, regions are created and homogenoues regions form:
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Regions created with SRM clustering</B></TD></TR></TBODY></TABLE></DIV><H2><SPAN class="mw-headline" id="Segmentation"> Segmentation </SPAN></H2><P>In the segmentation stage all background regions are removed. This task is quite crucial. If one removes too few, the final stage of finding pathogens might get irritated.
On the other hand, if one removes too many regions, positive hits might get removed early before detection. This surely must be avoided.
</P><P>We opted for a simple thresholding step because it showed that while being easy, it is an effective weapon against the uniform background. In fact, the good image quality we wanted to reach with our device allows now less sophisticated methods.
Also the less computational intensive the steps are, the better they might even run directly on the Raspberry Pi in our device!
</P><P>The HSV thresholding is performed on each component seperately. For more information on the HSV color space we refer to <A href="http://en.wikipedia.org/wiki/HSL_and_HSV" class="external text" rel="nofollow">Wikipedia</A>. The first component is the hue which we select to be inbetween $0.462$ and $0.520$ to select any blue-greenish color. We will not see bright green due to the filter selection in our device.
The saturation value must be high, between $0.99$ and $1.0$.
Moreover, the value component of the HSV image has to lie between $0.25$ and $0.32$, which assumes a relatively dark color.
</P><P>Indeed, these values are not problem specific, but specific for each setup and therefore have to be determined empirically.
</P><P>The remainder of this stage creates a mask of pixels that fulfill the conditions.
</P><DIV class="codediv"><PRE><CODE class="matlab">
% Auto-generated by colorThresholder app on 15-Oct-2014
%-------------------------------------------------------
function [maskedRGBImage] = createMask(srmimg)
RGB = srmimg;

% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.462;
channel1Max = 0.520;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.99;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.25;
channel3Max = 0.32;

% Create mask based on chosen histogram thresholds
BW = (I(:,:,1) &gt;= channel1Min ) &amp; (I(:,:,1) &lt;= channel1Max) &amp; ...
    (I(:,:,2) &gt;= channel2Min ) &amp; (I(:,:,2) &lt;= channel2Max) &amp; ...
    (I(:,:,3) &gt;= channel3Min ) &amp; (I(:,:,3) &lt;= channel3Max);

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end
</CODE></PRE></DIV><P>If you apply this HSV masking code to the SRMed test image, the following is created:
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Masked image</B></TD></TR></TBODY></TABLE></DIV><H2><SPAN class="mw-headline" id="Classification"> Classification </SPAN></H2><H3><SPAN class="mw-headline" id="Smoothness_Index"> Smoothness Index </SPAN></H3><P>For position prediction in virtual environments, jitter or noise in the output signal is not wanted though often present.
Since discovering smooth areas is a similar problem to jitter detection, a simple method for determining jitter can be used to measure non-jitter, smoothness (Joppich, Rausch and Kuhlen, 2013).
It is assumed that jitter-free areas of a position signal do not differ in velocity.
</P><P>Smooth areas do not differ in intensity, and therefore only low changes in velocity (intensity change) can be recorded.
For the reduction of noise, this operation is performed on the smoothed input image.
Then the smoothness $s$ of a pixel $p$ in its k-neighbourhood $\mathcal{N}_k$ can be determined as:
\begin{equation}
s(p) = \sum\limits_{p' \in \mathcal{N}_k} \nabla(p') / \arg\max\limits_{p} s(p)
\end{equation}
</P><P>Using thresholding, $TS_l \leq s(p) \leq TS_u \wedge TI_l \leq I \leq TI_u$, different areas, such as background or pathogen, can be selected.
</P><P>For the empirical choice of thresholds, it can be argued that these are tailored to the specific case.
While this surely is true to a certain extent, the here presented method has been successfully tested on images from a completely different domain, and no changes to the thresholds have been made to make it work.
A proper theoretical evaluation is emphasized, however, is probably not the aim of the iGEM competition.
</P><P>Finally, selecting for the red region, this delivers the location of possible pathogens.
Since the size of the agar chips is variable but fixed a quantitative analysis can be performed by counting pixels for instance.
</P><H3><SPAN class="mw-headline" id="Empirical_Evaluation"> Empirical Evaluation </SPAN></H3><P>Using our MATLAB code, we found the lower threshold for the smoothness index to be $TS_l = 0.85$ and the upper threshold $TS_u = \infty$.
Similarly, for $TI_l = 235$ and $TI_u = \infty$.
</P><P>Using these settings, we can find a response already in images taken after 42 minutes.
</P><P>Ideally, one would rate the quality of the image segmentation using some ground truth, such as manual delineations. This still has to be implemented for our method.
However, from visual observations, our method is showing promising results.
</P><UL><LI> image of smoothness index
</LI></UL><H3><SPAN class="mw-headline" id="Automatic_Classification"> Automatic Classification </SPAN></H3><DIV class="codediv"><PRE><CODE class="matlab">
function [mask, seg] = automaticseeds(im)

    imc = im;

    %% to grayscale and filtering
    Z = double(rgb2gray(im));
    Z = 255 * Z / max(max(Z));

    filtertype = 'disk';
    Z = filter2(fspecial(filtertype), Z);
    Z = filter2(fspecial(filtertype), filter2(fspecial(filtertype), Z));
    Z = 255 * Z / max(max(Z));   
    
    %% calculating similarity score/smoothness index
    k=4;
    sSI = similarity(Z,k);
    sSI = sSI / max(max(sSI));  
    
    %% classify
    pathogene = ((sSI &gt; 0.85) == 1) &amp; ((Z &gt; 235) == 1);  

    mask = ones( size(imc) );
    seg = zeros( size(imc) );

    
    %% output
    for i=1:size(im,1)
        for j=1:size(im,2)
            
            if (pathogene(i,j) == 1)
                seg(i,j,1:3) = [255 0 0];
                mask(i, j, 1:3) = [0 0 0];
            end
        end
    end
end
</CODE></PRE></DIV><P>This code actually creates two intermediate images from which the similarity index is calculated.
First the smoothed (disk-filter) input image is created and stored:
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Smoothed image</B></TD></TR></TBODY></TABLE></DIV><P>Only white regions are candidate regions.
After smoothing, the similarity index is calculated. As expected, edges are detected and limit the area from which the target region can be selected.
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Smoothness Index</B></TD></TR></TBODY></TABLE></DIV><P>Finally the selected pathogen region is selected by the black area in the following picture:
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Selected region</B></TD></TR></TBODY></TABLE></DIV><P>Combined with the input image, the final segmentation is received:
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Final the analyzed image</B></TD></TR></TBODY></TABLE></DIV><H2><SPAN class="mw-headline" id="Achievements"> Achievements </SPAN></H2><P><I>Measurarty</I> is the image analysis logic behind our project.
It is comprised of simple constructs put together into a pipeline, that is clearly laid out, easily maintainable and - if needed - easily adaptable.
For example, changing from green to red fluorescence, only means to change the <I>createMask</I> function to select another target area.
</P><P>Overall the results are convincing. We have not yet performed a comparison to a manual delineation, however, by eye the results look promising and have a low error.
</P><P>Talking about computational complexity, the MATLAB code of course performs better than our own C++ implementation, which must be regarded as a proof-of-principle.
</P><P>Space-wise, the code depends heavily on the image size $O( x \cdot y)$ (width $x$, height $y$, which also limits the number of edges in SRM between regions, as each pixel is one region to start with. However, it cannot take less memory, as the image is stored in an uncompressed format.
</P><P>On the computational side, the thresholding, image conversion and gradient steps are linear in the number of pixels, and are thus in $O(x \cdot y)$.
Unfortunately, the summation of the gradient for the smoothness index adds a heavy factor to it (k-neighbourhood for smoothness index).
Due to the merging step in our C++-SRM algorithm implementation, our code has to do  $O(x^2 \cdot y^2)$ comparisons, which then finally results in a runtime complexity of $O( x^2 \cdot y^2)$.
</P><DIV class="figure" style="float:center; margin: 10px 10px 10px 40px; border:0px solid #aaa;width:700px;padding:0px;"><TABLE><TBODY><TR><TD><B>Pixel count of the detected pathogenic region versus time after induction.</B></TD></TR></TBODY></TABLE></DIV><P>From the above figure it can also be seen that the detected amount of pathogenic-area correlates with time after induction.
The lag-phase can be explained first by the lag-phase of the cells, which first need to generate a response to the pathogen, and on the other hand, by too low fluorescence which is not detectable.
The pixel count also meets the expectation when looking at the sample files by eye.
</P><CENTER><DIV class="figure" style="float:center; margin: 0px 10px 10px 0px; border:0px solid #aaa;width:960px;padding:10px 10px 0px 0px;"><TABLE><TBODY><TR><TD><B>Detecting <I>P. aeroginosa</I> with K131026</B>The left half shows the original images from the device and the right half shows the same pictures with the detected pathogenic region analyzed by <I>Measurarty</I>.
</TD></TR></TBODY></TABLE></DIV></CENTER><P>It can be concluded that the <I>Measurarty</I> pipeline defines a robustly working chip-analysis algorithm which can detect pathogens from images supplied by <I>WatsOn</I>.
Therefore, this algorithm closes the gap between our biology, detection hardware and the user who wants easy-to-interpret results.
</P><P>For future prospects, it would be interesting to do a proper performance analysis on our code, to find hotspots and optimize the code. Many <I>for</I>-loops leave plenty of room for vectorization and loop-unrolling. Parallelization, specifically with respect to embedded hardware such as the Raspberry Pi or Odroid U3, is limited to the extend that the overhead created would probably eliminate the improvements.
</P><H2><SPAN class="mw-headline" id="Source_Code"> Source Code </SPAN></H2><P><I>Measuarty</I> is the image analysis logic behind our project. It has been prototyped and developed in <A href="http://www.mathworks.de/academia/student-competitions/igem/" class="external text" rel="nofollow">MATLAB</A>, and only later been ported into our <I>WatsOn</I> GUI.
</P><P>We are happy to provide you with a zip-ped download of our MATLAB code here, as well as on the iGEM software repository on <A href="https://github.com/orgs/igemsoftware/teams/aachen2014" class="external text" rel="nofollow">github</A>.
</P><UL><LI><A href="https://static.igem.org/mediawiki/2014/6/6e/Aachen_measurarty.zip" class="external text" rel="nofollow">MATLAB code</A></LI><LI> link <A href="https://github.com/igemsoftware/AachenSoftProject2014/tree/master/measurarty" class="external text" rel="nofollow">github</A></LI></UL><P>For the C++ conversion please see <A href="https://2014.igem.org/Team:Aachen/Notebook/Engineering/WatsOn#watsonsoftware" class="external text" rel="nofollow">our <I>WatsOn</I> Software</A> section.
</P><H3><SPAN class="mw-headline" id="Using_the_MATLAB_Code"> Using the MATLAB Code </SPAN></H3><P>In general, please follow the included <I>README.MD</I> file. Our package comes with a set of test files from one of our experiments.
After installing the Statistical Region Merging code (see readme), you can simply run <I>igem_srm_demo.m</I>. Select your current folder, and MATLAB will automatically segment and classify the included jpg-images.
</P><H2><SPAN class="mw-headline" id="References"> References </SPAN></H2><UL><LI> Boltz, S. (2009, October 20). Image segmentation using statistical region merging - File Exchange - MATLAB Central. Image segmentation using statistical region merging. Retrieved December 12, 2013, from <A href="http://www.mathworks.com/matlabcentral/fileexchange/25619-image-segmentation-using-statistical-region-merging" class="external free" rel="nofollow">http://www.mathworks.com/matlabcentral/fileexchange/25619-image-segmentation-using-statistical-region-merging</A></LI></UL><UL><LI> Joppich, M., Rausch, D., &amp; Kuhlen, T. (2013). Adaptive human motion prediction using multiple model approaches.. Virtuelle und erweiterte Realität (p. 169–180). 10. Workshop der GI-Fachgruppe VR/AR: Shaker.
</LI></UL><UL><LI> Nock, R., &amp; Nielsen, F. (2004). Statistical region merging. IEEE Transactions on Pattern Analysis and Machine Intelligence, 26(11), 1452-1458.
</LI></UL></DIV><DIV class="footerDiv" align="center" style="margin-bottom:-10px; background:#0069b3;"><CENTER><A class="footerCenter" href="https://2014.igem.org/Team:Aachen/Contact">Contact</A><A class="footerCenter" href="https://2014.igem.org/Team:Aachen/Disclaimer">Disclaimer</A></CENTER></DIV><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty">http://2014.igem.org/Team:Aachen/Notebook/Software/Measurarty</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Aachen/Notebook/Software/Measurarty" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Aachen/Notebook/Software/Measurarty" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Aachen/Notebook/Software/Measurarty&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Aachen/Notebook/Software/Measurarty&amp;oldid=399875" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></BODY></HTML>
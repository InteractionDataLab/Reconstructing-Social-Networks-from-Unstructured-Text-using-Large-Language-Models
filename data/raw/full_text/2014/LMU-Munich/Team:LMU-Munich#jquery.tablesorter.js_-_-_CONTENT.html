<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_LMU-Munich_jquery_tablesorter_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:LMU-Munich/jquery.tablesorter.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:LMU-Munich/jquery.tablesorter.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:LMU-Munich/jquery.tablesorter.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:LMU-Munich/jquery.tablesorter.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:LMU-Munich/jquery.tablesorter.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:LMU-Munich/jquery.tablesorter.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><P>/*
</P><PRE>* 
* TableSorter 2.0 - Client-side table sorting with ease!
* Version 2.0.5b
* @requires jQuery v1.2.3
* 
* Copyright (c) 2007 Christian Bach
* Examples and docs at: <A href="http://tablesorter.com" class="external free" rel="nofollow">http://tablesorter.com</A>
* Dual licensed under the MIT and GPL licenses:
* <A href="http://www.opensource.org/licenses/mit-license.php" class="external free" rel="nofollow">http://www.opensource.org/licenses/mit-license.php</A>
* <A href="http://www.gnu.org/licenses/gpl.html" class="external free" rel="nofollow">http://www.gnu.org/licenses/gpl.html</A>
* 
*/
</PRE><P>/**
</P><PRE>* 
* @description Create a sortable table with multi-column sorting capabilitys
* 
* @example $('table').tablesorter();
* @desc Create a simple tablesorter interface.
* 
* @example $('table').tablesorter({ sortList:[[0,0],[1,0]] });
* @desc Create a tablesorter interface and sort on the first and secound column column headers.
* 
* @example $('table').tablesorter({ headers: { 0: { sorter: false}, 1: {sorter: false} } });
*          
* @desc Create a tablesorter interface and disableing the first and second  column headers.
*      
* 
* @example $('table').tablesorter({ headers: { 0: {sorter:&quot;integer&quot;}, 1: {sorter:&quot;currency&quot;} } });
* 
* @desc Create a tablesorter interface and set a column parser for the first
*       and second column.
* 
* 
* @param Object
*            settings An object literal containing key/value pairs to provide
*            optional settings.
* 
* 
* @option String cssHeader (optional) A string of the class name to be appended
*         to sortable tr elements in the thead of the table. Default value:
*         &quot;header&quot;
* 
* @option String cssAsc (optional) A string of the class name to be appended to
*         sortable tr elements in the thead on a ascending sort. Default value:
*         &quot;headerSortUp&quot;
* 
* @option String cssDesc (optional) A string of the class name to be appended
*         to sortable tr elements in the thead on a descending sort. Default
*         value: &quot;headerSortDown&quot;
* 
* @option String sortInitialOrder (optional) A string of the inital sorting
*         order can be asc or desc. Default value: &quot;asc&quot;
* 
* @option String sortMultisortKey (optional) A string of the multi-column sort
*         key. Default value: &quot;shiftKey&quot;
* 
* @option String textExtraction (optional) A string of the text-extraction
*         method to use. For complex html structures inside td cell set this
*         option to &quot;complex&quot;, on large tables the complex option can be slow.
*         Default value: &quot;simple&quot;
* 
* @option Object headers (optional) An array containing the forces sorting
*         rules. This option let's you specify a default sorting rule. Default
*         value: null
* 
* @option Array sortList (optional) An array containing the forces sorting
*         rules. This option let's you specify a default sorting rule. Default
*         value: null
* 
* @option Array sortForce (optional) An array containing forced sorting rules.
*         This option let's you specify a default sorting rule, which is
*         prepended to user-selected rules. Default value: null
* 
* @option Boolean sortLocaleCompare (optional) Boolean flag indicating whatever
*         to use String.localeCampare method or not. Default set to true.
* 
* 
* @option Array sortAppend (optional) An array containing forced sorting rules.
*         This option let's you specify a default sorting rule, which is
*         appended to user-selected rules. Default value: null
* 
* @option Boolean widthFixed (optional) Boolean flag indicating if tablesorter
*         should apply fixed widths to the table columns. This is usefull when
*         using the pager companion plugin. This options requires the dimension
*         jquery plugin. Default value: false
* 
* @option Boolean cancelSelection (optional) Boolean flag indicating if
*         tablesorter should cancel selection of the table headers text.
*         Default value: true
* 
* @option Boolean debug (optional) Boolean flag indicating if tablesorter
*         should display debuging information usefull for development.
* 
* @type jQuery
* 
* @name tablesorter
* 
* @cat Plugins/Tablesorter
* 
* @author Christian Bach/christian.bach@polyester.se
*/
</PRE><P>(function ($) {
</P><PRE>   $.extend({
       tablesorter: new
       function () {
</PRE><PRE>           var parsers = [],
               widgets = [];
</PRE><PRE>           this.defaults = {
               cssHeader: &quot;header&quot;,
               cssAsc: &quot;headerSortUp&quot;,
               cssDesc: &quot;headerSortDown&quot;,
               cssChildRow: &quot;expand-child&quot;,
               sortInitialOrder: &quot;asc&quot;,
               sortMultiSortKey: &quot;shiftKey&quot;,
               sortForce: null,
               sortAppend: null,
               sortLocaleCompare: true,
               textExtraction: &quot;simple&quot;,
               parsers: {}, widgets: [],
               widgetZebra: {
                   css: [&quot;even&quot;, &quot;odd&quot;]
               }, headers: {}, widthFixed: false,
               cancelSelection: true,
               sortList: [],
               headerList: [],
               dateFormat: &quot;us&quot;,
               decimal: '/\.|\,/g',
               onRenderHeader: null,
               selectorHeaders: 'thead th',
               debug: false
           };
</PRE><PRE>           /* debuging utils */
</PRE><PRE>           function benchmark(s, d) {
               log(s + &quot;,&quot; + (new Date().getTime() - d.getTime()) + &quot;ms&quot;);
           }
</PRE><PRE>           this.benchmark = benchmark;
</PRE><PRE>           function log(s) {
               if (typeof console != &quot;undefined&quot; &amp;&amp; typeof console.debug != &quot;undefined&quot;) {
                   console.log(s);
               } else {
                   alert(s);
               }
           }
</PRE><PRE>           /* parsers utils */
</PRE><PRE>           function buildParserCache(table, $headers) {
</PRE><PRE>               if (table.config.debug) {
                   var parsersDebug = &quot;&quot;;
               }
</PRE><PRE>               if (table.tBodies.length == 0) return; // In the case of empty tables
               var rows = table.tBodies[0].rows;
</PRE><PRE>               if (rows[0]) {
</PRE><PRE>                   var list = [],
                       cells = rows[0].cells,
                       l = cells.length;
</PRE><PRE>                   for (var i = 0; i &lt; l; i++) {
</PRE><PRE>                       var p = false;
</PRE><PRE>                       if ($.metadata &amp;&amp; ($($headers[i]).metadata() &amp;&amp; $($headers[i]).metadata().sorter)) {
</PRE><PRE>                           p = getParserById($($headers[i]).metadata().sorter);
</PRE><PRE>                       } else if ((table.config.headers[i] &amp;&amp; table.config.headers[i].sorter)) {
</PRE><PRE>                           p = getParserById(table.config.headers[i].sorter);
                       }
                       if (!p) {
</PRE><PRE>                           p = detectParserForColumn(table, rows, -1, i);
                       }
</PRE><PRE>                       if (table.config.debug) {
                           parsersDebug += &quot;column:&quot; + i + &quot; parser:&quot; + p.id + &quot;\n&quot;;
                       }
</PRE><PRE>                       list.push(p);
                   }
               }
</PRE><PRE>               if (table.config.debug) {
                   log(parsersDebug);
               }
</PRE><PRE>               return list;
           };
</PRE><PRE>           function detectParserForColumn(table, rows, rowIndex, cellIndex) {
               var l = parsers.length,
                   node = false,
                   nodeValue = false,
                   keepLooking = true;
               while (nodeValue == <I>&amp;&amp; keepLooking) {</I>
                   rowIndex++;
                   if (rows[rowIndex]) {
                       node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);
                       nodeValue = trimAndGetNodeText(table.config, node);
                       if (table.config.debug) {
                           log('Checking if value was empty on row:' + rowIndex);
                       }
                   } else {
                       keepLooking = false;
                   }
               }
               for (var i = 1; i &lt; l; i++) {
                   if (parsers[i].is(nodeValue, table, node)) {
                       return parsers[i];
                   }
               }
               // 0 is always the generic parser (text)
               return parsers[0];
           }
</PRE><PRE>           function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {
               return rows[rowIndex].cells[cellIndex];
           }
</PRE><PRE>           function trimAndGetNodeText(config, node) {
               return $.trim(getElementText(config, node));
           }
</PRE><PRE>           function getParserById(name) {
               var l = parsers.length;
               for (var i = 0; i &lt; l; i++) {
                   if (parsers[i].id.toLowerCase() == name.toLowerCase()) {
                       return parsers[i];
                   }
               }
               return false;
           }
</PRE><PRE>           /* utils */
</PRE><PRE>           function buildCache(table) {
</PRE><PRE>               if (table.config.debug) {
                   var cacheTime = new Date();
               }
</PRE><PRE>               var totalRows = (table.tBodies[0] &amp;&amp; table.tBodies[0].rows.length) || 0,
                   totalCells = (table.tBodies[0].rows[0] &amp;&amp; table.tBodies[0].rows[0].cells.length) || 0,
                   parsers = table.config.parsers,
                   cache = {
                       row: [],
                       normalized: []
                   };
</PRE><PRE>               for (var i = 0; i &lt; totalRows; ++i) {
</PRE><PRE>                   /** Add the table data to main data array */
                   var c = $(table.tBodies[0].rows[i]),
                       cols = [];
</PRE><PRE>                   // if this is a child row, add it to the last row's children and
                   // continue to the next row
                   if (c.hasClass(table.config.cssChildRow)) {
                       cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);
                       // go to the next for loop
                       continue;
                   }
</PRE><PRE>                   cache.row.push(c);
</PRE><PRE>                   for (var j = 0; j &lt; totalCells; ++j) {
                       cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));
                   }
</PRE><PRE>                   cols.push(cache.normalized.length); // add position for rowCache
                   cache.normalized.push(cols);
                   cols = null;
               };
</PRE><PRE>               if (table.config.debug) {
                   benchmark(&quot;Building cache for &quot; + totalRows + &quot; rows:&quot;, cacheTime);
               }
</PRE><PRE>               return cache;
           };
</PRE><PRE>           function getElementText(config, node) {
</PRE><PRE>               var text = &quot;&quot;;
</PRE><PRE>               if (!node) return &quot;&quot;;
</PRE><PRE>               if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;
</PRE><PRE>               if (config.textExtraction == &quot;simple&quot;) {
                   if (config.supportsTextContent) {
                       text = node.textContent;
                   } else {
                       if (node.childNodes[0] &amp;&amp; node.childNodes[0].hasChildNodes()) {
                           text = node.childNodes[0].innerHTML;
                       } else {
                           text = node.innerHTML;
                       }
                   }
               } else {
                   if (typeof(config.textExtraction) == &quot;function&quot;) {
                       text = config.textExtraction(node);
                   } else {
                       text = $(node).text();
                   }
               }
               return text;
           }
</PRE><PRE>           function appendToTable(table, cache) {
</PRE><PRE>               if (table.config.debug) {
                   var appendTime = new Date()
               }
</PRE><PRE>               var c = cache,
                   r = c.row,
                   n = c.normalized,
                   totalRows = n.length,
                   checkCell = (n[0].length - 1),
                   tableBody = $(table.tBodies[0]),
                   rows = [];
</PRE><PRE>               for (var i = 0; i &lt; totalRows; i++) {
                   var pos = n[i][checkCell];
</PRE><PRE>                   rows.push(r[pos]);
</PRE><PRE>                   if (!table.config.appender) {
</PRE><PRE>                       //var o = ;
                       var l = r[pos].length;
                       for (var j = 0; j &lt; l; j++) {
                           tableBody[0].appendChild(r[pos][j]);
                       }
</PRE><PRE>                       // 
                   }
               }
</PRE><PRE>               if (table.config.appender) {
</PRE><PRE>                   table.config.appender(table, rows);
               }
</PRE><PRE>               rows = null;
</PRE><PRE>               if (table.config.debug) {
                   benchmark(&quot;Rebuilt table:&quot;, appendTime);
               }
</PRE><PRE>               // apply table widgets
               applyWidget(table);
</PRE><PRE>               // trigger sortend
               setTimeout(function () {
                   $(table).trigger(&quot;sortEnd&quot;);
               }, 0);
</PRE><PRE>           };
</PRE><PRE>           function buildHeaders(table) {
</PRE><PRE>               if (table.config.debug) {
                   var time = new Date();
               }
</PRE><PRE>               var meta = ($.metadata) ? true : false;
               
               var header_index = computeTableHeaderCellIndexes(table);
</PRE><PRE>               $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {
</PRE><PRE>                   this.column = header_index[this.parentNode.rowIndex + &quot;-&quot; + this.cellIndex];
                   // this.column = index;
                   this.order = formatSortingOrder(table.config.sortInitialOrder);
                   
</PRE><P>					this.count = this.order;
</P><PRE>                   if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;
</PRE><P>					if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);
</P><PRE>                   if (!this.sortDisabled) {
                       var $th = $(this).addClass(table.config.cssHeader);
                       if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);
                   }
</PRE><PRE>                   // add cell to headerList
                   table.config.headerList[index] = this;
               });
</PRE><PRE>               if (table.config.debug) {
                   benchmark(&quot;Built headers:&quot;, time);
                   log($tableHeaders);
               }
</PRE><PRE>               return $tableHeaders;
</PRE><PRE>           };
</PRE><PRE>           // from:
           // <A href="http://www.javascripttoolbox.com/lib/table/examples.php" class="external free" rel="nofollow">http://www.javascripttoolbox.com/lib/table/examples.php</A>
           // <A href="http://www.javascripttoolbox.com/temp/table_cellindex.html" class="external free" rel="nofollow">http://www.javascripttoolbox.com/temp/table_cellindex.html</A></PRE><PRE>           function computeTableHeaderCellIndexes(t) {
               var matrix = [];
               var lookup = {};
               var thead = t.getElementsByTagName('THEAD')[0];
               var trs = thead.getElementsByTagName('TR');
</PRE><PRE>               for (var i = 0; i &lt; trs.length; i++) {
                   var cells = trs[i].cells;
                   for (var j = 0; j &lt; cells.length; j++) {
                       var c = cells[j];
</PRE><PRE>                       var rowIndex = c.parentNode.rowIndex;
                       var cellId = rowIndex + &quot;-&quot; + c.cellIndex;
                       var rowSpan = c.rowSpan || 1;
                       var colSpan = c.colSpan || 1
                       var firstAvailCol;
                       if (typeof(matrix[rowIndex]) == &quot;undefined&quot;) {
                           matrix[rowIndex] = [];
                       }
                       // Find first available column in the first row
                       for (var k = 0; k &lt; matrix[rowIndex].length + 1; k++) {
                           if (typeof(matrix[rowIndex][k]) == &quot;undefined&quot;) {
                               firstAvailCol = k;
                               break;
                           }
                       }
                       lookup[cellId] = firstAvailCol;
                       for (var k = rowIndex; k &lt; rowIndex + rowSpan; k++) {
                           if (typeof(matrix[k]) == &quot;undefined&quot;) {
                               matrix[k] = [];
                           }
                           var matrixrow = matrix[k];
                           for (var l = firstAvailCol; l &lt; firstAvailCol + colSpan; l++) {
                               matrixrow[l] = &quot;x&quot;;
                           }
                       }
                   }
               }
               return lookup;
           }
</PRE><PRE>           function checkCellColSpan(table, rows, row) {
               var arr = [],
                   r = table.tHead.rows,
                   c = r[row].cells;
</PRE><PRE>               for (var i = 0; i &lt; c.length; i++) {
                   var cell = c[i];
</PRE><PRE>                   if (cell.colSpan &gt; 1) {
                       arr = arr.concat(checkCellColSpan(table, headerArr, row++));
                   } else {
                       if (table.tHead.length == 1 || (cell.rowSpan &gt; 1 || !r[row + 1])) {
                           arr.push(cell);
                       }
                       // headerArr[row] = (i+row);
                   }
               }
               return arr;
           };
</PRE><PRE>           function checkHeaderMetadata(cell) {
               if (($.metadata) &amp;&amp; ($(cell).metadata().sorter === false)) {
                   return true;
               };
               return false;
           }
</PRE><PRE>           function checkHeaderOptions(table, i) {
               if ((table.config.headers[i]) &amp;&amp; (table.config.headers[i].sorter === false)) {
                   return true;
               };
               return false;
           }
</PRE><P>			 function checkHeaderOptionsSortingLocked(table, i) {
</P><PRE>               if ((table.config.headers[i]) &amp;&amp; (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;
               return false;
           }
</PRE><PRE>          function applyWidget(table) {
               var c = table.config.widgets;
               var l = c.length;
               for (var i = 0; i &lt; l; i++) {
</PRE><PRE>                   getWidgetById(c[i]).format(table);
               }
</PRE><PRE>           }
</PRE><PRE>           function getWidgetById(name) {
               var l = widgets.length;
               for (var i = 0; i &lt; l; i++) {
                   if (widgets[i].id.toLowerCase() == name.toLowerCase()) {
                       return widgets[i];
                   }
               }
           };
</PRE><PRE>           function formatSortingOrder(v) {
               if (typeof(v) != &quot;Number&quot;) {
                   return (v.toLowerCase() == &quot;desc&quot;) ? 1 : 0;
               } else {
                   return (v == 1) ? 1 : 0;
               }
           }
</PRE><PRE>           function isValueInArray(v, a) {
               var l = a.length;
               for (var i = 0; i &lt; l; i++) {
                   if (a[i][0] == v) {
                       return true;
                   }
               }
               return false;
           }
</PRE><PRE>           function setHeadersCss(table, $headers, list, css) {
               // remove all header information
               $headers.removeClass(css[0]).removeClass(css[1]);
</PRE><PRE>               var h = [];
               $headers.each(function (offset) {
                   if (!this.sortDisabled) {
                       h[this.column] = $(this);
                   }
               });
</PRE><PRE>               var l = list.length;
               for (var i = 0; i &lt; l; i++) {
                   h[list[i][0]].addClass(css[list[i][1]]);
               }
           }
</PRE><PRE>           function fixColumnWidth(table, $headers) {
               var c = table.config;
               if (c.widthFixed) {
                   var colgroup = $('&lt;colgroup&gt;');
                   $(&quot;tr:first td&quot;, table.tBodies[0]).each(function () {
                       colgroup.append($('&lt;col&gt;').css('width', $(this).width()));
                   });
                   $(table).prepend(colgroup);
               };
           }
</PRE><PRE>           function updateHeaderSortCount(table, sortList) {
               var c = table.config,
                   l = sortList.length;
               for (var i = 0; i &lt; l; i++) {
                   var s = sortList[i],
                       o = c.headerList[s[0]];
                   o.count = s[1];
                   o.count++;
               }
           }
</PRE><PRE>           /* sorting methods */
</PRE><PRE>           function multisort(table, sortList, cache) {
</PRE><PRE>               if (table.config.debug) {
                   var sortTime = new Date();
               }
</PRE><PRE>               var dynamicExp = &quot;var sortWrapper = function(a,b) {&quot;,
                   l = sortList.length;
</PRE><PRE>               // TODO: inline functions.
               for (var i = 0; i &lt; l; i++) {
</PRE><PRE>                   var c = sortList[i][0];
                   var order = sortList[i][1];
                   // var s = (getCachedSortType(table.config.parsers,c) == &quot;text&quot;) ?
                   // ((order == 0) ? &quot;sortText&quot; : &quot;sortTextDesc&quot;) : ((order == 0) ?
                   // &quot;sortNumeric&quot; : &quot;sortNumericDesc&quot;);
                   // var s = (table.config.parsers[c].type == &quot;text&quot;) ? ((order == 0)
                   // ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?
                   // makeSortNumeric(c) : makeSortNumericDesc(c));
                   var s = (table.config.parsers[c].type == &quot;text&quot;) ? ((order == 0) ? makeSortFunction(&quot;text&quot;, &quot;asc&quot;, c) : makeSortFunction(&quot;text&quot;, &quot;desc&quot;, c)) : ((order == 0) ? makeSortFunction(&quot;numeric&quot;, &quot;asc&quot;, c) : makeSortFunction(&quot;numeric&quot;, &quot;desc&quot;, c));
                   var e = &quot;e&quot; + i;
</PRE><PRE>                   dynamicExp += &quot;var &quot; + e + &quot; = &quot; + s; // + &quot;(a[&quot; + c + &quot;],b[&quot; + c
                   // + &quot;]); &quot;;
                   dynamicExp += &quot;if(&quot; + e + &quot;) { return &quot; + e + &quot;; } &quot;;
                   dynamicExp += &quot;else { &quot;;
</PRE><PRE>               }
</PRE><PRE>               // if value is the same keep orignal order
               var orgOrderCol = cache.normalized[0].length - 1;
               dynamicExp += &quot;return a[&quot; + orgOrderCol + &quot;]-b[&quot; + orgOrderCol + &quot;];&quot;;
</PRE><PRE>               for (var i = 0; i &lt; l; i++) {
                   dynamicExp += &quot;}; &quot;;
               }
</PRE><PRE>               dynamicExp += &quot;return 0; &quot;;
               dynamicExp += &quot;}; &quot;;
</PRE><PRE>               if (table.config.debug) {
                   benchmark(&quot;Evaling expression:&quot; + dynamicExp, new Date());
               }
</PRE><PRE>               eval(dynamicExp);
</PRE><PRE>               cache.normalized.sort(sortWrapper);
</PRE><PRE>               if (table.config.debug) {
                   benchmark(&quot;Sorting on &quot; + sortList.toString() + &quot; and dir &quot; + order + &quot; time:&quot;, sortTime);
               }
</PRE><PRE>               return cache;
           };
</PRE><PRE>           function makeSortFunction(type, direction, index) {
               var a = &quot;a[&quot; + index + &quot;]&quot;,
                   b = &quot;b[&quot; + index + &quot;]&quot;;
               if (type == 'text' &amp;&amp; direction == 'asc') {
                   return &quot;(&quot; + a + &quot; == &quot; + b + &quot; ? 0 : (&quot; + a + &quot; === null ? Number.POSITIVE_INFINITY : (&quot; + b + &quot; === null ? Number.NEGATIVE_INFINITY : (&quot; + a + &quot; &lt; &quot; + b + &quot;) ? -1 : 1 )));&quot;;
               } else if (type == 'text' &amp;&amp; direction == 'desc') {
                   return &quot;(&quot; + a + &quot; == &quot; + b + &quot; ? 0 : (&quot; + a + &quot; === null ? Number.POSITIVE_INFINITY : (&quot; + b + &quot; === null ? Number.NEGATIVE_INFINITY : (&quot; + b + &quot; &lt; &quot; + a + &quot;) ? -1 : 1 )));&quot;;
               } else if (type == 'numeric' &amp;&amp; direction == 'asc') {
                   return &quot;(&quot; + a + &quot; === null &amp;&amp; &quot; + b + &quot; === null) ? 0 :(&quot; + a + &quot; === null ? Number.POSITIVE_INFINITY : (&quot; + b + &quot; === null ? Number.NEGATIVE_INFINITY : &quot; + a + &quot; - &quot; + b + &quot;));&quot;;
               } else if (type == 'numeric' &amp;&amp; direction == 'desc') {
                   return &quot;(&quot; + a + &quot; === null &amp;&amp; &quot; + b + &quot; === null) ? 0 :(&quot; + a + &quot; === null ? Number.POSITIVE_INFINITY : (&quot; + b + &quot; === null ? Number.NEGATIVE_INFINITY : &quot; + b + &quot; - &quot; + a + &quot;));&quot;;
               }
           };
</PRE><PRE>           function makeSortText(i) {
               return &quot;((a[&quot; + i + &quot;] &lt; b[&quot; + i + &quot;]) ? -1 : ((a[&quot; + i + &quot;] &gt; b[&quot; + i + &quot;]) ? 1 : 0));&quot;;
           };
</PRE><PRE>           function makeSortTextDesc(i) {
               return &quot;((b[&quot; + i + &quot;] &lt; a[&quot; + i + &quot;]) ? -1 : ((b[&quot; + i + &quot;] &gt; a[&quot; + i + &quot;]) ? 1 : 0));&quot;;
           };
</PRE><PRE>           function makeSortNumeric(i) {
               return &quot;a[&quot; + i + &quot;]-b[&quot; + i + &quot;];&quot;;
           };
</PRE><PRE>           function makeSortNumericDesc(i) {
               return &quot;b[&quot; + i + &quot;]-a[&quot; + i + &quot;];&quot;;
           };
</PRE><PRE>           function sortText(a, b) {
               if (table.config.sortLocaleCompare) return a.localeCompare(b);
               return ((a &lt; b) ? -1 : ((a &gt; b) ? 1 : 0));
           };
</PRE><PRE>           function sortTextDesc(a, b) {
               if (table.config.sortLocaleCompare) return b.localeCompare(a);
               return ((b &lt; a) ? -1 : ((b &gt; a) ? 1 : 0));
           };
</PRE><PRE>           function sortNumeric(a, b) {
               return a - b;
           };
</PRE><PRE>           function sortNumericDesc(a, b) {
               return b - a;
           };
</PRE><PRE>           function getCachedSortType(parsers, i) {
               return parsers[i].type;
           }; /* public methods */
           this.construct = function (settings) {
               return this.each(function () {
                   // if no thead or tbody quit.
                   if (!this.tHead || !this.tBodies) return;
                   // declare
                   var $this, $document, $headers, cache, config, shiftDown = 0,
                       sortOrder;
                   // new blank config object
                   this.config = {};
                   // merge and extend.
                   config = $.extend(this.config, $.tablesorter.defaults, settings);
                   // store common expression for speed
                   $this = $(this);
                   // save the settings where they read
                   $.data(this, &quot;tablesorter&quot;, config);
                   // build headers
                   $headers = buildHeaders(this);
                   // try to auto detect column type, and store in tables config
                   this.config.parsers = buildParserCache(this, $headers);
                   // build the cache for the tbody cells
                   cache = buildCache(this);
                   // get the css class names, could be done else where.
                   var sortCSS = [config.cssDesc, config.cssAsc];
                   // fixate columns if the users supplies the fixedWidth option
                   fixColumnWidth(this);
                   // apply event handling to headers
                   // this is to big, perhaps break it out?
                   $headers.click(
</PRE><PRE>                   function (e) {
                       var totalRows = ($this[0].tBodies[0] &amp;&amp; $this[0].tBodies[0].rows.length) || 0;
                       if (!this.sortDisabled &amp;&amp; totalRows &gt; 0) {
                           // Only call sortStart if sorting is
                           // enabled.
                           $this.trigger(&quot;sortStart&quot;);
                           // store exp, for speed
                           var $cell = $(this);
                           // get current column index
                           var i = this.column;
                           // get current column sort order
                           this.order = this.count++ % 2;
</PRE><P>							// always sort on the locked order.
							if(this.lockedOrder) this.order = this.lockedOrder;
</P><P>							// user only whants to sort on one
</P><PRE>                           // column
                           if (!e[config.sortMultiSortKey]) {
                               // flush the sort list
                               config.sortList = [];
                               if (config.sortForce != null) {
                                   var a = config.sortForce;
                                   for (var j = 0; j &lt; a.length; j++) {
                                       if (a[j][0] != i) {
                                           config.sortList.push(a[j]);
                                       }
                                   }
                               }
                               // add column to sort list
                               config.sortList.push([i, this.order]);
                               // multi column sorting
                           } else {
                               // the user has clicked on an all
                               // ready sortet column.
                               if (isValueInArray(i, config.sortList)) {
                                   // revers the sorting direction
                                   // for all tables.
                                   for (var j = 0; j &lt; config.sortList.length; j++) {
                                       var s = config.sortList[j],
                                           o = config.headerList[s[0]];
                                       if (s[0] == i) {
                                           o.count = s[1];
                                           o.count++;
                                           s[1] = o.count % 2;
                                       }
                                   }
                               } else {
                                   // add column to sort list array
                                   config.sortList.push([i, this.order]);
                               }
                           };
                           setTimeout(function () {
                               // set css for headers
                               setHeadersCss($this[0], $headers, config.sortList, sortCSS);
                               appendToTable(
</PRE><P>	                                $this[0], multisort(
	                                $this[0], config.sortList, cache)
								);
</P><PRE>                           }, 1);
                           // stop normal event by returning false
                           return false;
                       }
                       // cancel selection
                   }).mousedown(function () {
                       if (config.cancelSelection) {
                           this.onselectstart = function () {
                               return false
                           };
                           return false;
                       }
                   });
                   // apply easy methods that trigger binded events
                   $this.bind(&quot;update&quot;, function () {
                       var me = this;
                       setTimeout(function () {
                           // rebuild parsers.
                           me.config.parsers = buildParserCache(
                           me, $headers);
                           // rebuild the cache map
                           cache = buildCache(me);
                       }, 1);
                   }).bind(&quot;updateCell&quot;, function (e, cell) {
                       var config = this.config;
                       // get position from the dom.
                       var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];
                       // update cache
                       cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(
                       getElementText(config, cell), cell);
                   }).bind(&quot;sorton&quot;, function (e, list) {
                       $(this).trigger(&quot;sortStart&quot;);
                       config.sortList = list;
                       // update and store the sortlist
                       var sortList = config.sortList;
                       // update header count index
                       updateHeaderSortCount(this, sortList);
                       // set css for headers
                       setHeadersCss(this, $headers, sortList, sortCSS);
                       // sort the table and append it to the dom
                       appendToTable(this, multisort(this, sortList, cache));
                   }).bind(&quot;appendCache&quot;, function () {
                       appendToTable(this, cache);
                   }).bind(&quot;applyWidgetId&quot;, function (e, id) {
                       getWidgetById(id).format(this);
                   }).bind(&quot;applyWidgets&quot;, function () {
                       // apply widgets
                       applyWidget(this);
                   });
                   if ($.metadata &amp;&amp; ($(this).metadata() &amp;&amp; $(this).metadata().sortlist)) {
                       config.sortList = $(this).metadata().sortlist;
                   }
                   // if user has supplied a sort list to constructor.
                   if (config.sortList.length &gt; 0) {
                       $this.trigger(&quot;sorton&quot;, [config.sortList]);
                   }
                   // apply widgets
                   applyWidget(this);
               });
           };
           this.addParser = function (parser) {
               var l = parsers.length,
                   a = true;
               for (var i = 0; i &lt; l; i++) {
                   if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {
                       a = false;
                   }
               }
               if (a) {
                   parsers.push(parser);
               };
           };
           this.addWidget = function (widget) {
               widgets.push(widget);
           };
           this.formatFloat = function (s) {
               var i = parseFloat(s);
               return (isNaN(i)) ? 0 : i;
           };
           this.formatInt = function (s) {
               var i = parseInt(s);
               return (isNaN(i)) ? 0 : i;
           };
           this.isDigit = function (s, config) {
               // replace all an wanted chars and match.
               return /^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g, <I>)));</I>
           };
           this.clearTableBody = function (table) {
               if ($.browser.msie) {
                   function empty() {
                       while (this.firstChild)
                       this.removeChild(this.firstChild);
                   }
                   empty.apply(table.tBodies[0]);
               } else {
                   table.tBodies[0].innerHTML = &quot;&quot;;
               }
           };
       }
   });
</PRE><PRE>   // extend plugin scope
   $.fn.extend({
       tablesorter: $.tablesorter.construct
   });
</PRE><PRE>   // make shortcut
   var ts = $.tablesorter;
</PRE><PRE>   // add default parsers
   ts.addParser({
       id: &quot;text&quot;,
       is: function (s) {
           return true;
       }, format: function (s) {
           return $.trim(s.toLocaleLowerCase());
       }, type: &quot;text&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;digit&quot;,
       is: function (s, table) {
           var c = table.config;
           return $.tablesorter.isDigit(s, c);
       }, format: function (s) {
           return $.tablesorter.formatFloat(s);
       }, type: &quot;numeric&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;currency&quot;,
       is: function (s) {
           return /^[£$€?.]/.test(s);
       }, format: function (s) {
           return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g), &quot;&quot;));
       }, type: &quot;numeric&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;ipAddress&quot;,
       is: function (s) {
           return /^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);
       }, format: function (s) {
           var a = s.split(&quot;.&quot;),
               r = &quot;&quot;,
               l = a.length;
           for (var i = 0; i &lt; l; i++) {
               var item = a[i];
               if (item.length == 2) {
                   r += &quot;0&quot; + item;
               } else {
                   r += item;
               }
           }
           return $.tablesorter.formatFloat(r);
       }, type: &quot;numeric&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;url&quot;,
       is: function (s) {
           return /^(https?|ftp|file):\/\/$/.test(s);
       }, format: function (s) {
           return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//), <I>));</I>
       }, type: &quot;text&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;isoDate&quot;,
       is: function (s) {
           return /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);
       }, format: function (s) {
           return $.tablesorter.formatFloat((s != &quot;&quot;) ? new Date(s.replace(
           new RegExp(/-/g), &quot;/&quot;)).getTime() : &quot;0&quot;);
       }, type: &quot;numeric&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;percent&quot;,
       is: function (s) {
           return /\%$/.test($.trim(s));
       }, format: function (s) {
           return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g), &quot;&quot;));
       }, type: &quot;numeric&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;usLongDate&quot;,
       is: function (s) {
           return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));
       }, format: function (s) {
           return $.tablesorter.formatFloat(new Date(s).getTime());
       }, type: &quot;numeric&quot;
   });
</PRE><PRE>   ts.addParser({
       id: &quot;shortDate&quot;,
       is: function (s) {
           return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);
       }, format: function (s, table) {
           var c = table.config;
           s = s.replace(/\-/g, &quot;/&quot;);
           if (c.dateFormat == &quot;us&quot;) {
               // reformat the string in ISO format
               s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, &quot;$3/$1/$2&quot;);
           } else if (c.dateFormat == &quot;uk&quot;) {
               // reformat the string in ISO format
               s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, &quot;$3/$2/$1&quot;);
           } else if (c.dateFormat == &quot;dd/mm/yy&quot; || c.dateFormat == &quot;dd-mm-yy&quot;) {
               s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/, &quot;$1/$2/$3&quot;);
           }
           return $.tablesorter.formatFloat(new Date(s).getTime());
       }, type: &quot;numeric&quot;
   });
   ts.addParser({
       id: &quot;time&quot;,
       is: function (s) {
           return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);
       }, format: function (s) {
           return $.tablesorter.formatFloat(new Date(&quot;2000/01/01 &quot; + s).getTime());
       }, type: &quot;numeric&quot;
   });
   ts.addParser({
       id: &quot;metadata&quot;,
       is: function (s) {
           return false;
       }, format: function (s, table, cell) {
           var c = table.config,
               p = (!c.parserMetadataName) ? 'sortValue' : c.parserMetadataName;
           return $(cell).metadata()[p];
       }, type: &quot;numeric&quot;
   });
   // add default widgets
   ts.addWidget({
       id: &quot;zebra&quot;,
       format: function (table) {
           if (table.config.debug) {
               var time = new Date();
           }
           var $tr, row = -1,
               odd;
           // loop through the visible rows
           $(&quot;tr:visible&quot;, table.tBodies[0]).each(function (i) {
               $tr = $(this);
               // style children rows the same way the parent
               // row was styled
               if (!$tr.hasClass(table.config.cssChildRow)) row++;
               odd = (row % 2 == 0);
               $tr.removeClass(
               table.config.widgetZebra.css[odd ? 0 : 1]).addClass(
               table.config.widgetZebra.css[odd ? 1 : 0])
           });
           if (table.config.debug) {
               $.tablesorter.benchmark(&quot;Applying Zebra widget&quot;, time);
           }
       }
   });
</PRE><P>})(jQuery);
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:LMU-Munich/jquery.tablesorter.js">http://2014.igem.org/Team:LMU-Munich/jquery.tablesorter.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:LMU-Munich/jquery.tablesorter.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:LMU-Munich/jquery.tablesorter.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:LMU-Munich/jquery.tablesorter.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:LMU-Munich/jquery.tablesorter.js&amp;oldid=245155" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_MIT_Tools"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:MIT/Tools/">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:MIT/Tools/&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:MIT/Tools/&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:MIT/Tools/&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:MIT/Tools/" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform">Â </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:MIT/Tools/</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2011.igem.org</H3><P><UL class="navbar"><LI><A href="https://2011.igem.org/Team:MIT">HOME</A></LI><LI><A href="https://2011.igem.org/Team:MIT/Project/">PROJECT</A></LI><LI><A href="https://2011.igem.org/Team:MIT/Results/">DATA</A></LI><LI><A href="https://2011.igem.org/Team:MIT/Notebook/">NOTEBOOK</A></LI><LI><A href="https://2011.igem.org/Team:MIT/Tools/">MODEL</A></LI><LI><A href="https://2011.igem.org/Team:MIT/Partners/">PARTNERS</A></LI><LI><A href="https://2011.igem.org/Team:MIT/Team/Undergraduates">TEAM</A></LI><LI><A id="long" href="https://2011.igem.org/Team:MIT/HumanPractices/">HUMAN PRACTICES</A></LI></UL></P><DIV id="col_nav"><DIV class="col_list"><H2>Navigation</H2><UL><LI id="model">Modeling</LI><LI id="mcell">mcell Modeling Platform</LI><LI id="assembly">G-Level Assembly</LI><LI id="colony">Colony Picker</LI><LI id="geneious">Geneious</LI></UL></DIV></DIV><DIV id="col_left"><DIV class="content" id="modelcontent"><H1> Modeling </H1><P>
To understand how to create different types of cellular patterns, we did a tremendous amount of modeling. The modeling was central to our engineering process - it was used to determine what genetic circuits can produce patterns and the range of patterns any particular genetic circuit can produce. Moreover, the model was used to determine the feasibility of engineering any particular pattern into real-world cells; any pattern we could actually make in real life would have to be stable under a wide range of parameters. Essentially, we used the model as a computational design tool to decide what we could build and how we could build it.
</P><P>
The simulation of cell shape dynamics was crucial to our modeling. Cell shape is (obviously) an important part part of the structure of biological tissues. We incorporated control of cell adhesion strength into our circuits; differing cell adhesion cannot be simulated without the cells moving around and changing their form and surface area. However, the internal structure of the cell played little role in our design, because we did not incorporate any devices that allow control of internal structure, or the specific control of cell shape, into our circuits. Thus, the cells, for our purposes, were simply structure-less stochastically moving blobs with individually varying strengths of adhesion. This fit very well into the paradigm of the Cellular Potts Method[1], so we modeled the external shape-position dynamics of our cells using the Cellular Potts Method while simulating the internal protein dynamics by numerically integrating an ODE inside each cell.

</P><H2> A Summary of the Simulation Method </H2><P>
To simulate the cell shape dynamics, we used the Cellular Potts Method - an extremely efficient, lattice-based, Monte-Carlo method for simulating &quot;generalized cells&quot; - blobs with a set of given properties, occupying a set of lattice points. In our simulations we modeled a real-life cell using a single &quot;generalized cell&quot;. 

</P><P>
The &quot;energy&quot; of the system is a function of the state of the system; it is the sum of a set of constraints. In our case, the energy is the sum (for every cell) of
<UL><LI>A constraint on volume of the form <CODE>lambda_V(Volume_of_Cell - Target_Volume)^2</CODE></LI><LI>A constraint on surface area of the fomr <CODE>lambda_S(Surface_of_Cell - Target_Surface)^2</CODE></LI><LI>The energy of adhesion, which is (summing over the neighbors of the cell) <CODE>-NCAD_Strength*NCAD_in_Cell*NCad_in_Neighboring_Cell</CODE></LI></UL></P><P>
For our simulations, lambda_V = 1, lambda_S = 2, Target_Volume = 64, Target_Surface = 32, and NCAD_Strength = 1.
</P><P>
In our method, the following is repeatedly done:
<UL><LI> For every point P1 in the lattice,
	</LI><LI>A neighboring point P2 is chosen</LI><LI>If P1 belonged to cell A and P2 belonged to a cell other than A, the change in the &quot;energy&quot; of the system configuration is calculated
		</LI><LI>If the change in system energy is negative, P2 becomes a member of cell A
		</LI><LI>If the change in system energy is posituve, P2 becomes a member of cell A with probability e^-deltaH/T, where T is the &quot;temperature&quot;, a constant. 
(Thus, the &quot;temperature&quot; determines how much the cells move around.)
		</LI></UL><LI>The ODEs are Euler-stepped forward a fixed timestep (in our simulations, the timestep is 0.1)
</LI><LI>The parameters of the ODEs running &quot;inside&quot; each cell are updated with new information such as the amount of a surface protein in contact with a cell
</LI><LI>Parameters in the &quot;effective energy&quot;, like the amounth of NCAD in each cell, are updated by the new information in the ODEs in each cell


The software for running, managing, rendering, and analyzing models that use this method all this described on the <EM>mCell Modeling Framework</EM> page.

</LI></P><H2> The Circuit and the ODE Model </H2><P>
Using our simulations, we discovered this relatively simple patterning circuit should reliably produce several different types of patterns, depending on whether how adhesion is controlled. (Note: the amount of doxycycline, which modulates the strength of rtTA3, must be adjusted so that Notch production is less than Delta production when LacI is absent, but greater than Delta production when LacI is present. Essentially, this creates an intermediate-strength constitutive promoter.)
</P><P>
Not shown is the repression of the Hef1a-LacO promoter by LacI, the production of Gal4 when Notch and Delta on touching cells bind, the stimulation of UAS by Gal4, and the Notch/Delta cis-repression. In cis-repression, Notch and Delta on the same cell bind to one another to form a complex, which then gets removed from the plasma membrane. We assumed, following the models in [2], that these protein-protein dynamics occur on a much faster timescale than transcription. The same assumption was made of the 'Notch + Delta -&gt; Notch/Delta Complex' reaction. Thus, cis-repression is modeled with the term $k_c*NCis*DCis$, and trans-activation is modeled with the term $k_t*NCis*DCis$. We modeled the production of proteins by promoters using Hill functions, as is standard practice. 
</P><P>
That produces the following set of differential equations:
Key:
<UL><LI>D, N - amount of Delta, Notch inside the cell
	</LI><LI>D', N' - amount of Delta, Notch touching the membrane of the cell. (When calculating these values, we assumed that Delta and Notch are evenly distributed on a cell's membrane.)
	</LI><LI>G - amount of Gal4
	</LI><LI>L - amount of LacI
	</LI><LI>R - amount of Reporter protein
	</LI><LI>k_t - strength of trans-activation
	</LI><LI>k_c - strength of cis-inhibition
	</LI><LI>b_L - strength of LacI repression
	</LI><LI>n_prod - constitutive producton of Notch
	</LI><LI>d_min - minimum production of Delta
	</LI><LI>d_prod - the additional production that Delta can achieve. When LacI is absent, d_min + d_prod is the maximum rate of Delta production.
	</LI><LI>g_prod - maximum rate of production of UAS promoter
	</LI><LI>k_d - Gal4-UAS disassociation constant
	</LI><LI>h - cooperativity of Gal4 binding to UAS
	</LI><LI>g_deg - rate of degradation of Gal4
	</LI><LI>p_deg - rate of degradation of other protein
</LI></UL></P><P>
In our simulations, every cell began with 0 of every protein. We took the values k_t = 0.1, k_c = 1, k_d = 1500, h = 1, g_deg = 1, and p_deg = 0.1 from [2]. We let n_prod = 5, d_min = 2, d_prod = 8; these are reasonable values in scale with those suggested for Notch and Delta production in [2]. We varied b_L through various values and found that a fairly large range of reasonable values extending outside of 5&lt;b_L&lt;50 generates patterning.
<B> IN ALL THE FOLLOWING VIDEOS, RED IS AMOUNT OF DELTA PROTEIN AND GREEN IS AMOUNT OF NOTCH PROTEIN </B></P><H2>Constitutive Adhesion</H2><P>In this simulation, all cells have a constant 10 NCad. There is no UAS:NCAD in the circuit</P><H3>Video</H3><H3>Analysis</H3><P>What happens here is that, initially, all the cells develop a large amount of Delta. However, some Notch still remains in the cells, and is strongly activated; Delta production rates begin to drop because of the LacI. Some cells gain significant amounts of Notch before others, due to the random movements of the cells. Once a cell gains a significant amount of Notch, it's Delta level drops off sharply, and it ceases to activate cells in its vincinity. Thus, once a cell is fully &quot;activated&quot;, other cells around it are much less likely to be. The stable state of such dynamics is a mosaic pattern, in which single cells are activated and are surrounded by a sea of inactivated cells. THis produces a characteristic mosaic pattern.</P><H2>But what if they are not sticky?</H2><P>There is a very large discrepancy between the behavior of the circuit in HEK cells in CHO cells, which are modeled with no adhesion and are initialized with gaps in between them. In CHO cells, the following ensues:
</P><H3>Movie</H3><H3>Analysis</H3>
The cells drift around until they hit one another, activating. However, they do not stick. Many drift away. The pattern as a whole has no cohesive strucure. Whenever enough cells hit one area, only the cells in the middle are activated, producing a dendritic structure. (The reason there is any patterning at all is because there are too many cells for them not to run into one another.)

<H2>Adding in NCAD</H2><P>In this run, the UAS:NCAD is added to the circuit.
</P><H3>Movie</H3><H3>Analysis</H3><P>In here, cells drift around until they hit one another, then begin to activate. Eventually, this forms a stable, adhering structure with several holes in it. Many of the holes close up, but some remain quite stable. Cells drift from active into non-active form and back, occasionally, but the structure as whole remains stable. 
</P><P>It is interesting to see how whenever enough of a thickness of cells appears, the characteristic mosaic pattern forms. Furthermore, it is interesting to compare the behavior of the holes in the structure to the behavior of the holes in the previous simulation. In this simulation, the holes are <EM>more stable</EM> because of the effect the &quot;backbone&quot; of adhering cells has on the structure.
</P><H2>Data and Citations</H2><P>
The data for these runs can be downloaded from <A href="http://mit.edu/~semonr/igem/sims2.zip">here</A>.

</P><P>[1] http://en.wikipedia.org/wiki/Cellular_Potts_model 
</P><P>[2] Sprinzak, et al. Cis-interactions between Notch and Delta generate mutually exclusive signalling states. <EM>Nature</EM> 465:86-90</P></DIV><DIV class="content" id="mcellcontent"><H1><EM>mcell</EM> - A Multicellular Modeling Framework </H1><P><EM>mcell</EM> is a small set of Python classes that allows the enterprising modeler to:
<UL><LI>Easily create very flexible models of of multicellular dynamics</LI><LI>Manage the models already created through a simple command-line interface</LI><LI>Easily change defined parameters in models</LI><LI>Render the runs of the models in a convenient, simple way</LI><LI>Analyze the runs of the models through histograms</LI></UL></P><P><EM>mcell</EM> is a thin layer on top of the combination of <A href="http://ryanroper.wordpress.com/2011/05/04/multiscale-simulation-with-compucell3d-and-bionetsolver/">BionetSolver</A>, which model internal cell states as systems of ODEs, and <A href="http://compucell3d.org">CompuCell3D</A>, which models cell shape dynamics using the Glazier-Graner-Hogeweg methos. It was created largely in reaction to inconveniences experienced when using BionetSolver and CompuCell3D as detailed  <A href="http://ryanroper.wordpress.com/2011/05/04/multiscale-simulation-with-compucell3d-and-bionetsolver/">here</A>. It is in continuous development; we would like to continue evolving it outside the bounds of this competition. We encourage you to read through the code and look at our modeling data as examples to understand the framework.
</P><H3> Quick Links</H3><UL><LI><A href="#why">Why?</A></LI><LI><A href="#install">Installation</A></LI><LI><A href="#howitworks">How It Works</A></LI><LI><A href="#management">Management of Models</A></LI><LI><A href="#analysis">Rendering and Analysis of Runs</A></LI></UL><H2><A id="why" class="sec"> Why? </A></H2><P>Over the course of the summer, we tried several ways of modeling multicellular dynamics. The first thing we tried was everyone's trusted favorite, MATLAB. We generated a system of several thousand ODEs, in which groups of 5 ODEs represented the state of a single cell, and were coupled to ODEs describing adjacent cells. Unfortunately, this was very, very slow, and did not allow for the modeling of cell shape dynamics.</P><P>Then, we discovered <A href="http://ryanroper.wordpress.com/2011/05/04/multiscale-simulation-with-compucell3d-and-bionetsolver/">a way to couple CompuCell3D with ODE models of internal cell states.</A> We realized that, if we wanted to do any sort of reasonably flexible modeling, we needed to do something like this. So, we downloaded CompuCell3D, read the documentation, and started modeling various circuits.</P><P>Now, CompuCell3D coupled with BionetSolver is a great system. However, we quickly discovered that this wasn't quite enough for our purposes. For instance, CompuCell3D allows one to dynamically change the &quot;cell type&quot;, and this the cell color. However, as we were trying to engineer cells, we were interested in the dynamics of the protein expression levels -- in fundamentally continuous quantities -- rather than a discrete notion of &quot;cell type&quot;! CompuCell 3D would not let us visualize the values that we needed -- so we wrote a Python script to render the models the way we wanted to.</P><P>Other problems emerged. We wanted to be able to analyze the data in other ways -- in particular, we wanted to see histograms of the levels of expression of some protein.  In addition, we realized that trying to manage all our models was becoming quite inconvenient without a unified organization scheme.</P><P>So, we had several hastily-written, badly organized Python scripts and many, many folders scattered around. We then decided that this problem needs fixing, and created a small set of classes to unify the object model do the file management, rendering, and analysis, for us -- using a convenient and extensible command-line interface. We found this functionality to be tremndously useful for our purposes, and thus, we are sharing <EM>mcell</EM> with the world.

</P><H2><A id="install" class="sec"> Installation </A></H2><P><B>Dependencies:</B><A href="http://www.python.org/getit/releases/2.5.6/">Python 2.5.6</A>, <A href="http://www.compucell3d.org/SrcBin">CompuCell3D 3.5.0</A>, <A href="http://ryanroper.wordpress.com/2011/07/26/running-the-right-version-of-bionetsolver-with-cc3d/">BionetSolver 1.0.0 for Python 2.5</A>, <A href="http://matplotlib.sourceforge.net/">matplotlib</A>, <A href="http://www.pythonware.com/products/pil/">PIL</A>, and <A href="http://code.google.com/p/scipy-cluster/">hcluster</A>.</P><P><B>Also very useful:</B><A href="http://sbw.kgi.edu/sbwWiki/doku.php?id=sysbio:downloads">Synthetic Biology Workbench</A> (for defining circuits)</P><P>Download mcell from <A href="http://igem.mit.edu/mcell.zip">here</A>. Unzip the files somewhere into your PATH. Open mcell.py, and edit the variables between
<CODE>#START CONFIG</CODE> and <CODE>#END CONFIG</CODE>. (They have self-explanatory names, and their functions are explained in the file.) In <EM>hook.py.template</EM>, edit the commented line to reflect the location of <EM>mcell</EM>. Place the<EM>Template</EM> folder into you modeling directory for an empty template model. The other folders are also interesting models that we have tried out. (The <EM>params</EM> files in the model folders describe the parameters the model requires to run.) </P><H2><A id="howitworks" class="sec"> How it works </A></H2>
In mcell models, BionetSolver models the internal cell states, and CompuCell3D models the cell dynamics.

<H3> BionetSolver </H3><P>BionetSolver reads one or several <A href="http://sbml.org">SBML</A> files, each of which define a <EM>circuit</EM> as a system of chemical reactions in several containers with given rate laws. SBML models are simply XML files, and can be written with a text editor; however, it is much easier to define them using a graphical designer, like <A href="http://sbw.kgi.edu/software/jdesigner.htm">JDesigner</A>, or using a simple scripting language, like [Jarnac]. (Both of those editors can be obtained by installing the <A href="http://sbw.kgi.edu/sbwWiki/doku.php?id=sysbio:downloads">Synthetic Biology Workbench</A>.</P><P>After loading the circuits, BionetSolver is in posession of a system of ODEs that define the internal state of each modeled cell. To simulate each cell, BionetSolver simply Euler-steps its ODE system forward with a fixed time step. Some of the variables in the ODE model (like, say, the concentration of a protein on the neighboring cells) are actually parameters that are continually updated from the CompuCell3D thread.</P><P>More documentation on BionetSolver can be found by downloading it from the link <A href="#install">above</A>.</P><H3> CompuCell3D </H3><P>CompuCell3D uses the Glazier-Graner-Hogeweg model to simulate cell shape dynamics. The playing field is a matrix. An entry of the matrix corresponds to an ID of the cell occupying that spot on the playing field. Thus, a cell is represented as a set of points on the matrix. The medium the cell are in is represented by a single large cell occupying all the &quot;empty space&quot;. </P><P>To iterate the model forward, CompuCell3D chooses a random point on the matrix -- the <EM>invading</EM> point -- and a random adjacent point -- the <EM>receiving</EM> point. If the two points are from different cells, then the receiving point's cell id becomes set to the invading point's cell id with some probability <CODE>e^-(T*k(state))</CODE>, where <CODE>T</CODE> is set in the configuration file and <CODE>k(state)</CODE> is a function of the state of the system that is determined by the plugins defined in the configuration file. (For example, the Contact plugin adds a term to k that makes cells of one cell type want to stick or not stick to cells of another cell type. The Surface plugin adds a term that grows larger as the surface area of the cell deviates from a defined amount.) This procedure is called a Monte Carlo step (MCS).  Certain parameters of the plugins -- say, the type, or the adhesiveness of a cell -- can be continuously updated to reflect the internal state of the cell.</P><H3> Coupling BionetSolver and CompuCell3D </H3><P>CompuCell3D provides a mechanism to script its function called a <EM>Steppable</EM>. Thus, to couple the internal states of the cells and the cell shape dynamics, a steppable called <CODE>ModelSteppable</CODE> is used. <CODE>ModelSteppable</CODE> initializes BionetSolver with circuits before CompuCell starts running its model, but after it has created the initial state of the cells. Then, CompuCell3D takes several MCSs to update the cell shape state. <CODE>ModelSteppable</CODE> then loops over the cells, updating the internal states of the cells in the BionetSolver circuits to match the external states, and the external state parameters in CompuCell3D to match the internal states of the cells. The full internal state every cell is printed to one file, and the state of the cell shapes is printed to another file. This cycle then repeats many, many times.</P><H2><A id="management" class="sec">Management of Models</A></H2><H3> Directory Structure </H3><P><EM>mcell</EM> uses a directory structure to manage its models. All models are contained in a <EM>modeling directory</EM>, the location of which is configurable in <EM>mcell.py</EM>. Every folder in the modeling directory is considered by <EM>mcell</EM> to be a model. A model folder contains 3 necessary files: a CompuCell3D configuration file (<EM>cc3d.xml</EM>), a hook file(<EM>hook.py</EM>), and a file containing <CODE>ModelSteppable</CODE> (<EM>steppable.py</EM>). A model folder also contains files that start with &quot;<EM>circuit_</EM>&quot;, which are all assumed to be SBML models of circuits. These files define a model. </P><P>All folders inside the model folder are considered to be runs of the model; the name of the folder is the name of the run.  Inside the run folder, the <EM>LatticeData</EM> folder contains vtk files that describe the state of the cell shapes at every frame of the model; the <EM>CellData.txt</EM> file which describes the complete state of every cell for every frame, one frame per line; and the <EM>model</EM> folder, which contains the final model files with parameters substituted into them. (To run a model, <EM>mcell</EM> actually loads the model files, adds in the given parameters, writes them to the <EM>model</EM> folder, and runs CompuCell3D on <EM>cc3d.xml</EM> in the <EM>model</EM> folder.)</P><H4>Parameters</H4><P>Each of the model files can contain strings in the form &quot;%(something)s&quot;; when the model is run with <CODE>model.run(&quot;NewRun&quot;, something=2)</CODE>, the parameter <CODE>2</CODE> will be substituted in place of that string for the duration of the run.</P><H4>Easy definition of a model</H4><P>here are several utility functions in <EM>mcell_model_utils.py</EM> that allow easier definition of the coupling between internal and external cell states. Note: <EM>mcell_model_utils.py</EM> should be imported into every model's steppable inside the <CODE>ModelSteppable</CODE> class definition for them to work. All functions expect a setup for <CODE>ModelSteppable</CODE> as in the <EM>Template</EM> model.</P><P><CODE>self.setToWeightedValuesOf(&quot;a&quot;, &quot;b&quot;)</CODE> sets protein &quot;a&quot; in all cells to the value of &quot;b&quot; in the neighboring cells, weighted by contact area. This is used to easily set up a model of surface proteins interacting on adjacent cells.</P><P><CODE>self.updateAdhesionMolecule(&quot;a&quot;, &quot;b&quot;)</CODE> sets the amount of adhesion molecule &quot;a&quot; in CompuCell to the amount of protein &quot;b&quot; for every cell. This is used in conjunction with the AdhesionFlex plugin; it expects <CODE>self.adhesionFlexPlugin = CompuCell.getAdhesionFlexPlugin()</CODE> in the initialization of a steppable.</P><H3>Command Line Management </H3><P>To run <EM>mcell</EM>, run python and type <CODE>from mcell import *</CODE>. This initializes a <CODE>models</CODE> dictionary containing all the models in your modeling directory. Each model is a fully functional python object! If we have a model called <EM>Test</EM>, then:
<UL><LI><CODE>models['Test'].runs</CODE> is a dictionary containing all the runs of the object (which are also Python objects)</LI><LI><CODE>models['Test'].cc3d_config</CODE> contains a python object that represents the <EM>cc3d.xml</EM> for the model. running <CODE>models['Test'].cc3d_config.edit()</CODE> would open your favorite text editor to edit the config, and running <CODE>models['Test'].cc3d_config.copy(dest)</CODE> will copy the CC3D configuration to <CODE>dest</CODE>. The same goes for the hook file(<CODE>.hook</CODE>) and the <CODE>ModelSteppable</CODE> file(<CODE>.steppable</CODE>). </LI><LI><CODE>models['Test'].circuits</CODE> is an array containing python objects like described above that reference the circuits in the model.</LI><LI><CODE>models['Test'].clone('NewModel')</CODE> creates a new model identical to <EM>Test</EM> called <EM>NewModel</EM>. This is incredibly useful for creating models that are similar to other models, something done quite often. Cloning the <EM>Template</EM> model creates a fairly good setup to begin defining a model.</LI><LI><CODE>models['Test'].run('NewRun', params)</CODE> runs <EM>Test</EM> with parameters <CODE>params</CODE> (a dictionary) and creates the <EM>NewRun</EM> run. Parameters for a model are defined as described in the <B>Parameters</B> section above.</LI><LI><CODE>models['Test'].destroy()</CODE> irrevocably destroys the model.</LI></UL></P><H2><A id="analysis" class="sec"> Rendering and Analysis of Runs </A></H2><P>If <CODE>r</CODE> is a <CODE>Run</CODE> object (taken from something like <CODE>r = models['Test'].runs['NewRun']</CODE>), then:
<UL><LI><CODE>r.load()</CODE> will load the run data into memory. This is time and memory intensive, as, unfortunatly, multicellular runs entail a lot of data.</LI><LI><CODE>r.render(species=&quot;Reporter&quot;, unload=False, pix_size=5)</CODE> will render the model into <EM>movie.avi</EM> in the run's folder, coloring the cells proportional to the amount or &quot;Reporter&quot; protein that they express. The data for the model will not be unloaded after the run, and the pixel size of a singly CompuCell3D matrix entry is 5. All these arguments are optional and default to the values given here.</LI><LI><CODE>r.render_hist_movie(species=&quot;Reporter&quot;)</CODE> will render a movie of the histograms of the values of the &quot;Reporter&quot; protein in all the cells as the simulation evolves. The argument is optional and &quot;Reporter&quot; is the default. The name of the movie will be <EM>histograms.avi</EM>.</LI><LI><CODE>r.frames</CODE> is an array that, after <CODE>load</CODE>ing the model, contains <CODE>Frame</CODE> objects that contain the raw data for every frame of the simulation. Specifically, <CODE>r.frames[0].cell_states[2]['Reporter']</CODE> contains the value of the &quot;Reporter&quot; protein in cell with id 2 during the first frame. <CODE>r.frames[0].cell_types</CODE>, <CODE>r.frames[0].cell_ids</CODE>, and <CODE>r.frames[0].cell_clusters</CODE> are 2-dimensional arrays containing the cell types, the cell ids, and the cell clusters on the CompuCell3D &quot;playing field&quot;
for that frame.</LI></UL></P></DIV><DIV class="content" id="assemblycontent"><H1>G-Level Assembly</H1>
This summer, we relied on three levels of G-Level Assembly: Gibson, Golden Gate, and Gateway. These three techniques allowed us to assemble together fusion proteins of many parts of DNA in one-pot reactions.

<H2>Gateway</H2>
The Gateway cloning system is available from Invitrogen. It is a fast and reliable way to create expression vectors for mammalian cells. It fulfills the same function as restriction cloning in the Biobrick standardization, allowing us to combine vectors with different parts to create a whole circuit. But the actual mechanism is vastly different from restriction cloning. Gateway uses recombination enzymes to combine multiple vectors, a one-step process that avoids the laborious digestion and ligation steps involved in restriction cloning.

<CENTER>An example LR reaction.</CENTER><CENTER>An example BP reaction.</CENTER><B>Cloning Process Overview</B>
We start out by cloning all the genes and promoters needed into pENTR vectors; the pENTR vectors contain restriction and recombination sites, so either cloning method can be used to insert the target DNA into the vectors. The next step is to combine pENTR vectors containing the relevant gene and promoter with a pDEST vector containing both prokaryotic and eukaryotic origins of replication. Gateway cloning allows us to avoid laborious digestion and ligation steps in favor of a faster, more efficient method. To obtain the expression vector, we combine all three plasmids in a recombination reaction; the step takes 12-16 hours total and yields reliable products that can be further verified through restriction digests and sequencing. <H2>Golden Gate</H2>
Golden Gate assembly is a one-pot method using restriction endonucleases that have a different cutting site than recognition site to assemble many parts of DNA together. It was developed in 2008 by Engler <I>et al</I> and is available <A href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0003647">here</A>. Using a directional restriction enzyme, which does not cut at the recognition site such as BsaI allows us to cut out parts that have specific overhangs with each other after cutting. Ligase is also in the reaction, which will ligate parts together; if it ligates a cutting sequence back together, these will simply be cut again. By the end, all the recognition sites will have be excised, leaving only the complete part. This summer, we used Golden Gate assembly for <A href="http://partsregistry.org/wiki/index.php?title=Part:BBa_K511400">Part:BBa_K511400</A> and <A href="http://partsregistry.org/wiki/index.php?title=Part:BBa_K511500">Part:BBa_K511500</A>.
<SMALL>Image taken from http://j5.jbei.org/j5manual/pages/23.html</SMALL><B>Process Overview</B>
A Golden Gate reaction can be set up via the following protocol. Take special care to use equimolar concentrations for each DNA fragment and high concentration ligase. <UL><LI>50 fmol of each DNA fragment </LI><LI>1 uL of Promega High Concentration T4 Ligase</LI><LI>1 uL of NEB BsaI</LI><LI>1 uL of Promega T4 Ligase Buffer</LI><LI>Water to 15 uL</LI></UL>
Cycle at:<UL><LI>(5 minutes at 37 C, 5 minutes at 18 C) x 50</LI><LI>10 minutes at 50 C</LI><LI>10 minutes at 80 C</LI></UL><H2>Gibson</H2> 
Gibson assembly is a high-efficiency scarless method of assembling multiple large pieces of DNA at once without the need for restriction enzymes. It was developed in 2009 by Gibson <I>et al</I> and is available <A href="http://www.synbio.org.uk/gibson/resources/Gibson2009_nmeth.1318.pdf">here</A>. It uses an exonuclease to chew back the 5' overhang until the DNA parts hydrogen bond, a polymerase and ligase to replace and ligate the missing nucleotides. Enzyme activity is controlled through temperature cycling. This summer, we successfully used Gibson assembly to create some of our parts, such as <A href="http://partsregistry.org/wiki/index.php?title=Part:BBa_K511401">Part:BBa_K511401</A>. 

<B>Process Overview</B>
Primers are first designed to PCR on ~20bp overhangs onto each of the DNA parts to be assembled together. After this product is cleaned up, equimolar concentrations of DNA along with a Master Mix of enzymes are run for an hour at 50C, resulting in a product that can be immediately transformed into cells for propagation. 
</DIV><DIV class="content" id="colonycontent"><H1>Colony Picker</H1>
Depicted above is the 2011 MIT iGEM team's addition to the DARPA funded robot in collaboration with BU. We programmed a user interface for the colony picker that can be found <A href="http://semonr.scripts.mit.edu/picker.html">here</A>. A video of one of our instructors using our interface to guide the robot can be found <A href="http://people.csail.mit.edu/jbabb/picker.wmv">here</A>. The scanner can also be used a 2D barcode scanner, thanks to a collaboration with Ginkgo that allowed us to port their technology to the scanner.


Here is a screenshot of our user interface. 

<P>In addition, we developed a service that allows people to interface with the robot online to request automated restriction mapping or Gateway cloning.</P></DIV><DIV class="content" id="geneiouscontent"><H1><EM>Geneious</EM> - A Bioinformatics Suite for Synthetic Biology</H1>
This year, we assembled dozens of unique expression vectors from dozens of entry and destination vectors, some of which we assembled via Gibson or Golden Gate reactions. In order to keep track of this large volume of plasmids, primers, and sequencing results, we heavily relied on the Geneious bioinformatics suite. Geneious offers tools from primer design to virtual gel electrophoresis, excellent file sharing for collaborations, automatic in silico assembly of multi site LR reactions, and more. Geneious was a powerful tool for everything from analyzing our sequencing results to assembling fusion plasmids, and we are excited to have Geneious' host company, Biomatters Ltd., as a sponsor.
</DIV><DIV class="printfooter">
Retrieved from &quot;<A href="http://2011.igem.org/Team:MIT/Tools/">http://2011.igem.org/Team:MIT/Tools/</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:MIT/Tools/" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:MIT/Tools/" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:MIT/Tools/&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:MIT/Tools/&amp;oldid=262545" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2011.igem.org:Privacy_policy" title="2011.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2011.igem.org:General_disclaimer" title="2011.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></DIV></BODY></HTML>
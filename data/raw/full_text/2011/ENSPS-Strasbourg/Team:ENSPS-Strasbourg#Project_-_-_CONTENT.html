<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_ENSPS-Strasbourg_Project"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:ENSPS-Strasbourg/Project">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:ENSPS-Strasbourg/Project&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:ENSPS-Strasbourg/Project&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:ENSPS-Strasbourg/Project&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:ENSPS-Strasbourg/Project" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:ENSPS-Strasbourg/Project</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2011.igem.org</H3><DIV id="test"><UL id="menu"><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg">Home</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Team">Team</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Team#under">
				Students</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Team#advisors">
				Advisors</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Team#instructors">
				Instructors</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Team#ENSPS">
				School</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Team#UDS">
				University</A></LI></UL><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Background">Background</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Background#proj">
				Project</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Background#first">
				First step</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Modeling">Modeling</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Project">Software</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Project">
				Tools used</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Project#v1">
				Behavioral </A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Project#v2">
				Conservative</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Tutorial">Tutorial</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Future">Future plans</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Future#achiv">
				Achievements</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Future#next">
				Next version</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Project_management">Project management</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Attributions">Attributions</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Notebook">Notebook</A></LI><LI><A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Safety">Safety</A></LI></DIV><H1><SPAN class="mw-headline" id="Introduction">Introduction</SPAN></H1><H1><SPAN class="mw-headline" id="Choice_of_the_tools">Choice of the tools</SPAN></H1><P>The first step was to choose a programming language suitable for making our implementation. Ideally, we wanted to use the same language to program both GUI and file generation. 
In a previous project, we have already programed a GUI, in C++ language, with the framework QT creator.  Moreover, the C++ is a powerful multi-purpose language which could be suitable for making our file generation. Another advantage of C++ is that we have a C/C++ programming module in our course, and we thought that it was probably better to implement this program with a language we already knew.
We have so decided to use C++, for its versatility, and because we are quite used to it.
</P><P>&quot;Qt creator – presentation:&quot;
</P><P>Qt Creator is an integrated development environment (IDE) that provides tools to design and develop applications with the Qt application framework. Qt is designed for developing applications and user interfaces once and deploying them across several desktop and mobile operating systems.
</P><P>Then, we need to find an electronic circuit simulator which enables us to simulate the systems as electronic systems. For that, we choose SMASH (Dolphin), because this software is one of the most accomplished simulation software, so as to simulate both digital and analog electronics.
</P><H1><SPAN class="mw-headline" id="Version_1_-_.C2.AB_Behavioral_Code_Generator_.C2.BB">Version 1 - « Behavioral Code Generator »</SPAN></H1><H2><SPAN class="mw-headline" id="Introduction_2">Introduction</SPAN></H2><P>The first step of the project was to validate the concept of the program. We have so decided to build a first version of the software, with digital models. This version, entitled “Behavioral Code Generator”, permits the user to simulate a logic (or behavioral) version of the reactions of his system. This version enables the biologist to have a quick overview on the system, and could be useful for him before going further into the biobrick's conception</P><H2><SPAN class="mw-headline" id="Approach">Approach</SPAN></H2><P>The aim of this first implementation is to validate the idea of building a software which generates automatically models for each reaction of a system. Those models are electrical models of three basic biological mechanisms (inhibition, complexation and synthesis), written in VHDL, as seen in the <A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Modeling#vhdlmodels" class="external text" rel="nofollow">Models section</A>. After that, this generation can be simulated directly with an electronic circuit simulator, as a digital electronic circuit.</P><H2><SPAN class="mw-headline" id="File_generation">File generation</SPAN></H2><P>The goal is to generate automatically VHDL files which are representative of the different reactions of the system. For that, our approach is to use pattern files, and to fill up those files with the right variables (species, names…), depending on the reactions implemented by the user.</P><P>To simulate a system, the electric simulator needs several files:
•	One VHDL description per entity
•	A test-bench file</P><H3><SPAN class="mw-headline" id="Entity_files">Entity files</SPAN></H3><H4><SPAN class="mw-headline" id="Principle:">Principle:</SPAN></H4><P>At each entity (or each reaction) corresponds a VHDL file. An example of VHDL pattern file is available below:</P><P>
This file defines the structure of all the VHDL files which will contain a synthesis reaction. It is the same file for every synthesis reaction the user will create. Then, several parameters have to be changed. All the expressions between the symbols “%%” are attributes of the reaction:
•	ENTITY_NAME: Name of the reaction (given by the user)
•	PORT_DECLARATION: This section will contain the different variables (species) of the reaction, and if those species are inputs or outputs
•	LOGICAL_EQUATION: In this section, the model of the reaction, described by a logical equation, is inserted so as to have the right behavior between inputs and outputs
In the image below, you can see a correctly filled pattern file. Indeed, the entity name has been replaced by the name of the reaction given by the user, the different species involved into the reaction ( ZFP0 and ZFP3 in input, GFP in output), are correctly mapped, and the logical equation is automatically established (in this case GFP is synthetized only if there is ZFP0 (the activator) and not ZFP3 (the repressor) ).</P><H3><SPAN class="mw-headline" id="How_does_it_work.3F">How does it work?</SPAN></H3><P>The C++ code, linked with the GUI, stock the different species and reactions involved in the system. A special Class architecture of the code, based on heritage, enables the program to know exactly which species are involved in which reaction. This heritage structure is explained in the following scheme:</P><P>Basically, each part of this scheme is a class of our implementation. Each of this class has attributes. The question is: What do I need to know to describe each part? 
- The system needs to know 1)how the user wants to call it 2)which are the different reactions involved into it 
- Each reaction needs to know 1)its name (given by the user), 2)its type (inhibition, complexation or synthesis) and 3) which are the inputs and output species 
- Each species of the system needs to know 1)its name, and 2) its initial value </P><P>Then, we have all the information we need to start building our system. We have so implented several functions and methods so as to extract, list, classify this information, all this amount of data, and process it to build a system. </P><P>The software architecture is based on two QT main functionalities, the Main Window and the Manager. The Main window is the interface between the software and the user. From this window, the user can talk with the software, enter the species, parameters, reaction, etc…  The user builds all the reaction blocks with this interface. Then, to generate automatically the VHDL files associated with the system, the Manager analyses the different reactions, makes links between those blocks and generate the simulation files. This Manager is the crucial part of the architecture, and a lot of work has also been done to make the generation as automatic and reliable as possible. This is the invisible part of the work, the immerged part of the Iceberg. When the user press “generate the system”,  this manager is activated and realizes the file generation.
</P><H3><SPAN class="mw-headline" id="Test_Bench_Generation">Test Bench Generation</SPAN></H3><P>The Test-bench is necessary to perform a good simulation. This file gathers all the reactions of the system, and builds the links between the different reactions. The test-bench generation is the crucial part of the system generation. An example of a test-bench is available below. </P><P>Once again, the principle is the same as entity files. Some parameters have to be added to completely fill the file. The principle of the test bench is so to gather the device's entities (or the system's reactions), and interconnect them together.
- TB_ENTITY_NAME: name of the system (given by the user)</P><P>- TB_ARCHITECTURE_NAME: this name is useful for the simulation, and is automatically generated by the program. It is a VHDL specificity, so we are not going into detail here. 
- TB_SIGNAL_DECLARATION: the simulator needs to know how many different variables (species) there are into the system. THose variables as represented as signals (another VHDL specificity). So, the program has to list all the species involved, and associate to them a signal.</P><P>- TB_PORT_MAP: This is the crucial part of our work. To perform a simulation, the simulation needs to know how each entity (reaction) is connected. Until know, we have just implemented several blocks separately. Now, those blocks have to be interconnected together.
</P><P>Then, thanks to the Manager code architecture, the test bench is filled with the right values. An example can be seen below.
</P><P>The important part of the test bench is to gather the different components (reactions), and to map them so as to build the system. For gathering the different reactions, there are no specific issues for complexation and synthesis, but the interconnection is getting trickier with the inhibition (this issue is explained in the “Issue Faced” section below. Basically, the program goes into the different reactions, pick up the species, and if those species are the same the program know that they are interconnected. This mechanisms enables the test-bench generation</P><H3><SPAN class="mw-headline" id="Simulation_File_Generation:">Simulation File Generation:</SPAN></H3><P>To perform a simulation into SMASH software, we need to create an additional simulation file. This file gathers all the information the simulation software has to know to simulate the system. There are:
•	The list of the VHDL entity files (one file per reaction) to know how many components (reactions) are involved
•	The name of the test bench (this file will be elaborated to have the whole system)
•	The simulation parameters (start and stop simulation times, step of the simulation)</P><P>Those parameters are generated automatically, or by the user for the simulation parameters.
</P><H2><SPAN class="mw-headline" id="Issue_Faced">Issue Faced</SPAN></H2><H3><SPAN class="mw-headline" id="Inhibition">Inhibition</SPAN></H3><P>During the implementation of the program, some issues had to be overcome so as to make the file generation properly working.
</P><P>
To gather all the reactions together, the initial approach is to give the same species names, and link those names as illustrated in the figure below. 
</P><P>We could imagine than we want to link the output of CPLX1 and one of the input of SYNTH1 (in other words, the protein which is the result of the complexation between A and B is an activator or a repressor for the synthesis of the protein Y). Then, if both has the same name, the link could be done by the implementation.
</P><P>This principle works for complexation and synthesis, but for inhibition, this association gets trickier. The problem is illustrated below: 
</P><P>If we want to use a protein (for example E in the above scheme) as an input of another reaction (for example an activator or repressor of SYNTH1), but if this species E can be inhibited by another one, we could not connect directly neither E nor the Inhibitor as an input of the synthesis.
</P><P>To solve this problem, we have decided to create another species, a fictive species, which is the result of the inhibition (E_inh for example here). Then, we associate this new species as an input for the synthesis reaction. This work has to be done for every species which can be inhibited. This methos is illustrated here:
</P><H1><SPAN class="mw-headline" id="Version_2_-_.C2.AB_Conservative_Code_Generation_.C2.BB">Version 2 - « Conservative Code Generation »</SPAN></H1><H2><SPAN class="mw-headline" id="Introduction_3">Introduction</SPAN></H2><P>The first version of the program has validated the concept of our program. Then, we could extend this concept to analog models. With a similar approach, we have built an extension of our software which will enable us to simulate conservative models of the bio-system.
</P><H2><SPAN class="mw-headline" id="Approach_2">Approach</SPAN></H2><P>The approach we use is basically the same than the behavioral version. New pattern files have been created to generate VHDL-AMS files. But this new version has several specificities, because of the language used to describe the reactions. Several new files need to be generated in order to build this new system.
But, as explained in the Models part, the VHDL-AMS models are totally different from the VHDL ones. The VHDL-AMS model is now composed of several electronic elementary elements like resistors, capacitors, etc…
</P><H2><SPAN class="mw-headline" id="File_generation_2">File generation</SPAN></H2><H3><SPAN class="mw-headline" id="Entities_files">Entities files</SPAN></H3><P>The generation of the different entities (reactions) is made in the same way than the behavioral ones. A synthesis pattern file is presented below:
</P><P>The filling principle is the same, all the parameters are between “%%” are replaced by the right values.
</P><H3><SPAN class="mw-headline" id="Other_files">Other files</SPAN></H3><P>But, to perform the conservative simulation, in addition to the entity (reaction) and test-bench files, we have to generate files for each of the species involved. Each species is represented by a set of those electronic elements, and this set is used or not, depending on the type of the reaction.
The new files which have to be generated are resistor and capacitor representatives of the different species of the system. We will not going into details in this part because it is a VHDL-AMS specificity. But basically, the set of parameters is different depending if the species are input or output of a reaction. If the species is an input, it is represented just as a resistor. If this species is an output, it is represented by a capacitor and a resistor, as explained in the <A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Modeling#vhdlmodels" class="external text" rel="nofollow">Models part</A>, but also intermediate mRNA has to be generated, also represented as a resistor and a capacitor. 
An example of those files is available below:
</P><P>The architecture of the code stays the same as in the section <A href="https://2011.igem.org/Team:ENSPS-Strasbourg/Project#how" class="external text" rel="nofollow">“How does it work?”</A>.
</P><H3><SPAN class="mw-headline" id="Test_bench">Test bench</SPAN></H3><P>The test bench is generated from a pattern file, with the same manner as the Behavioral test –bench.
</P><P>Here, to gather the different blocks is less tricky than for the behavioral model. Indeed, the inhibition is not useful for this type of models, so the issue with inhibition is absent. Another reason is the specificity of VHDL-AMS language. In fact, the language has to know the different nodes involved in the system. Each node is a place where more than one signal is connected. Then, the program has to specify each node of the system, and several species can be connected to this node, the gathering of the different blocks is so less difficult here.
</P><H3><SPAN class="mw-headline" id="Simulation_File">Simulation File</SPAN></H3><P>The simulation file is the same than the behavioral file.
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2011.igem.org/Team:ENSPS-Strasbourg/Project">http://2011.igem.org/Team:ENSPS-Strasbourg/Project</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:ENSPS-Strasbourg/Project" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:ENSPS-Strasbourg/Project" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:ENSPS-Strasbourg/Project&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:ENSPS-Strasbourg/Project&amp;oldid=158769" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2011.igem.org:Privacy_policy" title="2011.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2011.igem.org:General_disclaimer" title="2011.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
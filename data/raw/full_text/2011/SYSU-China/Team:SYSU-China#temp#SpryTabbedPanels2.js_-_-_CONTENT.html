<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_SYSU-China_temp_SpryTabbedPanels2_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:SYSU-China/temp/SpryTabbedPanels2.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:SYSU-China/temp/SpryTabbedPanels2.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryTabbedPanels2.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryTabbedPanels2.js&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:SYSU-China/temp/SpryTabbedPanels2.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:SYSU-China/temp/SpryTabbedPanels2.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2011.igem.org</H3><P>// SpryTabbedPanels2.js - version 0.9 - Spry Pre-Release 1.7
//
// Copyright (c) 2010. Adobe Systems Incorporated.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//   * Neither the name of Adobe Systems Incorporated nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
</P><P>(function() { // BeginSpryComponent
</P><P>if (typeof Spry == &quot;undefined&quot; || !Spry.Widget || !Spry.Widget.Base)
{
	alert(&quot;SpryTabbedPanels2.js requires SpryWidget.js!&quot;);
	return;
}
</P><P>if (!Spry.Widget) Spry.Widget = {};
</P><P>var defaultConfig = {
	defaultTab:               0,     // Show the first panel by default.
	event:                    &quot;click&quot;,  // DOM Event name to trigger the panel change; click or mouseover.
	hideHeader:               true,  // Hide the header elements used to create the tabs.
	tabsPosition:             &quot;top&quot;, // One of &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;.
</P><P>	// Slide show features.
	autoPlay:                 false, // Start the slide show immediately after the widget is created.
	displayInterval:          5000,  // Interval (msecs) between display of each panel.
	stopOnUserAction:         true,  // If the user clicks on a tab, stop the slide show.
</P><P>	injectionType:            &quot;replace&quot;,    // &quot;inside&quot; or &quot;replace&quot;
</P><P>	tabSelector:              &quot;h1,h2,h3,h4,h5,h6&quot;,
	contentDelimiterSelector:  null,  // When null, the tabSelector is used to find the delimiter.
</P><P>	widgetClass:              &quot;TabbedPanels&quot;,
	tabClass:                 &quot;TabbedPanelsTab&quot;,     // Class name used for the tab elements.
	contentClass:             &quot;TabbedPanelsContent&quot;, // Class name used for the content panel elements.
</P><P>	// These strings are used as class names placed on every element used
	// within the widget markup.
	tabHoverClass:            &quot;TabbedPanelsTabHover&quot;,
	tabSelectedClass:         &quot;TabbedPanelsTabSelected&quot;,
	tabFocusedClass:          &quot;TabbedPanelsTabFocused&quot;,
	panelVisibleClass:        &quot;TabbedPanelsContentVisible&quot;,
</P><P>	groupClassStr:            &quot;Group&quot;,
	firstClassStr:            &quot;First&quot;,
	lastClassStr:             &quot;Last&quot;,
</P><P>	plugIns:             [],
	sliceMap:            {},
</P><P>	// After the widget markup is generated and inserted into the document, you
	// can have the widget automatically remove and/or add any class name to the
	// top-level element that contains the tab and content group element.
	classToRemove:             &quot;&quot;,
	classToAdd:                &quot;&quot;,
</P><P>	enableKeyboardNavigation:  true
};
</P><P>Spry.Widget.TabbedPanels2 = function(element, opts)
{
	this.element = this.getElement(element);
</P><P>	// This is the top-level element of the tabbed panel that is injected at
	// runtime.
</P><P>	this.widgetRoot = null;
</P><P>	this.tgObj = null;
	this.cgObj = null;
</P><P>	// Initialize to global configuration defaults.
</P><P>	this.setOptions(this, Spry.Widget.TabbedPanels2.config);
</P><P>	// Pick up the configuration overrides.
</P><P>	this.setOptions(this, opts);
</P><P>	if (this.tabsPosition == &quot;bottom&quot; || this.tabsPosition == &quot;right&quot;) {
		this.tabsAfterContent = true;
	} else {
		this.tabsAfterContent = false;
	}
</P><P>	// Initialize any plugins.
</P><P>	this.initializePlugIns(Spry.Widget.TabbedPanels2.config.plugIns, opts);
</P><P>	var evt = new Spry.Widget.Event(this);
	this.notifyObservers(&quot;onPreInitialize&quot;, evt);
	if (!evt.performDefaultAction)
		return;
</P><P>	this.transformMarkup();
	this.attachBehaviors();
</P><P>	this.notifyObservers(&quot;onPostInitialize&quot;, evt);
};
</P><P>Spry.Widget.TabbedPanels2.config = defaultConfig;
</P><P>Spry.Widget.TabbedPanels2.prototype = new Spry.Widget.Base();
Spry.Widget.TabbedPanels2.prototype.constructor = Spry.Widget.TabbedPanels2;
</P><P>Spry.Widget.TabbedPanels2.prototype.transformMarkup = function()
{
	var evt = new Spry.Widget.Event(this);
	this.notifyObservers(&quot;onPreTransformMarkup&quot;, evt);
	if (!evt.performDefaultAction)
		return;
</P><P>	// Find the elements, within the initial markup, that will serve as the
	// content for the tab buttons.
</P><P>	var tabContent = Spry.$$(this.tabSelector, this.element);
</P><P>	// Find the elements, within the initial markup, that will serve as the
	// delimiter between content. This is usually the element that contains
	// the content for the tabbed buttons.
</P><P>	var delimSelector = this.contentDelimiterSelector;
	if (!delimSelector)
		delimSelector = this.tabSelector;
</P><P>	var delimiters = Spry.$$(delimSelector, this.element);
</P><P>	if (tabContent.length != delimiters.length)
		alert(&quot;SpryTabbedPanels2.js - WARNING: Mismatch between tab elements and content delimiters!&quot;);
	if (tabContent.length == 0)
	{
		alert(&quot;SpryTabbedPanels2.js - ERROR: Failed to find tab markup.&quot;);
		return;
	}
</P><P>	// Create the widget element, and slice it.
	var root = this.createOptionalSlicedStructure(null, &quot;div&quot;, this.widgetClass);
</P><P>	if (this.widgetID)
		root.id = this.widgetID;
</P><P>	// Create the tab group element, and slice it.
</P><P>	this.tgObj = this.createOptionalSlicedStructure(null ,&quot;div&quot;, this.tabClass + this.groupClassStr);
	// For each tab content element, create a tab markup structure and add it
	// to the content container of the tab group.
</P><P>	var numTabs = tabContent.length;
	var lastTabIndex = numTabs - 1;
</P><P>	for (var i = 0; i &lt; numTabs; i++)
	{
		var t = this.createOptionalSlicedStructure(null, &quot;div&quot;, this.tabClass);
		var txt = this.getElementText(tabContent[i]);
		var linkEle = document.createElement(&quot;a&quot;);
		linkEle.href = &quot;#&quot;;
		linkEle.appendChild(document.createTextNode(txt));
		t.contentContainer.appendChild(linkEle);
</P><P>		// If this the first or last tab, add our special class name to it.
		if (i == 0)
			this.addClassName(t, this.tabClass + this.firstClassStr);
		if (i == lastTabIndex)
			this.addClassName(t, this.tabClass + this.lastClassStr);
</P><P>		this.tgObj.contentContainer.appendChild(t);
</P><P>		if (tabContent[i].id) {
			t.id = tabContent[i].id;
			tabContent[i].removeAttribute(&quot;id&quot;);
		}
		var ti = parseInt(tabContent[i].getAttribute(&quot;tabIndex&quot;));
		if (!isNaN(ti)) {
			t.tabIndex = tabContent[i].tabIndex;
			tabContent[i].removeAttribute(&quot;tabindex&quot;);
		} 
</P><P>		// Hide the initial tab content if necessary.
</P><P>		if (this.hideHeader)
			tabContent[i].style.display = &quot;none&quot;;
	}
</P><P>	// Create a content group element and fill it with the optional slice element structure.
</P><P>	this.cgObj = this.createOptionalSlicedStructure(null, &quot;div&quot;, this.contentClass + this.groupClassStr);
</P><P>	// The content for each panel follows the delimiter element. For each tab content element,
	// grab the nodes that follow it, up until the next tab content element, and stick it
	// into a tabbed panel content structure.
</P><P>	for (var i = 0; i &lt; delimiters.length; i++)
	{
		// Create a content panel and fill it with the 9-slice structure, then
		// add it to the content group.
</P><P>		var c = this.createOptionalSlicedStructure(null, &quot;div&quot;, this.contentClass);
		this.cgObj.contentContainer.appendChild(c);
</P><P>		// Grab all of the content that follows the tab content element and stick
		// it into the content structure we just created.
</P><P>		var d = delimiters[i];
		var nd = delimiters[i+1];
</P><P>		while (d &amp;&amp; d != nd)
		{
			var ns = d.nextSibling;
			c.contentContainer.appendChild(d);
			d = ns;
		}
</P><P>		// Hide the delimiter content if necessary.
</P><P>		if (this.hideHeader)
			delimiters[i].style.display = &quot;none&quot;;
	}
</P><P>	while (this.element.firstChild)
		this.element.removeChild(this.element.firstChild);
</P><P>	// Insert the tab and content groups into the document.
	if (this.tabsAfterContent)
	{
		root.contentContainer.appendChild(this.cgObj);
		root.contentContainer.appendChild(this.tgObj);
	}
	else
	{
		root.contentContainer.appendChild(this.tgObj);
		root.contentContainer.appendChild(this.cgObj);
	}
</P><P>	// Insert our newly constructed widget structure into the document.
</P><P>	if (this.injectionType == &quot;replace&quot;)
	{
		var parent = this.element.parentNode;
		parent.replaceChild(root, this.element);
		this.element = root;
	}
	else // &quot;inside&quot;
	{
		this.element.innerHTML = &quot;&quot;;
		this.element.appendChild(root);
	}
</P><P>	this.widgetRoot = root;
</P><P>	if (this.tabsPosition == &quot;bottom&quot;)
	{
		this.addClassName(this.widgetRoot, &quot;BTabbedPanels&quot;);
	}
	if (this.tabsPosition == &quot;left&quot; || this.tabsPosition == &quot;right&quot;)
	{
		this.removeClassName(this.widgetRoot, &quot;TabbedPanels&quot;);
		this.addClassName(this.widgetRoot, &quot;VTabbedPanels&quot;);
	}
</P><P>	if (this.classToRemove)
		this.removeClassName(this.widgetRoot, this.classToRemove);
</P><P>	if (this.classToAdd)
		this.addClassName(this.widgetRoot, this.classToAdd);
</P><P>
	this.notifyObservers(&quot;onPostTransformMarkup&quot;, evt);
};
</P><P>Spry.Widget.TabbedPanels2.prototype.getElementText = function(ele)
{
	var ta = [];
	var c = ele.firstChild;
	while (c)
	{
		if (c.nodeType == 3 || c.nodeType == 4) // Node.TEXT_NODE || Node.CDATA_NODE
			ta.push(c.data);
		else if (c.firstChild)
		{
			var str = this.getElementText(c);
			if (str)
				ta.push(str);
		}
		c = c.nextSibling;
	}
	return ta.join(&quot;&quot;);
};
</P><P>Spry.Widget.TabbedPanels2.prototype.getTabs = function()
{
	var tabs = [];
	if (this.element &amp;&amp; this.tgObj &amp;&amp; this.tgObj.contentContainer)
		tabs = this.getElementChildren(this.tgObj.contentContainer);
	return tabs;
};
</P><P>Spry.Widget.TabbedPanels2.prototype.getContentPanels = function()
{
	var panels = [];
	if (this.element &amp;&amp; this.cgObj &amp;&amp; this.cgObj.contentContainer)
		panels = this.getElementChildren(this.cgObj.contentContainer);
	return panels;
};
</P><P>Spry.Widget.TabbedPanels2.prototype.getTabbedPanelCount = function(ele)
{
	return Math.min(this.panelSelector.getButtonCount(), this.panelSet.getPanelCount());
};
</P><P>Spry.Widget.TabbedPanels2.prototype.getTabIndex = function(ele)
{
	return this.panelSelector.elementToIndex(ele);
};
</P><P>Spry.Widget.TabbedPanels2.prototype.getCurrentTabIndex = function()
{
	return this.panelSelector.getCurrentButtonIndex();
};
</P><P>Spry.Widget.TabbedPanels2.prototype.showPanel = function(idxOrId) {
	this.panelSelector.handleActivate(idxOrId);
};
</P><P>Spry.Widget.TabbedPanels2.prototype.showPreviousPanel = function()
{
	this.panelSelector.selectPreviousButton();
};
</P><P>Spry.Widget.TabbedPanels2.prototype.showNextPanel = function()
{
	this.panelSelector.selectNextButton();
};
</P><P>Spry.Widget.TabbedPanels2.prototype.showFirstPanel = function()
{
	this.panelSelector.selectFirstButton();
};
</P><P>Spry.Widget.TabbedPanels2.prototype.showLastPanel = function()
{
	this.panelSelector.selectLastButton();
};
</P><P>Spry.Widget.TabbedPanels2.prototype.markOpenPanel = function(panel)
{
	var panels = this.panelSet.getPanels();
</P><P>	for (var i = 0; i &lt; panels.length; i++)
	{
		var p = panels[i];
		if (panel == p)
		{
			this.addClassName(p, this.panelVisibleClass);
			p.style.display = &quot;block&quot;;
		} else {
			this.removeClassName(p, this.panelVisibleClass);
			p.style.display = &quot;none&quot;;
		}
	}
};
</P><P>Spry.Widget.TabbedPanels2.prototype.attachBehaviors = function()
{
	var evt = new Spry.Widget.Event(this);
	this.notifyObservers(&quot;onPreAttachBehaviors&quot;, evt);
	if (!evt.performDefaultAction)
		return;
</P><P>	this.attachViewBehaviors();
	this.attachTabBehaviors();
</P><P>	this.notifyObservers(&quot;onPostAttachBehaviors&quot;, evt);	
};
</P><P>
Spry.Widget.TabbedPanels2.prototype.attachViewBehaviors = function()
{
	var evt = new Spry.Widget.Event(this);
	this.notifyObservers(&quot;onPreAttachViewBehaviors&quot;, evt);
	if (!evt.performDefaultAction)
		return;
</P><P>	var panels = this.getContentPanels();
	this.panelSet = new Spry.Widget.PanelSet(panels, {
		defaultPanel:this.defaultTab,
		autoPlay:this.autoPlay,
		displayInterval: this.displayInterval,
		visibleClass: this.panelVisibleClass
	});
</P><P>	var self = this;
</P><P>	this.panelSet.addObserver({
		onPostShowPanel: function(n,d){
			self.markOpenPanel(d.target);
		}
	});
</P><P>	var p = this.panelSet.getCurrentPanel();
	if (p) {
		this.markOpenPanel(p);
	}
</P><P>	this.notifyObservers(&quot;onPostAttachViewBehaviors&quot;, evt);
};
</P><P>Spry.Widget.TabbedPanels2.prototype.attachTabBehaviors = function()
{
	var evt = new Spry.Widget.Event(this);
	this.notifyObservers(&quot;onPreAttachTabBehaviors&quot;, evt);
	if (!evt.performDefaultAction)
		return;
</P><P>	var tabs = this.getTabs();
</P><P>	this.panelSelector = new Spry.Widget.PanelSelector(tabs, this.panelSet, {
		event: this.event,
		selectionStopsSlideShow:this.stopOnUserAction,
		defaultButton:this.defaultTab,
		selectedClass: this.tabSelectedClass,
		focusedClass: this.tabFocusedClass,
		hoverClass: this.tabHoverClass
	});
</P><P>	this.notifyObservers(&quot;onPostAttachTabBehaviors&quot;, evt);
};
</P><P>})(); // EndSpryComponent
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2011.igem.org/Team:SYSU-China/temp/SpryTabbedPanels2.js">http://2011.igem.org/Team:SYSU-China/temp/SpryTabbedPanels2.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:SYSU-China/temp/SpryTabbedPanels2.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:SYSU-China/temp/SpryTabbedPanels2.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryTabbedPanels2.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryTabbedPanels2.js&amp;oldid=231636" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2011.igem.org:Privacy_policy" title="2011.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2011.igem.org:General_disclaimer" title="2011.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
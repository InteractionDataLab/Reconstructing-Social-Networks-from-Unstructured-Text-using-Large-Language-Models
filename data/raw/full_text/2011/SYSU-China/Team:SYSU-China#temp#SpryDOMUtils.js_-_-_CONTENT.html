<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_SYSU-China_temp_SpryDOMUtils_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:SYSU-China/temp/SpryDOMUtils.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:SYSU-China/temp/SpryDOMUtils.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryDOMUtils.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryDOMUtils.js&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:SYSU-China/temp/SpryDOMUtils.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:SYSU-China/temp/SpryDOMUtils.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2011.igem.org</H3><P>// SpryDOMUtils.js - version 0.13 - Spry Pre-Release 1.7
//
// Copyright (c) 2007. Adobe Systems Incorporated.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//   * Neither the name of Adobe Systems Incorporated nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
</P><P>(function() { // BeginSpryComponent
</P><P>if (typeof Spry == &quot;undefined&quot;) window.Spry = {}; if (!Spry.Utils) Spry.Utils = {};
</P><P>//////////////////////////////////////////////////////////////////////
//
// Define Prototype's $() convenience function, but make sure it is
// namespaced under Spry so that we avoid collisions with other
// toolkits.
//
//////////////////////////////////////////////////////////////////////
</P><P>Spry.$ = function(element)
{
	if (arguments.length &gt; 1)
	{
		for (var i = 0, elements = [], length = arguments.length; i &lt; length; i++)
			elements.push(Spry.$(arguments[i]));
		return elements;
	}
	if (typeof element == 'string')
		element = document.getElementById(element);
	return element;
};
</P><P>//////////////////////////////////////////////////////////////////////
//
// DOM Utils
//
//////////////////////////////////////////////////////////////////////
</P><P>Spry.Utils.getAttribute = function(ele, name)
{
	ele = Spry.$(ele);
	if (!ele || !name)
		return null;
</P><P>	// We need to wrap getAttribute with a try/catch because IE will throw
	// an exception if you call it with a namespace prefixed attribute name
	// that doesn't exist.
</P><P>	try { var value = ele.getAttribute(name); }
	catch (e) { value == undefined; }
</P><P>	// XXX: Workaround for Safari 2.x and earlier:
	//
	// If value is undefined, the attribute didn't exist. Check to see if this is
	// a namespace prefixed attribute name. If it is, remove the ':' from the name
	// and try again. This allows us to support spry attributes of the form
	// &quot;spry:region&quot; and &quot;spryregion&quot;.
</P><P>	if (value == undefined &amp;&amp; name.search(/:/) != -1)
	{
		try { var value = ele.getAttribute(name.replace(/:/, &quot;&quot;)); }
		catch (e) { value == undefined; }
	}
</P><P>	return value;
};
</P><P>Spry.Utils.setAttribute = function(ele, name, value)
{
	ele = Spry.$(ele);
	if (!ele || !name)
		return;
</P><P>	// IE doesn't allow you to set the &quot;class&quot; attribute. You
	// have to set the className property instead.
</P><P>	if (name == &quot;class&quot;)
		ele.className = value;
	else
	{
		// I'm probably being a bit paranoid, but given the fact that
		// getAttribute() throws exceptions when dealing with namespace
		// prefixed attributes, I'm going to wrap this setAttribute()
		// call with try/catch just in case ...
</P><P>		try { ele.setAttribute(name, value); } catch(e) {}
</P><P>		// XXX: Workaround for Safari 2.x and earlier:
		//
		// If this is a namespace prefixed attribute, check to make
		// sure an attribute was created. This is necessary because some
		// older versions of Safari (2.x and earlier) drop the namespace
		// prefixes. If the attribute was munged, try removing the ':'
		// character from the attribute name and setting the attribute
		// using the resulting name. The idea here is that even if we
		// remove the ':' character, Spry.Utils.getAttribute() will still
		// find the attribute.
</P><P>		if (name.search(/:/) != -1 &amp;&amp; ele.getAttribute(name) == undefined)
			ele.setAttribute(name.replace(/:/, &quot;&quot;), value);
	}
};
</P><P>Spry.Utils.removeAttribute = function(ele, name)
{
	ele = Spry.$(ele);
	if (!ele || !name)
		return;
</P><P>	try { ele.removeAttribute(name); } catch(e) {}
</P><P>	// XXX: Workaround for Safari 2.x and earlier:
	//
	// If this is a namespace prefixed attribute, make sure we
	// also remove any attributes with the same name, but without
	// the ':' character.
</P><P>	if (name.search(/:/) != -1)
		ele.removeAttribute(name.replace(/:/, &quot;&quot;));
</P><P>	// XXX: Workaround for IE
	//
	// IE doesn't allow you to remove the &quot;class&quot; attribute.
	// It requires you to remove &quot;className&quot; instead, so go
	// ahead and try to remove that too.
</P><P>	if (name == &quot;class&quot;)
		ele.removeAttribute(&quot;className&quot;);
};
</P><P>Spry.Utils.addClassName = function(ele, className)
{
	ele = Spry.$(ele);
	if (!ele || !className || (ele.className &amp;&amp; ele.className.search(new RegExp(&quot;\\b&quot; + className + &quot;\\b&quot;)) != -1))
		return;
	ele.className += (ele.className ? &quot; &quot; : &quot;&quot;) + className;
};
</P><P>Spry.Utils.removeClassName = function(ele, className)
{
	ele = Spry.$(ele);
	if (Spry.Utils.hasClassName(ele, className))
		ele.className = ele.className.replace(new RegExp(&quot;\\s*\\b&quot; + className + &quot;\\b&quot;, &quot;g&quot;), &quot;&quot;);
};
</P><P>Spry.Utils.toggleClassName = function(ele, className)
{
	if (Spry.Utils.hasClassName(ele, className))
		Spry.Utils.removeClassName(ele, className);
	else
		Spry.Utils.addClassName(ele, className);
};
</P><P>Spry.Utils.hasClassName = function(ele, className)
{
	ele = Spry.$(ele);
	if (!ele || !className || !ele.className || ele.className.search(new RegExp(&quot;\\b&quot; + className + &quot;\\b&quot;)) == -1)
		return false;
	return true;
};
</P><P>Spry.Utils.camelizeString = function(str)
{
	var cStr = &quot;&quot;;
	var a = str.split(&quot;-&quot;);
	for (var i = 0; i &lt; a.length; i++)
	{
		var s = a[i];
		if (s)
			cStr = cStr ? (cStr + s.charAt(0).toUpperCase() + s.substring(1)) : s;
	}
	return cStr;
};
</P><P>Spry.Utils.styleStringToObject = function(styleStr)
{
	var o = {};
	if (styleStr)
	{
		var pvA = styleStr.split(&quot;;&quot;);
		for (var i = 0; i &lt; pvA.length; i++)
		{
			var pv = pvA[i];
			if (pv &amp;&amp; pv.indexOf(&quot;:&quot;) != -1)
			{
				var nvA = pv.split(&quot;:&quot;);
				var n = nvA[0].replace(/^\s*|\s*$/g, &quot;&quot;);			
				var v = nvA[1].replace(/^\s*|\s*$/g, &quot;&quot;);
				if (n &amp;&amp; v)
					o[Spry.Utils.camelizeString(n)] = v;
			}
		}
	}
	return o;
};
</P><P>Spry.Utils.addEventListener = function(element, eventType, handler, capture)
{
	try
	{
		if (!Spry.Utils.eventListenerIsBoundToElement(element, eventType, handler, capture))
		{
			element = Spry.$(element);
			handler = Spry.Utils.bindEventListenerToElement(element, eventType, handler, capture);
			if (element.addEventListener)
				element.addEventListener(eventType, handler, capture);
			else if (element.attachEvent)
				element.attachEvent(&quot;on&quot; + eventType, handler);
		}
	}
	catch (e) {}
};
</P><P>Spry.Utils.removeEventListener = function(element, eventType, handler, capture)
{
	try
	{
			element = Spry.$(element);
			handler = Spry.Utils.unbindEventListenerFromElement(element, eventType, handler, capture);
			if (element.removeEventListener)
				element.removeEventListener(eventType, handler, capture);
			else if (element.detachEvent)
				element.detachEvent(&quot;on&quot; + eventType, handler);
	}
	catch (e) {}
};
</P><P>Spry.Utils.eventListenerHash = {};
Spry.Utils.nextEventListenerID = 1;
</P><P>Spry.Utils.getHashForElementAndHandler = function(element, eventType, handler, capture)
{
	var hash = null;
	element = Spry.$(element);
	if (element)
	{
		if (typeof element.spryEventListenerID == &quot;undefined&quot;)
			element.spryEventListenerID = &quot;e&quot; + (Spry.Utils.nextEventListenerID++);
		if (typeof handler.spryEventHandlerID == &quot;undefined&quot;)
			handler.spryEventHandlerID = &quot;h&quot; + (Spry.Utils.nextEventListenerID++);	
		hash = element.spryEventListenerID + &quot;-&quot; + handler.spryEventHandlerID + &quot;-&quot; + eventType + (capture?&quot;-capture&quot;:&quot;&quot;);
	}
	return hash;
};
</P><P>Spry.Utils.eventListenerIsBoundToElement = function(element, eventType, handler, capture)
{
	element = Spry.$(element);
	var hash = Spry.Utils.getHashForElementAndHandler(element, eventType, handler, capture);
	return Spry.Utils.eventListenerHash[hash] != undefined;
};
</P><P>Spry.Utils.bindEventListenerToElement = function(element, eventType, handler, capture)
{
	element = Spry.$(element);
	var hash = Spry.Utils.getHashForElementAndHandler(element, eventType, handler, capture);
	if (Spry.Utils.eventListenerHash[hash])
		return Spry.Utils.eventListenerHash[hash];
	return Spry.Utils.eventListenerHash[hash] = function(e)
	{
		e = e || window.event;
</P><P>		if (!e.preventDefault) e.preventDefault = function() { this.returnValue = false; };
		if (!e.stopPropagation) e.stopPropagation = function() { this.cancelBubble = true; };
</P><P>		var result = handler.call(element, e);
		if (result == false)
		{
			e.preventDefault();
			e.stopPropagation();
		}
		return result;
	};
};
</P><P>Spry.Utils.unbindEventListenerFromElement = function(element, eventType, handler, capture)
{
	element = Spry.$(element);
	var hash = Spry.Utils.getHashForElementAndHandler(element, eventType, handler, capture);
	if (Spry.Utils.eventListenerHash[hash])
	{
		handler = Spry.Utils.eventListenerHash[hash];
		Spry.Utils.eventListenerHash[hash] = undefined;
	}
	return handler;
};
</P><P>Spry.Utils.cancelEvent = function(e)
{
	if (e.preventDefault) e.preventDefault();
	else e.returnValue = false;
	if (e.stopPropagation) e.stopPropagation();
	else e.cancelBubble = true;
</P><P>	return false;
};
</P><P>
Spry.Utils.addLoadListener = function(handler)
{
	if (typeof window.addEventListener != 'undefined')
		window.addEventListener('load', handler, false);
	else if (typeof document.addEventListener != 'undefined')
		document.addEventListener('load', handler, false);
	else if (typeof window.attachEvent != 'undefined')
		window.attachEvent('onload', handler);
};
</P><P>Spry.Utils.isDescendant = function(parent, child)
{
	if (parent &amp;&amp; child)
	{
		child = child.parentNode;
		while (child)
		{
			if (parent == child)
				return true;
			child = child.parentNode;
		}
	}
	return false;
};
</P><P>Spry.Utils.getAncestor = function(ele, selector)
{
	ele = Spry.$(ele);
	if (ele)
	{
		var s = Spry.$$.tokenizeSequence(selector ? selector : &quot;*&quot;)[0];
		var t = s ? s[0] : null;
		if (t)
		{
			var p = ele.parentNode;
			while (p)
			{
				if (t.match(p))
					return p;
				p = p.parentNode;
			}
		}
	}
	return null;
};
</P><P>//////////////////////////////////////////////////////////////////////
//
// CSS Selector Matching
//
//////////////////////////////////////////////////////////////////////
</P><P>Spry.$$ = function(selectorSequence, rootNode)
{
	var matches = [];
	Spry.$$.addExtensions(matches);
</P><P>	// If the first argument to $$() is an object, it
	// is assumed that all args are either a DOM element
	// or an array of DOM elements, in which case we
	// simply append all DOM elements to our special
	// matches array and return immediately.
</P><P>	if (typeof arguments[0] == &quot;object&quot;)
	{
		for (var i = 0; i &lt; arguments.length; i++)
		{
			if (arguments[i].constructor == Array)
				matches.push.apply(matches, arguments[i]);
			else
				matches.push(arguments[i]);
		}
		return matches;
	}
</P><P>	if (!rootNode)
		rootNode = document;
	else
		rootNode = Spry.$(rootNode);
</P><P>	var sequences = Spry.$$.tokenizeSequence(selectorSequence);
</P><P>	++Spry.$$.queryID;
</P><P>	var nid = 0;
	var ns = sequences.length;
	for (var i = 0; i &lt; ns; i++)
	{
		var m = Spry.$$.processTokens(sequences[i], rootNode);
		var nm = m.length;
		for (var j = 0; j &lt; nm; j++)
		{
			var n = m[j];
			if (!n.spry$$ID)
			{
				n.spry$$ID = ++nid;
				matches.push(n);
			}
		}
	}
</P><P>	var nm = matches.length;
	for (i = 0; i &lt; nm; i++)
		matches[i].spry$$ID = undefined;
</P><P>	return matches;
};
</P><P>Spry.$$.cache = {};
Spry.$$.queryID = 0;
</P><P>Spry.$$.Token = function()
{
	this.type = Spry.$$.Token.SELECTOR;
	this.name = &quot;*&quot;;
	this.id = &quot;&quot;;
	this.classes = [];
	this.attrs = [];
</P><P>	this.pseudos = [];
};
</P><P>Spry.$$.Token.Attr = function(n, v)
{
	this.name = n;
	this.value = v ? new RegExp(v) : undefined;
};
</P><P>Spry.$$.Token.PseudoClass = function(pstr)
{
	this.name = pstr.replace(/\(.*/, &quot;&quot;);
	this.arg = pstr.replace(/^[^\(\)]*\(?\s*|\)\s*$/g, &quot;&quot;);
	this.func = Spry.$$.pseudoFuncs[this.name];
};
</P><P>Spry.$$.Token.SELECTOR = 0;
Spry.$$.Token.COMBINATOR = 1;
</P><P>Spry.$$.Token.prototype.match = function(ele, nameAlreadyMatches)
{
	if (this.type == Spry.$$.Token.COMBINATOR)
		return false;
	if (!nameAlreadyMatches &amp;&amp; this.name != '*' &amp;&amp; this.name != ele.nodeName.toLowerCase())
		return false;
	if (this.id &amp;&amp; this.id != ele.id)
		return false;
	var classes = this.classes;
	var len = classes.length;
	for (var i = 0; i &lt; len; i++)
	{
		if (!ele.className || !classes[i].value.test(ele.className))
			return false;
	}
</P><P>	var attrs = this.attrs;
	len = attrs.length;
	for (var i = 0; i &lt; len; i++)
	{
		var a = attrs[i];
		var an = ele.attributes.getNamedItem(a.name);
		if (!an || (!a.value &amp;&amp; an.nodeValue == undefined) || (a.value &amp;&amp; !a.value.test(an.nodeValue)))
			return false;
	}
</P><P>	var ps = this.pseudos;
	var len = ps.length;
	for (var i = 0; i &lt; len; i++)
	{
		var p = ps[i];
		if (p &amp;&amp; p.func &amp;&amp; !p.func(p.arg, ele, this))
			return false;
	}
</P><P>	return true;
};
</P><P>Spry.$$.Token.prototype.getNodeNameIfTypeMatches = function(ele)
{
	var nodeName = ele.nodeName.toLowerCase();
	if (this.name != '*')
	{
		if (this.name != nodeName)
			return null;
		return this.name;
	}
	return nodeName;
};
</P><P>Spry.$$.escapeRegExpCharsRE = /\/|\.|\*|\+|\(|\)|\[|\]|\{|\}|\\|\|/g;
</P><P>Spry.$$.tokenizeSequence = function(s)
{
	var cc = Spry.$$.cache[s];
	if (cc) return cc;
</P><P>	// Attribute Selector: /(\<A href="/wiki/index.php?title=%5E%5C%22%27%7E%5C%5E%5C$%5C*%5C&amp;action=edit&amp;redlink=1" class="new" title="^\&quot;'~\^\$\*\ (page does not exist)">\]=]+([~\^\$\*\|]?=\s*('[^']*'|&quot;[^&quot;]*&quot;|[^&quot;'\</A>+))?\s*\])/g
	// Simple Selector:    /((:[^\.#:\s,&gt;~\+\[\]]+\(([^\(\)]+|\([^\(\)]*\))*\))|[\.#:]?[^\.#:\s,&gt;~\+\[\]]+)/g
	// Combinator:         /(\s*[\s,&gt;~\+]\s*)/g
</P><P>	var tokenExpr = /(\<A href="/wiki/index.php?title=%5E%5C%22%27%7E%5C%5E%5C$%5C*%5C&amp;action=edit&amp;redlink=1" class="new" title="^\&quot;'~\^\$\*\ (page does not exist)">\]=]+([~\^\$\*\|]?=\s*('[^']*'|&quot;[^&quot;]*&quot;|[^&quot;'\</A>+))?\s*\])|((:[^\.#:\s,&gt;~\+\[\]]+\(([^\(\)]+|\([^\(\)]*\))*\))|[\.#:]?[^\.#:\s,&gt;~\+\[\]]+)|(\s*[\s,&gt;~\+]\s*)/g;
</P><P>	var tkn = new Spry.$$.Token;
	var sequence = [];
	sequence.push(tkn);
	var tokenSequences = [];
	tokenSequences.push(sequence);
</P><P>	s = s.replace(/^\s*|\s*$/, &quot;&quot;);
</P><P>	var expMatch = tokenExpr.exec(s);
	while (expMatch)
	{
		var tstr = expMatch[0];
		var c = tstr.charAt(0);
		switch (c)
		{
			case '.':
				tkn.classes.push(new Spry.$$.Token.Attr(&quot;class&quot;, &quot;\\b&quot; + tstr.substr(1) + &quot;\\b&quot;));
				break;
			case '#':
				tkn.id = tstr.substr(1);
				break;
			case ':':
				tkn.pseudos.push(new Spry.$$.Token.PseudoClass(tstr));
				break;
			case '[':
				var attrComps = tstr.match(/\[([^\&quot;'~\^\$\*\|\]=]+)(([~\^\$\*\|]?=)\s*('[^']*'|&quot;[^&quot;]*&quot;|[^&quot;'\]]+))?\s*\]/);
				var name = attrComps[1];				
				var matchType = attrComps[3];
				var val = attrComps[4];
				if (val)
				{
					val = val.replace(/^['&quot;]|['&quot;]$/g, &quot;&quot;);
					val = val.replace(Spry.$$.escapeRegExpCharsRE, '\\$&amp;');
				}
</P><P>				var matchStr = undefined;
</P><P>				switch(matchType)
				{
					case &quot;=&quot;:
						matchStr = &quot;^&quot; + val + &quot;$&quot;;
						break;
					case &quot;^=&quot;:
						matchStr = &quot;^&quot; + val;
						break;
					case &quot;$=&quot;:
						matchStr = val + &quot;$&quot;;
						break;
					case &quot;~=&quot;:
					case &quot;|=&quot;:
						matchStr = &quot;\\b&quot; + val + &quot;\\b&quot;;
						break;
					case &quot;*=&quot;:
						matchStr = val;
						break;
				}
</P><P>				tkn.attrs.push(new Spry.$$.Token.Attr(name, matchStr));
				break;
			default:
				var combiMatch = tstr.match(/^\s*([\s,~&gt;\+])\s*$/);
				if (combiMatch)
				{
					if (combiMatch[1] == ',')
					{
						sequence = new Array;
						tokenSequences.push(sequence);
						tkn = new Spry.$$.Token;
						sequence.push(tkn);
					}
					else
					{
						tkn = new Spry.$$.Token;
						tkn.type = Spry.$$.Token.COMBINATOR;
						tkn.name = combiMatch[1];
						sequence.push(tkn);
						tkn = new Spry.$$.Token();
						sequence.push(tkn);
					}
				}
				else
					tkn.name = tstr.toLowerCase();
				break;
		}
		expMatch = tokenExpr.exec(s);
	}
</P><P>	Spry.$$.cache[s] = tokenSequences;
</P><P>	return tokenSequences;
};
</P><P>Spry.$$.combinatorFuncs = {
	// Element Descendant
</P><P>	&quot; &quot;: function(nodes, token)
	{
		var uid = ++Spry.$$.uniqueID;
		var results = [];
		var nn = nodes.length;
		for (var i = 0; i &lt; nn; i++)
		{
			var n = nodes[i];
			if (uid != n.spry$$uid)
			{
				// n.spry$$uid = uid;
				var ea = nodes[i].getElementsByTagName(token.name);
				var ne = ea.length;
				for (var j = 0; j &lt; ne; j++)
				{
					var e = ea[j];
</P><P>					// If the token matches, add it to our results. We have
					// to make sure e is an element because IE6 returns the DOCTYPE
					// tag as a comment when '*' is used in the call to getElementsByTagName().
</P><P>					if (e.nodeType == 1 /* Node.ELEMENT_NODE */ &amp;&amp; token.match(e, true))
						results.push(e);
					e.spry$$uid = uid;
				}
			}
		}
		return results;
	},
</P><P>	// Element Child
</P><P>	&quot;&gt;&quot;: function(nodes, token)
	{
		var results = [];
		var nn = nodes.length;
		for (var i = 0; i &lt; nn; i++)
		{
			var n = nodes[i].firstChild;
			while (n)
			{
				if (n.nodeType == 1 /* Node.ELEMENT_NODE */ &amp;&amp; token.match(n))
					results.push(n);
				n = n.nextSibling;
			}
		}
		return results;
	},
</P><P>	// Element Immediately Preceded By
</P><P>	&quot;+&quot;: function(nodes, token)
	{
		var results = [];
		var nn = nodes.length;
		for (var i = 0; i &lt; nn; i++)
		{
			var n = nodes[i].nextSibling;
			while (n &amp;&amp; n.nodeType != 1 /* Node.ELEMENT_NODE */)
				n = n.nextSibling;
			if (n &amp;&amp; token.match(n))
				results.push(n);
		}
		return results;
	},
</P><P>	// Element Preceded By
</P><P>	&quot;~&quot;: function(nodes, token)
	{
		var uid = ++Spry.$$.uniqueID;
		var results = [];
		var nn = nodes.length;
		for (var i = 0; i &lt; nn; i++)
		{
			var n = nodes[i].nextSibling;
			while (n)
			{
				if (n.nodeType == 1 /* Node.ELEMENT_NODE */)
				{
					if (uid == n.spry$$uid)
						break;
</P><P>					if (token.match(n))
					{
						results.push(n);
						n.spry$$uid = uid;
					}
				}
				n = n.nextSibling;
			}
		}
		return results;
	}
};
</P><P>Spry.$$.uniqueID = 0;
</P><P>Spry.$$.pseudoFuncs = {
	&quot;:first-child&quot;: function(arg, node, token)
	{
		var n = node.previousSibling;
		while (n)
		{
			if (n.nodeType == 1) return false; // Node.ELEMENT_NODE
			n = n.previousSibling;
		}
</P><P>		return true;
	},
</P><P>	&quot;:last-child&quot;: function(arg, node, token)
	{
		var n = node.nextSibling;
		while (n)
		{
			if (n.nodeType == 1) // Node.ELEMENT_NODE
				return false;
			n = n.nextSibling;
		}
		return true;
	},
</P><P>	&quot;:empty&quot;: function(arg, node, token)
	{
		var n = node.firstChild;
		while (n)
		{
			switch(n.nodeType)
			{
				case 1: // Node.ELEMENT_NODE
				case 3: // Node.TEXT_NODE
				case 4: // Node.CDATA_NODE
				case 5: // Node.ENTITY_REFERENCE_NODE
					return false;
			}
			n = n.nextSibling;
		}
		return true;
	},
</P><P>	&quot;:nth-child&quot;: function(arg, node, token)
	{
		return Spry.$$.nthChild(arg, node, token);
	},
</P><P>	&quot;:nth-last-child&quot;: function(arg, node, token)
	{
		return Spry.$$.nthChild(arg, node, token, true);
	},
</P><P>	&quot;:nth-of-type&quot;: function(arg, node, token)
	{
		return Spry.$$.nthChild(arg, node, token, false, true);
	},
</P><P>	&quot;:nth-last-of-type&quot;: function(arg, node, token)
	{
		return Spry.$$.nthChild(arg, node, token, true, true);
	},
</P><P>	&quot;:first-of-type&quot;: function(arg, node, token)
	{
		var nodeName = token.getNodeNameIfTypeMatches(node);
		if (!nodeName) return false;
</P><P>		var n = node.previousSibling;
		while (n)
		{
			if (n.nodeType == 1 &amp;&amp; nodeName == n.nodeName.toLowerCase()) return false; // Node.ELEMENT_NODE
			n = n.previousSibling;
		}
</P><P>		return true;
	},
</P><P>	&quot;:last-of-type&quot;: function(arg, node, token)
	{
		var nodeName = token.getNodeNameIfTypeMatches(node);
		if (!nodeName) return false;
</P><P>	var n = node.nextSibling;
		while (n)
		{
			if (n.nodeType == 1 &amp;&amp; nodeName == n.nodeName.toLowerCase()) // Node.ELEMENT_NODE
				return false;
			n = n.nextSibling;
		}
		return true;
	},
</P><P>	&quot;:only-child&quot;: function(arg, node, token)
	{
		var f = Spry.$$.pseudoFuncs;
		return f[&quot;:first-child&quot;](arg, node, token) &amp;&amp; f[&quot;:last-child&quot;](arg, node, token);
	},
</P><P>	&quot;:only-of-type&quot;: function(arg, node, token)
	{
		var f = Spry.$$.pseudoFuncs;
		return f[&quot;:first-of-type&quot;](arg, node, token) &amp;&amp; f[&quot;:last-of-type&quot;](arg, node, token);
	},
</P><P>	&quot;:not&quot;: function(arg, node, token)
	{
		var s = Spry.$$.tokenizeSequence(arg)[0];
		var t = s ? s[0] : null;
		return !t || !t.match(node);
	},
</P><P>	&quot;:enabled&quot;: function(arg, node, token)
	{
		return !node.disabled;
	},
</P><P>	&quot;:disabled&quot;: function(arg, node, token)
	{
		return node.disabled;
	},
</P><P>	&quot;:checked&quot;: function(arg, node, token)
	{
		return node.checked;
	},
</P><P>	&quot;:root&quot;: function(arg, node, token)
	{
		return node.parentNode &amp;&amp; node.ownerDocument &amp;&amp; node.parentNode == node.ownerDocument;
	}
};
</P><P>Spry.$$.nthRegExp = /((-|[0-9]+)?n)?([+-]?[0-9]*)/;
</P><P>Spry.$$.nthCache = {
	  &quot;even&quot;: { a: 2, b: 0, mode: 1, invalid: false }
	, &quot;odd&quot;:  { a: 2, b: 1, mode: 1, invalid: false }
	, &quot;2n&quot;:   { a: 2, b: 0, mode: 1, invalid: false }
	, &quot;2n+1&quot;: { a: 2, b: 1, mode: 1, invalid: false }
};
</P><P>Spry.$$.parseNthChildString = function(str)
{
	var o = Spry.$$.nthCache[str];
	if (!o)
	{
		var m = str.match(Spry.$$.nthRegExp);
		var n = m[1];
		var a = m[2];
		var b = m[3];
</P><P>		if (!a)
		{
			// An 'a' value was not specified. Was there an 'n' present?
			// If so, we treat it as an increment of 1, otherwise we're
			// in no-repeat mode.
</P><P>			a = n ? 1 : 0;
		}
		else if (a == &quot;-&quot;)
		{
			// The string is using the &quot;-n&quot; short-hand which is
			// short for -1.
</P><P>			a = -1;
		}
		else
		{
			// An integer repeat value for 'a' was specified. Convert
			// it into number.
</P><P>			a = parseInt(a, 10);
		}
</P><P>		// If a 'b' value was specified, turn it into a number.
		// If no 'b' value was specified, default to zero.
</P><P>		b = b ? parseInt(b, 10) : 0;
</P><P>		// Figure out the mode:
		//
		// -1 - repeat backwards
		//  0 - no repeat
		//  1 - repeat forwards
</P><P>		var mode = (a == 0) ? 0 : ((a &gt; 0) ? 1 : -1);
		var invalid = false;
</P><P>		// Fix up 'a' and 'b' for proper repeating.
</P><P>		if (a &gt; 0 &amp;&amp; b &lt; 0)
		{
			b = b % a;
			b = ((b=(b%a)) &lt; 0) ? a + b : b;
		}
		else if (a &lt; 0)
		{
			if (b &lt; 0)
				invalid = true;
			else
				a = Math.abs(a);
		}
</P><P>		o = new Object;
		o.a = a;
		o.b = b;
		o.mode = mode;
		o.invalid = invalid;
</P><P>		Spry.$$.nthCache[str] = o;
	}
</P><P>	return o;
};
</P><P>Spry.$$.nthChild = function(arg, node, token, fromLastSib, matchNodeName)
{
	if (matchNodeName)
	{
		var nodeName = token.getNodeNameIfTypeMatches(node);
		if (!nodeName) return false;
	}
</P><P>	var o = Spry.$$.parseNthChildString(arg);
</P><P>	if (o.invalid)
		return false;
</P><P>	var qidProp = &quot;spry$$ncQueryID&quot;;
	var posProp = &quot;spry$$ncPos&quot;;
	var countProp = &quot;spry$$ncCount&quot;;
	if (matchNodeName)
	{
		qidProp += nodeName;
		posProp += nodeName;
		countProp += nodeName;
	}
</P><P>	var parent = node.parentNode;
	if (parent[qidProp] != Spry.$$.queryID)
	{
		var pos = 0;
		parent[qidProp] = Spry.$$.queryID;
		var c = parent.firstChild;
		while (c)
		{
			if (c.nodeType == 1 &amp;&amp; (!matchNodeName || nodeName == c.nodeName.toLowerCase()))
				c[posProp] = ++pos;
			c = c.nextSibling;
		}
		parent[countProp] = pos;
	}
</P><P>	pos = node[posProp];
	if (fromLastSib)
		pos = parent[countProp] - pos + 1;
</P><P>/*
	var sib = fromLastSib ? &quot;nextSibling&quot; : &quot;previousSibling&quot;;
</P><P>	var pos = 1;
	var n = node[sib];
	while (n)
	{
		if (n.nodeType == 1 &amp;&amp; (!matchNodeName || nodeName == n.nodeName.toLowerCase()))
		{
			if (n == node) break;
			++pos;
		}
		n = n[sib];
	}
</P><UL><LI>/</LI></UL><P>	if (o.mode == 0) // Exact match
		return pos == o.b;
	if (o.mode &gt; 0) // Forward Repeat
		return (pos &lt; o.b) ? false : (!((pos - o.b) % o.a));
	return (pos &gt; o.b) ? false : (!((o.b - pos) % o.a)); // Backward Repeat
};
</P><P>Spry.$$.processTokens = function(tokens, root)
{
	var numTokens = tokens.length;
	var nodeSet = [ root ];
	var combiFunc = null;
</P><P>	for (var i = 0; i &lt; numTokens &amp;&amp; nodeSet.length &gt; 0; i++)
	{
		var t = tokens[i];
		if (t.type == Spry.$$.Token.SELECTOR)
		{
			if (combiFunc)
			{
				nodeSet = combiFunc(nodeSet, t);
				combiFunc = null;
			}
			else
				nodeSet = Spry.$$.getMatchingElements(nodeSet, t);
		}
		else // Spry.$$.Token.COMBINATOR
			combiFunc = Spry.$$.combinatorFuncs[t.name];
	}
	return nodeSet;
};
</P><P>Spry.$$.getMatchingElements = function(nodes, token)
{
	var results = [];
	if (token.id)
	{
		n = nodes[0];
		if (n &amp;&amp; n.ownerDocument)
		{
			var e = n.ownerDocument.getElementById(token.id);
			if (e)
			{
				// XXX: We need to make sure that the element
				//      we found is actually underneath the root
				//      we were given!
</P><P>				if (token.match(e))
					results.push(e);
			}
			return results;
		}
	}
</P><P>	var nn = nodes.length;
	for (var i = 0; i &lt; nn; i++)
	{
		var n = nodes[i];
		// if (token.match(n)) results.push(n);
</P><P>		var ea = n.getElementsByTagName(token.name);
		var ne = ea.length;
		for (var j = 0; j &lt; ne; j++)
		{
			var e = ea[j];
</P><P>			// If the token matches, add it to our results. We have
			// to make sure e is an element because IE6 returns the DOCTYPE
			// tag as a comment when '*' is used in the call to getElementsByTagName().
</P><P>			if (e.nodeType == 1 /* Node.ELEMENT_NODE */ &amp;&amp; token.match(e, true))
				results.push(e);
		}
	}
	return results;
};
</P><P>/*
Spry.$$.dumpSequences = function(sequences)
{
</P>
	Spry.Debug.trace(&quot;Number of Sequences: &quot; + sequences.length);
<P>	for (var i = 0; i &lt; sequences.length; i++)
	{
		var str = &quot;&quot;;
		var s = sequences[i];
</P>
		Spry.Debug.trace(&quot;Sequence &quot; + i + &quot; -- Tokens: &quot; + s.length);
<P>		for (var j = 0; j &lt; s.length; j++)
		{
			var t = s[j];
			if (t.type == Spry.$$.Token.SELECTOR)
			{
				str += &quot;  SELECTOR:\n    Name: &quot; + t.name + &quot;\n    ID: &quot; + t.id + &quot;\n    Attrs:\n&quot;;
				for (var k = 0; k &lt; t.classes.length; k++)
					str += &quot;      &quot; + t.classes[k].name + &quot;: &quot; + t.classes[k].value + &quot;\n&quot;;
				for (var k = 0; k &lt; t.attrs.length; k++)
					str += &quot;      &quot; + t.attrs[k].name + &quot;: &quot; + t.attrs[k].value + &quot;\n&quot;;
				str += &quot;    Pseudos:\n&quot;;
				for (var k = 0; k &lt; t.pseudos.length; k++)
					str += &quot;      &quot; + t.pseudos[k].name + (t.pseudos[k].arg ? &quot;(&quot; + t.pseudos[k].arg + &quot;)&quot; : &quot;&quot;) + &quot;\n&quot;;
			}
			else
			{
				str += &quot;  COMBINATOR:\n    Name: '&quot; + t.name + &quot;'\n&quot;; 
			}
		}
</P>
		Spry.Debug.trace(&quot;<PRE>&quot; + Spry.Utils.encodeEntities(str) + &quot;</PRE>&quot;);
<P>	}
};
</P><UL><LI>/
</LI></UL><P>Spry.$$.addExtensions = function(a)
{
	for (var f in Spry.$$.Results)
		a[f] = Spry.$$.Results[f];
};
</P><P>Spry.$$.Results = {};
</P><P>Spry.$$.Results.forEach = function(func)
{
	var n = this.length;
	for (var i = 0; i &lt; n; i++)
		func(this[i]);
	return this;
};
</P><P>Spry.$$.Results.setAttribute = function(name, value)
{
	return this.forEach(function(n) { Spry.Utils.setAttribute(n, name, value); });
};
</P><P>Spry.$$.Results.removeAttribute = function(name)
{
	return this.forEach(function(n) { Spry.Utils.removeAttribute(n, name); });
};
</P><P>Spry.$$.Results.addClassName = function(className)
{
	return this.forEach(function(n) { Spry.Utils.addClassName(n, className); });
};
</P><P>Spry.$$.Results.removeClassName = function(className)
{
	return this.forEach(function(n) { Spry.Utils.removeClassName(n, className); });
};
</P><P>Spry.$$.Results.toggleClassName = function(className)
{
	return this.forEach(function(n) { Spry.Utils.toggleClassName(n, className); });
};
</P><P>Spry.$$.Results.addEventListener = function(eventType, handler, capture, bindHandler)
{
	return this.forEach(function(n) { Spry.Utils.addEventListener(n, eventType, handler, capture, bindHandler); });
};
</P><P>Spry.$$.Results.removeEventListener = function(eventType, handler, capture)
{
	return this.forEach(function(n) { Spry.Utils.removeEventListener(n, eventType, handler, capture); });
};
</P><P>Spry.$$.Results.setStyle = function(style)
{
	if (style)
	{
		style = Spry.Utils.styleStringToObject(style);
		this.forEach(function(n)
		{
			for (var p in style)
				try { n.style[p] = style[p]; } catch (e) {}
		});
	}
	return this;
};
</P><P>Spry.$$.Results.setProperty = function(prop, value)
{
	if (prop)
	{
		if (typeof prop == &quot;string&quot;)
		{
			var p = {};
			p[prop] = value;
			prop = p;
		}
</P><P>		this.forEach(function(n)
		{
			for (var p in prop)
				try { n[p] = prop[p]; } catch (e) {}
		});
	}
	return this;
};
</P><P>})(); // EndSpryComponent
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2011.igem.org/Team:SYSU-China/temp/SpryDOMUtils.js">http://2011.igem.org/Team:SYSU-China/temp/SpryDOMUtils.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:SYSU-China/temp/SpryDOMUtils.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:SYSU-China/temp/SpryDOMUtils.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryDOMUtils.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:SYSU-China/temp/SpryDOMUtils.js&amp;oldid=231572" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2011.igem.org:Privacy_policy" title="2011.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2011.igem.org:General_disclaimer" title="2011.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
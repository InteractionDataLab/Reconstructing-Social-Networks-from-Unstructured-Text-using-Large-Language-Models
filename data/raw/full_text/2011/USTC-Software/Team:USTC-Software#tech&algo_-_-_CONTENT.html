<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_USTC-Software_tech_algo"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:USTC-Software/tech%26algo">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:USTC-Software/tech%26algo&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:USTC-Software/tech%26algo&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:USTC-Software/tech%26algo&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:USTC-Software/tech%26algo" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:USTC-Software/tech&amp;amp;algo</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2011.igem.org</H3><P><TITLE>Team:USTC-Software - 2011.igem.org/Technology &amp; Algorithm</TITLE></P><DIV id="header_wrapper"><DIV id="header"><DIV id="site_title"><H1> USTC-Software </H1></DIV><UL id="nav"><LI><A href="https://2011.igem.org/Team:USTC-Software">Home</A></LI><LI><A class="on" href="https://2011.igem.org/Team:USTC-Software/project">Project</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/documents">Documents Parser</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/models">Models</A></LI><LI><A href="#">Views</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/aview">Assembly View</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/bview">Behavior View</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/nview">Network View</A></LI></UL><LI><A href="https://2011.igem.org/Team:USTC-Software/tech&amp;algo">Technology &amp; Algorithm</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/tutorial">Tutorial &amp; Demo</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/notebook">Notebook</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/team">Team</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/members">members</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/collaboration">collaboration</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/attribution">attribution &amp; contributions</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/acknowledgements">acknowledgements</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/human practice">Human practice</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/safety">safety</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/meetup">meetup</A></LI><LI><A class="last" href="https://2011.igem.org/Team:USTC-Software/download">Download</A></LI></DIV></DIV><DIV id="content_wrapper"><DIV id="intro"><P> Contents:
   <UL type="square"><LI><A href="#Algorithm"> Algorithm </A></LI><UL type="circle"><LI><A href="#Particle swarm optimization (PSO) Algorithm">Particle swarm optimization (PSO) Algorithm</A></LI><UL type="disc"><LI><A href="#History">History</A></LI><LI><A href="#Algorithm introduction">Algorithm introduction</A></LI><LI><A href="#Application">Application</A></LI></UL></UL><UL type="circle"><LI><A href="#Simulated Annealing(SA) Algorithm">Simulated Annealing(SA) Algorithm</A></LI><UL type="disc"><LI><A href="#Principle of the algorithm">Principle of the algorithm</A></LI><LI><A href="#Steps">Steps</A></LI><LI><A href="#State transition">State transition</A></LI><LI><A href="#Probability function of the state transition">Probability function of the state transition</A></LI></UL></UL><UL type="circle"><LI><A href="#MoDeL">MoDeL</A></LI></UL></UL></P></DIV><H2>Particle swarm optimization (PSO) Algorithm</H2><H3>History</H3><P>Particle swarm optimization (PSO) is a population based stochastic optimization technique developed by Dr. Eberhart and Dr. Kennedy in 1995, 
 inspired by social behavior of bird flocking or fish schooling. The particle swarm concept originated as a simulation of simplified social system. 
 The original intent was to graphically simulate the choreography of bird of a bird block or fish school.
 However, it was found that particle swarm model can be used as an optimizer. </P><H3>Algorithm introduction</H3><P>Each particle keeps track of its coordinates in the problem space which are associated with the best solution (fitness) it has achieved so far. (The fitness value is also stored.)
  This value is called pbest. Another &quot;best&quot; value that is tracked by the particle swarm optimizer is the best value, obtained so far by any particle in the neighbors of the particle. 
  This location is called lbest. when a particle takes all the population as its topological neighbors, the best value is a global best and is called gbest. </P><P>The particle swarm optimization concept consists of, at each time step, changing the velocity of (accelerating) each particle toward its pbest and lbest locations (local version of PSO).
   Acceleration is weighted by a random term, with separate random numbers being generated for acceleration toward pbest and lbest locations.</P><H3>Application</H3><P>PSO has been successfully applied in many research and application areas. 
   It is demonstrated that PSO gets better results in a faster, cheaper way compared with other methods.</P><H2>Simulated Annealing(SA) Algorithm </H2><P>Simulated annealing (SA) is a generic probabilistic metaheuristic for the global optimization problem of locating a good approximation to the global optimum of a given function in a large search space. It is often used when the search space is discrete (e.g., all tours that visit a given set of cities). 
For certain problems, simulated annealing may be more efficient than exhaustive enumeration — provided that the goal is merely to find an acceptably good solution in a fixed amount of time, rather than the best possible solution.</P><H3>Principle of the algorithm</H3><P>In the simulated annealing (SA) method, each point s of the search space is analogous to a state of some physical system, and the function E(s) to be minimized is analogous to the internal energy of the system in that state. 
The goal is to bring the system, from an arbitrary initial state, to a state with the minimum possible energy.</P><H3>Steps</H3><P>At each step, the SA heuristic considers some neighbouring state s' of the current state s, and probabilistically decides between moving the system to state s' or staying in state s. These probabilities ultimately lead the system to move to states of lower energy. 
Typically this step is repeated until the system reaches a state that is good enough for the application, or until a given computation budget has been exhausted.</P><H3>State transition</H3><P>The neighbours of a state are new states of the problem that are produced after altering the given state in some particular way. For example, in the traveling salesman problem, each state is typically defined as a particular permutation of the cities to be visited. The neighbours of some particular permutation are the permutations that are produced for example by interchanging a pair of adjacent cities. 
The action taken to alter the solution in order to find neighbouring solutions is called &quot;move&quot; and different &quot;moves&quot; give different neighbours. These moves usually result in minimal alterations of the solution, as the previous example depicts, in order to help an algorithm to optimize the solution to the maximum extent and also to retain the already optimum parts of the solution and affect only the suboptimum parts. 
In the previous example, the parts of the solution are the parts of the tour.</P><H3>Probability function of the state transition</H3><P>The probability of making the transition from the current state s to a candidate new state s' is specified by an acceptance probability function P(e,e',T), that depends on the energies e = E(s) and e' = E(s') of the two states, and on a global time-varying parameter T called the temperature. States with a smaller energy are better than those with a greater energy. The probability function P must be positive even when e' is greater than e. 
This feature prevents the method from becoming stuck at a local minimum that is worse than the global one.</P><H2>MoDeL</H2><P>The Perl language is a powerful tool for dealing with regular expressions, and it manages to   process complex problems in a timely way. For example, for a hash array with a few elements in the buckets almost get the same manipulating time with a big hash with millions of elements. This feature improves the speed of rule based modeling remarkably.</P><P>Dealing with regular expressions is also Perl's cup of tea. So the software can spend more running time saved by perl on providing a better user's interface, making it more convenient for users.</P><P>Our approach first realized by Liaochen and 2010igemers emphasize on the structure of the species.</P><P>Here is a detailed explanation to the input file of the rule based modeling approach 
There are four blocks, respectively lists the definition of parameters, the definition of compartments, seed species and events.</P><P>The definition of parameters consists of two items. The left side term is the name of the variable, to the right is the expression of that parameter. Note that variables in that expression must be defined by the user. But it makes no difference whether they are defined before the expression. This is to avoid redundant definition and no definition. </P><P>The compartments definition is in this way: [name ][outside][ruletable]{volume}{population}, where terms in the square brackets are mandatory, while terms in the curly braces are optional.
The default value of the volume is 1. The outside term means the compartment outside the compartment, which is usually the medium that held the compartment like the ecoli. 
Ruletable is used to associate a rule in the data base with the compartment. </P><P>The third block, reads [compartment][name][structure][init_concentration]{const}, structure is the definition of the complex structure, const is optional since it's in the curly brace.  If the substance has a const property, then after the substance, write a const. if not, leave it blank.</P><P>The last block is the events definition. The formats are [name][trigger_condition][event_assignments...]
The name of the event is usr defined, trigger_condition is a bool expression, all the variables inside this bool expression must have been defined in one of the above three blocks. Event_assignments is a list of assignments, something like assignment1 assignment2 assignment3, with white space separated. There is no constraint on the number of assignments. Each assignment must be the format [variable]=[expression]</P><P>A general rule in the algorithm is that the name of the variable must be started by A-Z –z and other characters can be A-Z-a-z-0-9.</P><H2>iGAME</H2><P>According to the rule-based languages, such as BNGL[1,2] and Kappa Language[3], molecules are
represented with structured objects comprised of agents that can take any number of sites.
Bonds could be formed by connecting sites on different agents to group them together and
form complex. Typically, sites represent functional physical entities of various kinds of
molecules, such as DNA-binding domains and promoter regions. Besides serving as terminal
ends of bonds, sites can also take on any number of labels representing its internal states.
Labels can be phosphorylation/unphorsphorylation status of proteins and open/close status
of a complex of RNA polymerase and a promoter. Biological processes between agents can be
easily and conveniently represented by the changes of their sites on the binding
status and labels. An example of Lac dimer is given to briefly illustrate the syntax
of this representation. Each Lac repressor, LacR, has one dimerization domain dim and
can thus be written as LacR(dim). By connecting the two dim domains of two LacRs,
the Lac dimer is then represented as LacR(dim!1).LacR(dim!1), where `.' separates different agents
and the same number following `!' shared by two dim domains indicates a bond formation
between them. The essences of those languages are preserved in MoDeL but with some major changes
to make it better suited to describe synthetic biological systems.</P><P>Synthetic biological systems are mostly Genetic Regulatory Networks (GRNs), in which
regulations in both transcriptional and translational level are key to control the system
to exhibit some complex bahaviors, such as oscillation.
DNA sequences composed of basic BioBrick parts (agents) are not consicely represented,
resulting in unreadability of the reaction rules containing such DNA sequences. In their
representations, each part has both upstream and downstream domain and adjacent parts are
connected by forming a bond between the upstream domain of one part and the downstream
domain of the other. In addition, all the agents in Kappa Language are allowed to appear in
any order so that it may blur the recognition of spatial relationship of agents; it is
hard to pick up the agents in a DNA chain with the correct order. For example,
a complex of RNA polymerase binding to trp promoter (MIT registry ID K191007) with LOVTAP
on p2 can be rewritten as `\textbf{\small{DNA(up!2,bind,type$\sim$K191007p3), LOVTAP(dna!1),
DNA(bind!1,type$\sim$K191007p2,down!2), RNAP(dna,rna)}}'. However, most readers, even specialists,
have some difficulties to recognize and map it to the molecule it represents in a short
time, making the process of model contruction laborious and error-prone.</P><P>Aiming to simplify the representation of DNA and RNA sequences, we use the hyphen character `-'
to connect two adjacent BioBricks rather than through bonding between one pair of
upstream and downstream sites. This is good for visualization since the structure of
molecules pictured in this way can be understood eaisly by readers. As to the syntax
of single BioBrick representation, there are some minor differences with Kappa language:
(1) the name of each BioBrick should be the same with the identifier of that BioBrick
in the MIT registry; (2) the reversed sequence of each DNA BioBrick is assumed when an
asterik character `*' appears following its name; But the sites of each BioBrick
are defined in the same way as Kappa Language does and those names should be different
with each other indicating equivalent sites are not supported. For example, the reverse part
of Lac promoter (r0010) can be represented as r0010*(), where sites in the
parenthesis are not shown. It is worthy of nothing that the parenthesis cannot be
omitted even for BioBricks that do not take any sites. By convention,
a DNA sequence written from left to right is assumed to read from 5' end to 3' end.</P><P>As shown in the example of Lac dimer, a molecule may contain several agents as members
separated by `.', by which means an agent is the basic unit of its composition. In MoDeL,
the basic unit, however, has been expanded horizontally to be a sequence and
different sequences, also separated by `.' in the representation, constitute molecules
by forming bonds between them. The concept of sequence is not limited to DNA or RNA chains,
but can be generalized to proteins and non-BioBricks in which cases
each sequence may have only one agent. One example is Isopropyl beta-D-1-thiogalactopyranoside
(IPTG). It has a binding domain \textit{laci} for Lac repressor and thus can be
represented as i0001(laci), where i0001 is not a valid identifier
in MIT registry since IPTG is not a BioBrick part but a conceptual part in our extension,
which can be represented using the same syntax of BioBrick definition. In a short summary,
sequences are chains composed of one or more parts, which are not limited to BioBrick parts or even
not corresponded to any actual entities.</P><P>There is a problem brought by the use of registry identifiers as the name of BioBricks:
in principle, protein coding sequences should also have both RNA and protein
representations and other type of BioBricks, such as promoters, ribosome binding sites and
terminators, should have RNA representations. Each BioBrick, when transcribed or translated
possibly, cannot be distinguished from its DNA, RNA and protein representations simply by
its name and a qualifier is needed to tag a sequence explicitly to tell whether it is a BioBrick
and if it is, which type of representation it belongs to. This can be easily done by adding
a type qualifier preceding a colon character `:' to the head of a sequence representation
to distinguish the four cases. In the current version of MoDeL, the four permitted types
of sequences are DNA(d), RNA(r), Protein(p) and Non-BioBricks(nb), where the character in parenthesis
following each type is the type qualifier used to tag sequences. For example, the tet repressor (tetR)
can be represented as p:c0040(dna), which is totally different with d:c0040(dna), the protein
coding sequence for tetR protein.</P></DIV></DIV><DIV id="mfooter"><UL class="mfooter_menu"><LI><A href="https://2011.igem.org/Team:USTC-Software" target="_parent">Home</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/project" target="_parent">Project</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/notebook" target="_parent">Notebook</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/team" target="_parent">Team</A></LI><LI><A href="https://2011.igem.org/Team:USTC-Software/team" target="_parent">Human Practice</A></LI><LI class="last_menu"><A href="https://2011.igem.org/Team:USTC-Software/download" target="_parent">Download</A></LI></UL><B> Welcome to   <A href="http://en.ustc.edu.cn/" target="_blank">University of Science and Technology of China</A> ! </B></DIV><DIV class="printfooter">
Retrieved from &quot;<A href="http://2011.igem.org/Team:USTC-Software/tech%26algo">http://2011.igem.org/Team:USTC-Software/tech%26algo</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:USTC-Software/tech%26algo" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:USTC-Software/tech%26algo" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:USTC-Software/tech%26algo&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:USTC-Software/tech%26algo&amp;oldid=222520" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2011.igem.org:Privacy_policy" title="2011.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2011.igem.org:General_disclaimer" title="2011.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></BODY></HTML>